{
  "version": 3,
  "sources": ["../src/language-turtle/server.ts"],
  "sourcesContent": ["/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nimport {\r\n\tcreateConnection,\r\n\tTextDocuments,\r\n\tDiagnostic,\r\n\tDiagnosticSeverity,\r\n\tProposedFeatures,\r\n\tInitializeParams,\r\n\tDidChangeConfigurationNotification,\r\n\tCompletionItem,\r\n\tCompletionItemKind,\r\n\tTextDocumentPositionParams,\r\n\tTextDocumentSyncKind,\r\n\tInitializeResult,\r\n\tRange\r\n} from 'vscode-languageserver/node';\r\nimport { TextDocument } from 'vscode-languageserver-textdocument';\r\nimport { IToken, ISemanticError, TurtleParser } from 'millan';\r\n\r\n// TODO:\r\n// * https://code.visualstudio.com/api/language-extensions/syntax-highlight-guide\r\n// * https://code.visualstudio.com/api/references/vscode-api#DocumentSemanticTokensProvider\r\n// * https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#standard-token-types-and-modifiers\r\n\r\nconsole.log('Starting Turtle Language Server');\r\n\r\n// Create a connection for the server, using Node's IPC as a transport.\r\n// Also include all preview / proposed LSP features.\r\nconst connection = createConnection(ProposedFeatures.all);\r\n\r\n// Create a simple text document manager.\r\nconst documents: TextDocuments<TextDocument> = new TextDocuments(TextDocument);\r\n\r\nlet hasConfigurationCapability = false;\r\nlet hasWorkspaceFolderCapability = false;\r\nlet hasDiagnosticRelatedInformationCapability = false;\r\n\r\nconnection.onInitialize((params: InitializeParams) => {\r\n\tconst capabilities = params.capabilities;\r\n\r\n\t// Does the client support the `workspace/configuration` request?\r\n\t// If not, we fall back using global settings.\r\n\thasConfigurationCapability = !!(\r\n\t\tcapabilities.workspace && !!capabilities.workspace.configuration\r\n\t);\r\n\r\n\thasWorkspaceFolderCapability = !!(\r\n\t\tcapabilities.workspace && !!capabilities.workspace.workspaceFolders\r\n\t);\r\n\r\n\thasDiagnosticRelatedInformationCapability = !!(\r\n\t\tcapabilities.textDocument &&\r\n\t\tcapabilities.textDocument.publishDiagnostics &&\r\n\t\tcapabilities.textDocument.publishDiagnostics.relatedInformation\r\n\t);\r\n\r\n\tconnection.console.log(`[Server(${process.pid})] Started and initialize received`);\r\n\r\n\tconst result: InitializeResult = {\r\n\t\tcapabilities: {\r\n\t\t\ttextDocumentSync: TextDocumentSyncKind.Incremental,\r\n\t\t\t// Tell the client that this server supports code completion.\r\n\t\t\tcompletionProvider: {\r\n\t\t\t\tresolveProvider: true\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tif (hasWorkspaceFolderCapability) {\r\n\t\tresult.capabilities.workspace = {\r\n\t\t\tworkspaceFolders: {\r\n\t\t\t\tsupported: true\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\treturn result;\r\n});\r\n\r\nconnection.onInitialized(() => {\r\n\tif (hasConfigurationCapability) {\r\n\t\t// Register for all configuration changes.\r\n\t\tconnection.client.register(DidChangeConfigurationNotification.type, undefined);\r\n\t}\r\n\r\n\tif (hasWorkspaceFolderCapability) {\r\n\t\tconnection.workspace.onDidChangeWorkspaceFolders(_event => {\r\n\t\t\tconnection.console.log('Workspace folder change event received.');\r\n\t\t});\r\n\t}\r\n});\r\n\r\ninterface ParserSettings {\r\n\tmaxNumberOfProblems: number;\r\n}\r\n\r\n// The global settings, used when the `workspace/configuration` request is not supported by the client.\r\n// Please note that this is not the case when using this server with the client provided in this example\r\n// but could happen with other clients.\r\nconst defaultSettings: ParserSettings = { maxNumberOfProblems: 1000 };\r\n\r\nlet globalSettings: ParserSettings = defaultSettings;\r\n\r\n// Cache the settings of all open documents\r\nconst documentSettings: Map<string, Thenable<ParserSettings>> = new Map();\r\n\r\nconnection.onDidChangeConfiguration(change => {\r\n\tif (hasConfigurationCapability) {\r\n\t\t// Reset all cached document settings\r\n\t\tdocumentSettings.clear();\r\n\t} else {\r\n\t\tglobalSettings = <ParserSettings>(\r\n\t\t\t(change.settings.languageServerExample || defaultSettings)\r\n\t\t);\r\n\t}\r\n\r\n\t// Revalidate all open text documents\r\n\tdocuments.all().forEach(validateTextDocument);\r\n});\r\n\r\nfunction getDocumentSettings(resource: string): Thenable<ParserSettings> {\r\n\tif (!hasConfigurationCapability) {\r\n\t\treturn Promise.resolve(globalSettings);\r\n\t}\r\n\r\n\tlet result = documentSettings.get(resource);\r\n\r\n\tif (!result) {\r\n\t\tresult = connection.workspace.getConfiguration({\r\n\t\t\tscopeUri: resource,\r\n\t\t\tsection: 'mentor.config.languageServer'\r\n\t\t});\r\n\r\n\t\tdocumentSettings.set(resource, result);\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\n// Only keep settings for open documents\r\ndocuments.onDidClose(e => {\r\n\tdocumentSettings.delete(e.document.uri);\r\n});\r\n\r\n// The content of a text document has changed. This event is emitted\r\n// when the text document first opened or when its content has changed.\r\ndocuments.onDidChangeContent(change => {\r\n\tvalidateTextDocument(change.document);\r\n});\r\n\r\nfunction getLexDiagnostics(document: TextDocument, tokens: IToken[]) {\r\n\treturn tokens\r\n\t\t.filter((res) => res?.tokenType?.tokenName === 'Unknown')\r\n\t\t.map(\r\n\t\t\t(unknownToken): Diagnostic => ({\r\n\t\t\t\tseverity: DiagnosticSeverity.Error,\r\n\t\t\t\tmessage: `Unknown token`,\r\n\t\t\t\trange: {\r\n\t\t\t\t\tstart: document.positionAt(unknownToken.startOffset),\r\n\t\t\t\t\tend: document.positionAt((unknownToken.endOffset ?? unknownToken.startOffset) + 1),\r\n\t\t\t\t},\r\n\t\t\t})\r\n\t\t);\r\n}\r\n\r\nfunction getParseDiagnostics(document: TextDocument, errors: ISemanticError[]) {\r\n\tconst content = document.getText();\r\n\r\n\treturn errors.map(\r\n\t\t(error): Diagnostic => {\r\n\t\t\tconst { message, context, token } = error;\r\n\r\n\t\t\tconst ruleStack = context ? context.ruleStack : null;\r\n\t\t\tconst source =\r\n\t\t\t\truleStack && ruleStack.length > 0\r\n\t\t\t\t\t? ruleStack[ruleStack.length - 1]\r\n\t\t\t\t\t: undefined;\r\n\r\n\t\t\tconst constructedDiagnostic: Partial<Diagnostic> = {\r\n\t\t\t\tmessage,\r\n\t\t\t\tsource,\r\n\t\t\t\tseverity: DiagnosticSeverity.Error,\r\n\t\t\t};\r\n\r\n\t\t\tif (token.tokenType?.tokenName !== 'EOF') {\r\n\t\t\t\tconstructedDiagnostic.range = Range.create(\r\n\t\t\t\t\tdocument.positionAt(token.startOffset),\r\n\t\t\t\t\tdocument.positionAt((token.endOffset ?? token.startOffset) + 1)\r\n\t\t\t\t);\r\n\t\t\t} else {\r\n\t\t\t\tconst { previousToken = {} } = error as any; // chevrotain doesn't have this typed fully, but it exists for early exit exceptions\r\n\t\t\t\tlet rangeStart;\r\n\t\t\t\tlet rangeEnd;\r\n\r\n\t\t\t\tif (typeof previousToken.endOffset !== 'undefined') {\r\n\t\t\t\t\trangeStart = Math.min(previousToken.endOffset + 1, content.length);\r\n\t\t\t\t\trangeEnd = Math.min(previousToken.endOffset + 2, content.length);\r\n\t\t\t\t} else {\r\n\t\t\t\t\trangeStart = rangeEnd = content.length;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconstructedDiagnostic.range = Range.create(\r\n\t\t\t\t\tdocument.positionAt(rangeStart),\r\n\t\t\t\t\tdocument.positionAt(rangeEnd)\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\treturn constructedDiagnostic as Diagnostic;\r\n\t\t}\r\n\t);\r\n}\r\n\r\nasync function validateTextDocument(document: TextDocument): Promise<void> {\r\n\tconnection.console.log(`[Server(${process.pid} ${document.uri.toString()})] Validating document.`);\r\n\r\n\t// In this simple example we get the settings for every validate run.\r\n\tconst settings = await getDocumentSettings(document.uri);\r\n\r\n\t// The validator creates diagnostics for all uppercase words length 2 and more\r\n\tconst { uri } = document;\r\n\tconst content = document.getText();\r\n\r\n\tif (!content.length) {\r\n\t\tconnection.sendDiagnostics({ uri, diagnostics: [] });\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst parser = new TurtleParser();\r\n\r\n\tconst { cst, errors } = parser.parse(content, 'standard');\r\n\tconst tokens = parser.input;\r\n\r\n\tconnection.console.log(JSON.stringify(tokens));\r\n\r\n\tconst lexDiagnostics = getLexDiagnostics(document, tokens);\r\n\tconst parseDiagnostics = getParseDiagnostics(document, errors);\r\n\r\n\tconnection.console.log(JSON.stringify(lexDiagnostics));\r\n\tconnection.console.log(JSON.stringify(parseDiagnostics));\r\n\r\n\treturn connection.sendDiagnostics({ uri, diagnostics: [...lexDiagnostics, ...parseDiagnostics] });\r\n}\r\n\r\nconnection.onDidChangeWatchedFiles(_change => {\r\n\t// Monitored files have change in VSCode\r\n\tconnection.console.log(`[Server(${process.pid})] Watched files changed.`);\r\n});\r\n\r\n// This handler provides the initial list of the completion items.\r\nconnection.onCompletion(\r\n\t(_textDocumentPosition: TextDocumentPositionParams): CompletionItem[] => {\r\n\t\t// The pass parameter contains the position of the text document in\r\n\t\t// which code complete got requested. For the example we ignore this\r\n\t\t// info and always provide the same completion items.\r\n\t\treturn [\r\n\t\t\t{\r\n\t\t\t\tlabel: 'TypeScript',\r\n\t\t\t\tkind: CompletionItemKind.Text,\r\n\t\t\t\tdata: 1\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tlabel: 'JavaScript',\r\n\t\t\t\tkind: CompletionItemKind.Text,\r\n\t\t\t\tdata: 2\r\n\t\t\t}\r\n\t\t];\r\n\t}\r\n);\r\n\r\n// This handler resolves additional information for the item selected in\r\n// the completion list.\r\nconnection.onCompletionResolve(\r\n\t(item: CompletionItem): CompletionItem => {\r\n\t\tif (item.data === 1) {\r\n\t\t\titem.detail = 'TypeScript details';\r\n\t\t\titem.documentation = 'TypeScript documentation';\r\n\t\t} else if (item.data === 2) {\r\n\t\t\titem.detail = 'JavaScript details';\r\n\t\t\titem.documentation = 'JavaScript documentation';\r\n\t\t}\r\n\t\treturn item;\r\n\t}\r\n);\r\n\r\n// Make the text document manager listen on the connection\r\n// for open, change and close text document events\r\ndocuments.listen(connection);\r\n\r\n// Listen on the connection\r\nconnection.listen();\r\n"],
  "mappings": "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",
  "names": []
}
