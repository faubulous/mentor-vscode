"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __read: () => __read,
  __rest: () => __rest,
  __spread: () => __spread,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
}
function __exportStar(m, exports) {
  for (var p in m)
    if (p !== "default" && !exports.hasOwnProperty(p))
      exports[p] = m[p];
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (Object.hasOwnProperty.call(mod, k))
        result[k] = mod[k];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics, __assign;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// node_modules/n3/src/IRIs.js
var RDF, XSD, SWAP, IRIs_default;
var init_IRIs = __esm({
  "node_modules/n3/src/IRIs.js"() {
    RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
    XSD = "http://www.w3.org/2001/XMLSchema#";
    SWAP = "http://www.w3.org/2000/10/swap/";
    IRIs_default = {
      xsd: {
        decimal: `${XSD}decimal`,
        boolean: `${XSD}boolean`,
        double: `${XSD}double`,
        integer: `${XSD}integer`,
        string: `${XSD}string`
      },
      rdf: {
        type: `${RDF}type`,
        nil: `${RDF}nil`,
        first: `${RDF}first`,
        rest: `${RDF}rest`,
        langString: `${RDF}langString`
      },
      owl: {
        sameAs: "http://www.w3.org/2002/07/owl#sameAs"
      },
      r: {
        forSome: `${SWAP}reify#forSome`,
        forAll: `${SWAP}reify#forAll`
      },
      log: {
        implies: `${SWAP}log#implies`
      }
    };
  }
});

// node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "node_modules/queue-microtask/index.js"(exports, module2) {
    var promise;
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});

// node_modules/n3/src/N3Lexer.js
var import_queue_microtask, xsd, escapeSequence, escapeReplacements, illegalIriChars, lineModeRegExps, invalidRegExp, N3Lexer;
var init_N3Lexer = __esm({
  "node_modules/n3/src/N3Lexer.js"() {
    init_IRIs();
    import_queue_microtask = __toESM(require_queue_microtask());
    ({ xsd } = IRIs_default);
    escapeSequence = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{8})|\\([^])/g;
    escapeReplacements = {
      "\\": "\\",
      "'": "'",
      '"': '"',
      "n": "\n",
      "r": "\r",
      "t": "	",
      "f": "\f",
      "b": "\b",
      "_": "_",
      "~": "~",
      ".": ".",
      "-": "-",
      "!": "!",
      "$": "$",
      "&": "&",
      "(": "(",
      ")": ")",
      "*": "*",
      "+": "+",
      ",": ",",
      ";": ";",
      "=": "=",
      "/": "/",
      "?": "?",
      "#": "#",
      "@": "@",
      "%": "%"
    };
    illegalIriChars = /[\x00-\x20<>\\"\{\}\|\^\`]/;
    lineModeRegExps = {
      _iri: true,
      _unescapedIri: true,
      _simpleQuotedString: true,
      _langcode: true,
      _blank: true,
      _newline: true,
      _comment: true,
      _whitespace: true,
      _endOfFile: true
    };
    invalidRegExp = /$0^/;
    N3Lexer = class {
      constructor(options) {
        this._iri = /^<((?:[^ <>{}\\]|\\[uU])+)>[ \t]*/;
        this._unescapedIri = /^<([^\x00-\x20<>\\"\{\}\|\^\`]*)>[ \t]*/;
        this._simpleQuotedString = /^"([^"\\\r\n]*)"(?=[^"])/;
        this._simpleApostropheString = /^'([^'\\\r\n]*)'(?=[^'])/;
        this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\-])/i;
        this._prefix = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:(?=[#\s<])/;
        this._prefixed = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:((?:(?:[0-:A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])(?:(?:[\.\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])*(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~]))?)?)(?:[ \t]+|(?=\.?[,;!\^\s#()\[\]\{\}"'<>]))/;
        this._variable = /^\?(?:(?:[A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?=[.,;!\^\s#()\[\]\{\}"'<>])/;
        this._blank = /^_:((?:[0-9A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?:[ \t]+|(?=\.?[,;:\s#()\[\]\{\}"'<>]))/;
        this._number = /^[\-+]?(?:(\d+\.\d*|\.?\d+)[eE][\-+]?|\d*(\.)?)\d+(?=\.?[,;:\s#()\[\]\{\}"'<>])/;
        this._boolean = /^(?:true|false)(?=[.,;\s#()\[\]\{\}"'<>])/;
        this._keyword = /^@[a-z]+(?=[\s#<:])/i;
        this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\s#<])/i;
        this._shortPredicates = /^a(?=[\s#()\[\]\{\}"'<>])/;
        this._newline = /^[ \t]*(?:#[^\n\r]*)?(?:\r\n|\n|\r)[ \t]*/;
        this._comment = /#([^\n\r]*)/;
        this._whitespace = /^[ \t]+/;
        this._endOfFile = /^(?:#[^\n\r]*)?$/;
        options = options || {};
        if (this._lineMode = !!options.lineMode) {
          this._n3Mode = false;
          for (const key in this) {
            if (!(key in lineModeRegExps) && this[key] instanceof RegExp)
              this[key] = invalidRegExp;
          }
        } else {
          this._n3Mode = options.n3 !== false;
        }
        this._comments = !!options.comments;
        this._literalClosingPos = 0;
      }
      // ## Private methods
      // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback
      _tokenizeToEnd(callback, inputFinished) {
        let input = this._input;
        let currentLineLength = input.length;
        while (true) {
          let whiteSpaceMatch, comment;
          while (whiteSpaceMatch = this._newline.exec(input)) {
            if (this._comments && (comment = this._comment.exec(whiteSpaceMatch[0])))
              emitToken("comment", comment[1], "", this._line, whiteSpaceMatch[0].length);
            input = input.substr(whiteSpaceMatch[0].length, input.length);
            currentLineLength = input.length;
            this._line++;
          }
          if (!whiteSpaceMatch && (whiteSpaceMatch = this._whitespace.exec(input)))
            input = input.substr(whiteSpaceMatch[0].length, input.length);
          if (this._endOfFile.test(input)) {
            if (inputFinished) {
              if (this._comments && (comment = this._comment.exec(input)))
                emitToken("comment", comment[1], "", this._line, input.length);
              input = null;
              emitToken("eof", "", "", this._line, 0);
            }
            return this._input = input;
          }
          const line = this._line, firstChar = input[0];
          let type = "", value = "", prefix2 = "", match = null, matchLength = 0, inconclusive = false;
          switch (firstChar) {
            case "^":
              if (input.length < 3)
                break;
              else if (input[1] === "^") {
                this._previousMarker = "^^";
                input = input.substr(2);
                if (input[0] !== "<") {
                  inconclusive = true;
                  break;
                }
              } else {
                if (this._n3Mode) {
                  matchLength = 1;
                  type = "^";
                }
                break;
              }
            case "<":
              if (match = this._unescapedIri.exec(input))
                type = "IRI", value = match[1];
              else if (match = this._iri.exec(input)) {
                value = this._unescape(match[1]);
                if (value === null || illegalIriChars.test(value))
                  return reportSyntaxError(this);
                type = "IRI";
              } else if (input.length > 1 && input[1] === "<")
                type = "<<", matchLength = 2;
              else if (this._n3Mode && input.length > 1 && input[1] === "=")
                type = "inverse", matchLength = 2, value = ">";
              break;
            case ">":
              if (input.length > 1 && input[1] === ">")
                type = ">>", matchLength = 2;
              break;
            case "_":
              if ((match = this._blank.exec(input)) || inputFinished && (match = this._blank.exec(`${input} `)))
                type = "blank", prefix2 = "_", value = match[1];
              break;
            case '"':
              if (match = this._simpleQuotedString.exec(input))
                value = match[1];
              else {
                ({ value, matchLength } = this._parseLiteral(input));
                if (value === null)
                  return reportSyntaxError(this);
              }
              if (match !== null || matchLength !== 0) {
                type = "literal";
                this._literalClosingPos = 0;
              }
              break;
            case "'":
              if (!this._lineMode) {
                if (match = this._simpleApostropheString.exec(input))
                  value = match[1];
                else {
                  ({ value, matchLength } = this._parseLiteral(input));
                  if (value === null)
                    return reportSyntaxError(this);
                }
                if (match !== null || matchLength !== 0) {
                  type = "literal";
                  this._literalClosingPos = 0;
                }
              }
              break;
            case "?":
              if (this._n3Mode && (match = this._variable.exec(input)))
                type = "var", value = match[0];
              break;
            case "@":
              if (this._previousMarker === "literal" && (match = this._langcode.exec(input)))
                type = "langcode", value = match[1];
              else if (match = this._keyword.exec(input))
                type = match[0];
              break;
            case ".":
              if (input.length === 1 ? inputFinished : input[1] < "0" || input[1] > "9") {
                type = ".";
                matchLength = 1;
                break;
              }
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
            case "+":
            case "-":
              if (match = this._number.exec(input) || inputFinished && (match = this._number.exec(`${input} `))) {
                type = "literal", value = match[0];
                prefix2 = typeof match[1] === "string" ? xsd.double : typeof match[2] === "string" ? xsd.decimal : xsd.integer;
              }
              break;
            case "B":
            case "b":
            case "p":
            case "P":
            case "G":
            case "g":
              if (match = this._sparqlKeyword.exec(input))
                type = match[0].toUpperCase();
              else
                inconclusive = true;
              break;
            case "f":
            case "t":
              if (match = this._boolean.exec(input))
                type = "literal", value = match[0], prefix2 = xsd.boolean;
              else
                inconclusive = true;
              break;
            case "a":
              if (match = this._shortPredicates.exec(input))
                type = "abbreviation", value = "a";
              else
                inconclusive = true;
              break;
            case "=":
              if (this._n3Mode && input.length > 1) {
                type = "abbreviation";
                if (input[1] !== ">")
                  matchLength = 1, value = "=";
                else
                  matchLength = 2, value = ">";
              }
              break;
            case "!":
              if (!this._n3Mode)
                break;
            case ",":
            case ";":
            case "[":
            case "]":
            case "(":
            case ")":
            case "}":
              if (!this._lineMode) {
                matchLength = 1;
                type = firstChar;
              }
              break;
            case "{":
              if (!this._lineMode && input.length >= 2) {
                if (input[1] === "|")
                  type = "{|", matchLength = 2;
                else
                  type = firstChar, matchLength = 1;
              }
              break;
            case "|":
              if (input.length >= 2 && input[1] === "}")
                type = "|}", matchLength = 2;
              break;
            default:
              inconclusive = true;
          }
          if (inconclusive) {
            if ((this._previousMarker === "@prefix" || this._previousMarker === "PREFIX") && (match = this._prefix.exec(input)))
              type = "prefix", value = match[1] || "";
            else if ((match = this._prefixed.exec(input)) || inputFinished && (match = this._prefixed.exec(`${input} `)))
              type = "prefixed", prefix2 = match[1] || "", value = this._unescape(match[2]);
          }
          if (this._previousMarker === "^^") {
            switch (type) {
              case "prefixed":
                type = "type";
                break;
              case "IRI":
                type = "typeIRI";
                break;
              default:
                type = "";
            }
          }
          if (!type) {
            if (inputFinished || !/^'''|^"""/.test(input) && /\n|\r/.test(input))
              return reportSyntaxError(this);
            else
              return this._input = input;
          }
          const length = matchLength || match[0].length;
          const token = emitToken(type, value, prefix2, line, length);
          this.previousToken = token;
          this._previousMarker = type;
          input = input.substr(length, input.length);
        }
        function emitToken(type, value, prefix2, line, length) {
          const start = input ? currentLineLength - input.length : currentLineLength;
          const end = start + length;
          const token = { type, value, prefix: prefix2, line, start, end };
          callback(null, token);
          return token;
        }
        function reportSyntaxError(self2) {
          callback(self2._syntaxError(/^\S*/.exec(input)[0]));
        }
      }
      // ### `_unescape` replaces N3 escape codes by their corresponding characters
      _unescape(item) {
        let invalid = false;
        const replaced = item.replace(escapeSequence, (sequence, unicode4, unicode8, escapedChar) => {
          if (typeof unicode4 === "string")
            return String.fromCharCode(Number.parseInt(unicode4, 16));
          if (typeof unicode8 === "string") {
            let charCode = Number.parseInt(unicode8, 16);
            return charCode <= 65535 ? String.fromCharCode(Number.parseInt(unicode8, 16)) : String.fromCharCode(55296 + ((charCode -= 65536) >> 10), 56320 + (charCode & 1023));
          }
          if (escapedChar in escapeReplacements)
            return escapeReplacements[escapedChar];
          invalid = true;
          return "";
        });
        return invalid ? null : replaced;
      }
      // ### `_parseLiteral` parses a literal into an unescaped value
      _parseLiteral(input) {
        if (input.length >= 3) {
          const opening = input.match(/^(?:"""|"|'''|'|)/)[0];
          const openingLength = opening.length;
          let closingPos = Math.max(this._literalClosingPos, openingLength);
          while ((closingPos = input.indexOf(opening, closingPos)) > 0) {
            let backslashCount = 0;
            while (input[closingPos - backslashCount - 1] === "\\")
              backslashCount++;
            if (backslashCount % 2 === 0) {
              const raw = input.substring(openingLength, closingPos);
              const lines = raw.split(/\r\n|\r|\n/).length - 1;
              const matchLength = closingPos + openingLength;
              if (openingLength === 1 && lines !== 0 || openingLength === 3 && this._lineMode)
                break;
              this._line += lines;
              return { value: this._unescape(raw), matchLength };
            }
            closingPos++;
          }
          this._literalClosingPos = input.length - openingLength + 1;
        }
        return { value: "", matchLength: 0 };
      }
      // ### `_syntaxError` creates a syntax error for the given issue
      _syntaxError(issue) {
        this._input = null;
        const err = new Error(`Unexpected "${issue}" on line ${this._line}.`);
        err.context = {
          token: void 0,
          line: this._line,
          previousToken: this.previousToken
        };
        return err;
      }
      // ### Strips off any starting UTF BOM mark.
      _readStartingBom(input) {
        return input.startsWith("\uFEFF") ? input.substr(1) : input;
      }
      // ## Public methods
      // ### `tokenize` starts the transformation of an N3 document into an array of tokens.
      // The input can be a string or a stream.
      tokenize(input, callback) {
        this._line = 1;
        if (typeof input === "string") {
          this._input = this._readStartingBom(input);
          if (typeof callback === "function")
            (0, import_queue_microtask.default)(() => this._tokenizeToEnd(callback, true));
          else {
            const tokens = [];
            let error;
            this._tokenizeToEnd((e, t) => e ? error = e : tokens.push(t), true);
            if (error)
              throw error;
            return tokens;
          }
        } else {
          this._pendingBuffer = null;
          if (typeof input.setEncoding === "function")
            input.setEncoding("utf8");
          input.on("data", (data) => {
            if (this._input !== null && data.length !== 0) {
              if (this._pendingBuffer) {
                data = Buffer.concat([this._pendingBuffer, data]);
                this._pendingBuffer = null;
              }
              if (data[data.length - 1] & 128) {
                this._pendingBuffer = data;
              } else {
                if (typeof this._input === "undefined")
                  this._input = this._readStartingBom(typeof data === "string" ? data : data.toString());
                else
                  this._input += data;
                this._tokenizeToEnd(callback, false);
              }
            }
          });
          input.on("end", () => {
            if (typeof this._input === "string")
              this._tokenizeToEnd(callback, true);
          });
          input.on("error", callback);
        }
      }
    };
  }
});

// node_modules/n3/src/N3Util.js
var N3Util_exports = {};
__export(N3Util_exports, {
  inDefaultGraph: () => inDefaultGraph,
  isBlankNode: () => isBlankNode,
  isDefaultGraph: () => isDefaultGraph,
  isLiteral: () => isLiteral,
  isNamedNode: () => isNamedNode,
  isVariable: () => isVariable,
  prefix: () => prefix,
  prefixes: () => prefixes
});
function isNamedNode(term) {
  return !!term && term.termType === "NamedNode";
}
function isBlankNode(term) {
  return !!term && term.termType === "BlankNode";
}
function isLiteral(term) {
  return !!term && term.termType === "Literal";
}
function isVariable(term) {
  return !!term && term.termType === "Variable";
}
function isDefaultGraph(term) {
  return !!term && term.termType === "DefaultGraph";
}
function inDefaultGraph(quad2) {
  return isDefaultGraph(quad2.graph);
}
function prefix(iri, factory) {
  return prefixes({ "": iri.value || iri }, factory)("");
}
function prefixes(defaultPrefixes, factory) {
  const prefixes2 = /* @__PURE__ */ Object.create(null);
  for (const prefix2 in defaultPrefixes)
    processPrefix(prefix2, defaultPrefixes[prefix2]);
  factory = factory || N3DataFactory_default;
  function processPrefix(prefix2, iri) {
    if (typeof iri === "string") {
      const cache = /* @__PURE__ */ Object.create(null);
      prefixes2[prefix2] = (local) => {
        return cache[local] || (cache[local] = factory.namedNode(iri + local));
      };
    } else if (!(prefix2 in prefixes2)) {
      throw new Error(`Unknown prefix: ${prefix2}`);
    }
    return prefixes2[prefix2];
  }
  return processPrefix;
}
var init_N3Util = __esm({
  "node_modules/n3/src/N3Util.js"() {
    init_N3DataFactory();
  }
});

// node_modules/n3/src/N3DataFactory.js
function termFromId(id, factory, nested) {
  factory = factory || DataFactory;
  if (!id)
    return factory.defaultGraph();
  switch (id[0]) {
    case "?":
      return factory.variable(id.substr(1));
    case "_":
      return factory.blankNode(id.substr(2));
    case '"':
      if (factory === DataFactory)
        return new Literal(id);
      if (id[id.length - 1] === '"')
        return factory.literal(id.substr(1, id.length - 2));
      const endPos = id.lastIndexOf('"', id.length - 1);
      return factory.literal(
        id.substr(1, endPos - 1),
        id[endPos + 1] === "@" ? id.substr(endPos + 2) : factory.namedNode(id.substr(endPos + 3))
      );
    case "[":
      id = JSON.parse(id);
      break;
    default:
      if (!nested || !Array.isArray(id)) {
        return factory.namedNode(id);
      }
  }
  return factory.quad(
    termFromId(id[0], factory, true),
    termFromId(id[1], factory, true),
    termFromId(id[2], factory, true),
    id[3] && termFromId(id[3], factory, true)
  );
}
function termToId(term, nested) {
  if (typeof term === "string")
    return term;
  if (term instanceof Term && term.termType !== "Quad")
    return term.id;
  if (!term)
    return DEFAULTGRAPH.id;
  switch (term.termType) {
    case "NamedNode":
      return term.value;
    case "BlankNode":
      return `_:${term.value}`;
    case "Variable":
      return `?${term.value}`;
    case "DefaultGraph":
      return "";
    case "Literal":
      return `"${term.value}"${term.language ? `@${term.language}` : term.datatype && term.datatype.value !== xsd2.string ? `^^${term.datatype.value}` : ""}`;
    case "Quad":
      const res = [
        termToId(term.subject, true),
        termToId(term.predicate, true),
        termToId(term.object, true)
      ];
      if (!isDefaultGraph(term.graph)) {
        res.push(termToId(term.graph, true));
      }
      return nested ? res : JSON.stringify(res);
    default:
      throw new Error(`Unexpected termType: ${term.termType}`);
  }
}
function namedNode(iri) {
  return new NamedNode(iri);
}
function blankNode(name) {
  return new BlankNode(name || `n3-${_blankNodeCounter++}`);
}
function literal(value, languageOrDataType) {
  if (typeof languageOrDataType === "string")
    return new Literal(`"${value}"@${languageOrDataType.toLowerCase()}`);
  let datatype = languageOrDataType ? languageOrDataType.value : "";
  if (datatype === "") {
    if (typeof value === "boolean")
      datatype = xsd2.boolean;
    else if (typeof value === "number") {
      if (Number.isFinite(value))
        datatype = Number.isInteger(value) ? xsd2.integer : xsd2.double;
      else {
        datatype = xsd2.double;
        if (!Number.isNaN(value))
          value = value > 0 ? "INF" : "-INF";
      }
    }
  }
  return datatype === "" || datatype === xsd2.string ? new Literal(`"${value}"`) : new Literal(`"${value}"^^${datatype}`);
}
function variable(name) {
  return new Variable(name);
}
function defaultGraph() {
  return DEFAULTGRAPH;
}
function quad(subject, predicate, object, graph) {
  return new Quad(subject, predicate, object, graph);
}
var rdf, xsd2, DEFAULTGRAPH, _blankNodeCounter, DataFactory, N3DataFactory_default, Term, NamedNode, Literal, BlankNode, Variable, DefaultGraph, Quad;
var init_N3DataFactory = __esm({
  "node_modules/n3/src/N3DataFactory.js"() {
    init_IRIs();
    init_N3Util();
    ({ rdf, xsd: xsd2 } = IRIs_default);
    _blankNodeCounter = 0;
    DataFactory = {
      namedNode,
      blankNode,
      variable,
      literal,
      defaultGraph,
      quad,
      triple: quad
    };
    N3DataFactory_default = DataFactory;
    Term = class {
      constructor(id) {
        this.id = id;
      }
      // ### The value of this term
      get value() {
        return this.id;
      }
      // ### Returns whether this object represents the same term as the other
      equals(other) {
        if (other instanceof Term)
          return this.id === other.id;
        return !!other && this.termType === other.termType && this.value === other.value;
      }
      // ### Implement hashCode for Immutable.js, since we implement `equals`
      // https://immutable-js.com/docs/v4.0.0/ValueObject/#hashCode()
      hashCode() {
        return 0;
      }
      // ### Returns a plain object representation of this term
      toJSON() {
        return {
          termType: this.termType,
          value: this.value
        };
      }
    };
    NamedNode = class extends Term {
      // ### The term type of this term
      get termType() {
        return "NamedNode";
      }
    };
    Literal = class extends Term {
      // ### The term type of this term
      get termType() {
        return "Literal";
      }
      // ### The text value of this literal
      get value() {
        return this.id.substring(1, this.id.lastIndexOf('"'));
      }
      // ### The language of this literal
      get language() {
        const id = this.id;
        let atPos = id.lastIndexOf('"') + 1;
        return atPos < id.length && id[atPos++] === "@" ? id.substr(atPos).toLowerCase() : "";
      }
      // ### The datatype IRI of this literal
      get datatype() {
        return new NamedNode(this.datatypeString);
      }
      // ### The datatype string of this literal
      get datatypeString() {
        const id = this.id, dtPos = id.lastIndexOf('"') + 1;
        const char = dtPos < id.length ? id[dtPos] : "";
        return char === "^" ? id.substr(dtPos + 2) : (
          // If "@" follows, return rdf:langString; xsd:string otherwise
          char !== "@" ? xsd2.string : rdf.langString
        );
      }
      // ### Returns whether this object represents the same term as the other
      equals(other) {
        if (other instanceof Literal)
          return this.id === other.id;
        return !!other && !!other.datatype && this.termType === other.termType && this.value === other.value && this.language === other.language && this.datatype.value === other.datatype.value;
      }
      toJSON() {
        return {
          termType: this.termType,
          value: this.value,
          language: this.language,
          datatype: { termType: "NamedNode", value: this.datatypeString }
        };
      }
    };
    BlankNode = class extends Term {
      constructor(name) {
        super(`_:${name}`);
      }
      // ### The term type of this term
      get termType() {
        return "BlankNode";
      }
      // ### The name of this blank node
      get value() {
        return this.id.substr(2);
      }
    };
    Variable = class extends Term {
      constructor(name) {
        super(`?${name}`);
      }
      // ### The term type of this term
      get termType() {
        return "Variable";
      }
      // ### The name of this variable
      get value() {
        return this.id.substr(1);
      }
    };
    DefaultGraph = class extends Term {
      constructor() {
        super("");
        return DEFAULTGRAPH || this;
      }
      // ### The term type of this term
      get termType() {
        return "DefaultGraph";
      }
      // ### Returns whether this object represents the same term as the other
      equals(other) {
        return this === other || !!other && this.termType === other.termType;
      }
    };
    DEFAULTGRAPH = new DefaultGraph();
    Quad = class extends Term {
      constructor(subject, predicate, object, graph) {
        super("");
        this._subject = subject;
        this._predicate = predicate;
        this._object = object;
        this._graph = graph || DEFAULTGRAPH;
      }
      // ### The term type of this term
      get termType() {
        return "Quad";
      }
      get subject() {
        return this._subject;
      }
      get predicate() {
        return this._predicate;
      }
      get object() {
        return this._object;
      }
      get graph() {
        return this._graph;
      }
      // ### Returns a plain object representation of this quad
      toJSON() {
        return {
          termType: this.termType,
          subject: this._subject.toJSON(),
          predicate: this._predicate.toJSON(),
          object: this._object.toJSON(),
          graph: this._graph.toJSON()
        };
      }
      // ### Returns whether this object represents the same quad as the other
      equals(other) {
        return !!other && this._subject.equals(other.subject) && this._predicate.equals(other.predicate) && this._object.equals(other.object) && this._graph.equals(other.graph);
      }
    };
  }
});

// node_modules/n3/src/N3Parser.js
function noop() {
}
function initDataFactory(parser, factory) {
  const namedNode2 = factory.namedNode;
  parser._namedNode = namedNode2;
  parser._blankNode = factory.blankNode;
  parser._literal = factory.literal;
  parser._variable = factory.variable;
  parser._quad = factory.quad;
  parser.DEFAULTGRAPH = factory.defaultGraph();
  parser.RDF_FIRST = namedNode2(IRIs_default.rdf.first);
  parser.RDF_REST = namedNode2(IRIs_default.rdf.rest);
  parser.RDF_NIL = namedNode2(IRIs_default.rdf.nil);
  parser.N3_FORALL = namedNode2(IRIs_default.r.forAll);
  parser.N3_FORSOME = namedNode2(IRIs_default.r.forSome);
  parser.ABBREVIATIONS = {
    "a": namedNode2(IRIs_default.rdf.type),
    "=": namedNode2(IRIs_default.owl.sameAs),
    ">": namedNode2(IRIs_default.log.implies)
  };
  parser.QUANTIFIERS_GRAPH = namedNode2("urn:n3:quantifiers");
}
var blankNodePrefix, N3Parser;
var init_N3Parser = __esm({
  "node_modules/n3/src/N3Parser.js"() {
    init_N3Lexer();
    init_N3DataFactory();
    init_IRIs();
    blankNodePrefix = 0;
    N3Parser = class {
      constructor(options) {
        this._contextStack = [];
        this._graph = null;
        options = options || {};
        this._setBase(options.baseIRI);
        options.factory && initDataFactory(this, options.factory);
        const format = typeof options.format === "string" ? options.format.match(/\w*$/)[0].toLowerCase() : "", isTurtle = /turtle/.test(format), isTriG = /trig/.test(format), isNTriples = /triple/.test(format), isNQuads = /quad/.test(format), isN3 = this._n3Mode = /n3/.test(format), isLineMode = isNTriples || isNQuads;
        if (!(this._supportsNamedGraphs = !(isTurtle || isN3)))
          this._readPredicateOrNamedGraph = this._readPredicate;
        this._supportsQuads = !(isTurtle || isTriG || isNTriples || isN3);
        this._supportsRDFStar = format === "" || /star|\*$/.test(format);
        if (isLineMode)
          this._resolveRelativeIRI = (iri) => {
            return null;
          };
        this._blankNodePrefix = typeof options.blankNodePrefix !== "string" ? "" : options.blankNodePrefix.replace(/^(?!_:)/, "_:");
        this._lexer = options.lexer || new N3Lexer({ lineMode: isLineMode, n3: isN3 });
        this._explicitQuantifiers = !!options.explicitQuantifiers;
      }
      // ## Static class methods
      // ### `_resetBlankNodePrefix` restarts blank node prefix identification
      static _resetBlankNodePrefix() {
        blankNodePrefix = 0;
      }
      // ## Private methods
      // ### `_setBase` sets the base IRI to resolve relative IRIs
      _setBase(baseIRI) {
        if (!baseIRI) {
          this._base = "";
          this._basePath = "";
        } else {
          const fragmentPos = baseIRI.indexOf("#");
          if (fragmentPos >= 0)
            baseIRI = baseIRI.substr(0, fragmentPos);
          this._base = baseIRI;
          this._basePath = baseIRI.indexOf("/") < 0 ? baseIRI : baseIRI.replace(/[^\/?]*(?:\?.*)?$/, "");
          baseIRI = baseIRI.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\/\/[^\/]*)?/i);
          this._baseRoot = baseIRI[0];
          this._baseScheme = baseIRI[1];
        }
      }
      // ### `_saveContext` stores the current parsing context
      // when entering a new scope (list, blank node, formula)
      _saveContext(type, graph, subject, predicate, object) {
        const n3Mode = this._n3Mode;
        this._contextStack.push({
          type,
          subject,
          predicate,
          object,
          graph,
          inverse: n3Mode ? this._inversePredicate : false,
          blankPrefix: n3Mode ? this._prefixes._ : "",
          quantified: n3Mode ? this._quantified : null
        });
        if (n3Mode) {
          this._inversePredicate = false;
          this._prefixes._ = this._graph ? `${this._graph.value}.` : ".";
          this._quantified = Object.create(this._quantified);
        }
      }
      // ### `_restoreContext` restores the parent context
      // when leaving a scope (list, blank node, formula)
      _restoreContext(type, token) {
        const context = this._contextStack.pop();
        if (!context || context.type !== type)
          return this._error(`Unexpected ${token.type}`, token);
        this._subject = context.subject;
        this._predicate = context.predicate;
        this._object = context.object;
        this._graph = context.graph;
        if (this._n3Mode) {
          this._inversePredicate = context.inverse;
          this._prefixes._ = context.blankPrefix;
          this._quantified = context.quantified;
        }
      }
      // ### `_readInTopContext` reads a token when in the top context
      _readInTopContext(token) {
        switch (token.type) {
          case "eof":
            if (this._graph !== null)
              return this._error("Unclosed graph", token);
            delete this._prefixes._;
            return this._callback(null, null, this._prefixes);
          case "PREFIX":
            this._sparqlStyle = true;
          case "@prefix":
            return this._readPrefix;
          case "BASE":
            this._sparqlStyle = true;
          case "@base":
            return this._readBaseIRI;
          case "{":
            if (this._supportsNamedGraphs) {
              this._graph = "";
              this._subject = null;
              return this._readSubject;
            }
          case "GRAPH":
            if (this._supportsNamedGraphs)
              return this._readNamedGraphLabel;
          default:
            return this._readSubject(token);
        }
      }
      // ### `_readEntity` reads an IRI, prefixed name, blank node, or variable
      _readEntity(token, quantifier) {
        let value;
        switch (token.type) {
          case "IRI":
          case "typeIRI":
            const iri = this._resolveIRI(token.value);
            if (iri === null)
              return this._error("Invalid IRI", token);
            value = this._namedNode(iri);
            break;
          case "type":
          case "prefixed":
            const prefix2 = this._prefixes[token.prefix];
            if (prefix2 === void 0)
              return this._error(`Undefined prefix "${token.prefix}:"`, token);
            value = this._namedNode(prefix2 + token.value);
            break;
          case "blank":
            value = this._blankNode(this._prefixes[token.prefix] + token.value);
            break;
          case "var":
            value = this._variable(token.value.substr(1));
            break;
          default:
            return this._error(`Expected entity but got ${token.type}`, token);
        }
        if (!quantifier && this._n3Mode && value.id in this._quantified)
          value = this._quantified[value.id];
        return value;
      }
      // ### `_readSubject` reads a quad's subject
      _readSubject(token) {
        this._predicate = null;
        switch (token.type) {
          case "[":
            this._saveContext(
              "blank",
              this._graph,
              this._subject = this._blankNode(),
              null,
              null
            );
            return this._readBlankNodeHead;
          case "(":
            this._saveContext("list", this._graph, this.RDF_NIL, null, null);
            this._subject = null;
            return this._readListItem;
          case "{":
            if (!this._n3Mode)
              return this._error("Unexpected graph", token);
            this._saveContext(
              "formula",
              this._graph,
              this._graph = this._blankNode(),
              null,
              null
            );
            return this._readSubject;
          case "}":
            return this._readPunctuation(token);
          case "@forSome":
            if (!this._n3Mode)
              return this._error('Unexpected "@forSome"', token);
            this._subject = null;
            this._predicate = this.N3_FORSOME;
            this._quantifier = this._blankNode;
            return this._readQuantifierList;
          case "@forAll":
            if (!this._n3Mode)
              return this._error('Unexpected "@forAll"', token);
            this._subject = null;
            this._predicate = this.N3_FORALL;
            this._quantifier = this._variable;
            return this._readQuantifierList;
          case "literal":
            if (!this._n3Mode)
              return this._error("Unexpected literal", token);
            if (token.prefix.length === 0) {
              this._literalValue = token.value;
              return this._completeSubjectLiteral;
            } else
              this._subject = this._literal(token.value, this._namedNode(token.prefix));
            break;
          case "<<":
            if (!this._supportsRDFStar)
              return this._error("Unexpected RDF* syntax", token);
            this._saveContext("<<", this._graph, null, null, null);
            this._graph = null;
            return this._readSubject;
          default:
            if ((this._subject = this._readEntity(token)) === void 0)
              return;
            if (this._n3Mode)
              return this._getPathReader(this._readPredicateOrNamedGraph);
        }
        return this._readPredicateOrNamedGraph;
      }
      // ### `_readPredicate` reads a quad's predicate
      _readPredicate(token) {
        const type = token.type;
        switch (type) {
          case "inverse":
            this._inversePredicate = true;
          case "abbreviation":
            this._predicate = this.ABBREVIATIONS[token.value];
            break;
          case ".":
          case "]":
          case "}":
            if (this._predicate === null)
              return this._error(`Unexpected ${type}`, token);
            this._subject = null;
            return type === "]" ? this._readBlankNodeTail(token) : this._readPunctuation(token);
          case ";":
            return this._predicate !== null ? this._readPredicate : this._error("Expected predicate but got ;", token);
          case "[":
            if (this._n3Mode) {
              this._saveContext(
                "blank",
                this._graph,
                this._subject,
                this._subject = this._blankNode(),
                null
              );
              return this._readBlankNodeHead;
            }
          case "blank":
            if (!this._n3Mode)
              return this._error("Disallowed blank node as predicate", token);
          default:
            if ((this._predicate = this._readEntity(token)) === void 0)
              return;
        }
        return this._readObject;
      }
      // ### `_readObject` reads a quad's object
      _readObject(token) {
        switch (token.type) {
          case "literal":
            if (token.prefix.length === 0) {
              this._literalValue = token.value;
              return this._readDataTypeOrLang;
            } else
              this._object = this._literal(token.value, this._namedNode(token.prefix));
            break;
          case "[":
            this._saveContext(
              "blank",
              this._graph,
              this._subject,
              this._predicate,
              this._subject = this._blankNode()
            );
            return this._readBlankNodeHead;
          case "(":
            this._saveContext("list", this._graph, this._subject, this._predicate, this.RDF_NIL);
            this._subject = null;
            return this._readListItem;
          case "{":
            if (!this._n3Mode)
              return this._error("Unexpected graph", token);
            this._saveContext(
              "formula",
              this._graph,
              this._subject,
              this._predicate,
              this._graph = this._blankNode()
            );
            return this._readSubject;
          case "<<":
            if (!this._supportsRDFStar)
              return this._error("Unexpected RDF* syntax", token);
            this._saveContext("<<", this._graph, this._subject, this._predicate, null);
            this._graph = null;
            return this._readSubject;
          default:
            if ((this._object = this._readEntity(token)) === void 0)
              return;
            if (this._n3Mode)
              return this._getPathReader(this._getContextEndReader());
        }
        return this._getContextEndReader();
      }
      // ### `_readPredicateOrNamedGraph` reads a quad's predicate, or a named graph
      _readPredicateOrNamedGraph(token) {
        return token.type === "{" ? this._readGraph(token) : this._readPredicate(token);
      }
      // ### `_readGraph` reads a graph
      _readGraph(token) {
        if (token.type !== "{")
          return this._error(`Expected graph but got ${token.type}`, token);
        this._graph = this._subject, this._subject = null;
        return this._readSubject;
      }
      // ### `_readBlankNodeHead` reads the head of a blank node
      _readBlankNodeHead(token) {
        if (token.type === "]") {
          this._subject = null;
          return this._readBlankNodeTail(token);
        } else {
          this._predicate = null;
          return this._readPredicate(token);
        }
      }
      // ### `_readBlankNodeTail` reads the end of a blank node
      _readBlankNodeTail(token) {
        if (token.type !== "]")
          return this._readBlankNodePunctuation(token);
        if (this._subject !== null)
          this._emit(this._subject, this._predicate, this._object, this._graph);
        const empty = this._predicate === null;
        this._restoreContext("blank", token);
        if (this._object !== null)
          return this._getContextEndReader();
        else if (this._predicate !== null)
          return this._readObject;
        else
          return empty ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank;
      }
      // ### `_readPredicateAfterBlank` reads a predicate after an anonymous blank node
      _readPredicateAfterBlank(token) {
        switch (token.type) {
          case ".":
          case "}":
            this._subject = null;
            return this._readPunctuation(token);
          default:
            return this._readPredicate(token);
        }
      }
      // ### `_readListItem` reads items from a list
      _readListItem(token) {
        let item = null, list = null, next = this._readListItem;
        const previousList = this._subject, stack = this._contextStack, parent = stack[stack.length - 1];
        switch (token.type) {
          case "[":
            this._saveContext(
              "blank",
              this._graph,
              list = this._blankNode(),
              this.RDF_FIRST,
              this._subject = item = this._blankNode()
            );
            next = this._readBlankNodeHead;
            break;
          case "(":
            this._saveContext(
              "list",
              this._graph,
              list = this._blankNode(),
              this.RDF_FIRST,
              this.RDF_NIL
            );
            this._subject = null;
            break;
          case ")":
            this._restoreContext("list", token);
            if (stack.length !== 0 && stack[stack.length - 1].type === "list")
              this._emit(this._subject, this._predicate, this._object, this._graph);
            if (this._predicate === null) {
              next = this._readPredicate;
              if (this._subject === this.RDF_NIL)
                return next;
            } else {
              next = this._getContextEndReader();
              if (this._object === this.RDF_NIL)
                return next;
            }
            list = this.RDF_NIL;
            break;
          case "literal":
            if (token.prefix.length === 0) {
              this._literalValue = token.value;
              next = this._readListItemDataTypeOrLang;
            } else {
              item = this._literal(token.value, this._namedNode(token.prefix));
              next = this._getContextEndReader();
            }
            break;
          case "{":
            if (!this._n3Mode)
              return this._error("Unexpected graph", token);
            this._saveContext(
              "formula",
              this._graph,
              this._subject,
              this._predicate,
              this._graph = this._blankNode()
            );
            return this._readSubject;
          default:
            if ((item = this._readEntity(token)) === void 0)
              return;
        }
        if (list === null)
          this._subject = list = this._blankNode();
        if (previousList === null) {
          if (parent.predicate === null)
            parent.subject = list;
          else
            parent.object = list;
        } else {
          this._emit(previousList, this.RDF_REST, list, this._graph);
        }
        if (item !== null) {
          if (this._n3Mode && (token.type === "IRI" || token.type === "prefixed")) {
            this._saveContext("item", this._graph, list, this.RDF_FIRST, item);
            this._subject = item, this._predicate = null;
            return this._getPathReader(this._readListItem);
          }
          this._emit(list, this.RDF_FIRST, item, this._graph);
        }
        return next;
      }
      // ### `_readDataTypeOrLang` reads an _optional_ datatype or language
      _readDataTypeOrLang(token) {
        return this._completeObjectLiteral(token, false);
      }
      // ### `_readListItemDataTypeOrLang` reads an _optional_ datatype or language in a list
      _readListItemDataTypeOrLang(token) {
        return this._completeObjectLiteral(token, true);
      }
      // ### `_completeLiteral` completes a literal with an optional datatype or language
      _completeLiteral(token) {
        let literal2 = this._literal(this._literalValue);
        switch (token.type) {
          case "type":
          case "typeIRI":
            const datatype = this._readEntity(token);
            if (datatype === void 0)
              return;
            literal2 = this._literal(this._literalValue, datatype);
            token = null;
            break;
          case "langcode":
            literal2 = this._literal(this._literalValue, token.value);
            token = null;
            break;
        }
        return { token, literal: literal2 };
      }
      // Completes a literal in subject position
      _completeSubjectLiteral(token) {
        this._subject = this._completeLiteral(token).literal;
        return this._readPredicateOrNamedGraph;
      }
      // Completes a literal in object position
      _completeObjectLiteral(token, listItem) {
        const completed = this._completeLiteral(token);
        if (!completed)
          return;
        this._object = completed.literal;
        if (listItem)
          this._emit(this._subject, this.RDF_FIRST, this._object, this._graph);
        if (completed.token === null)
          return this._getContextEndReader();
        else {
          this._readCallback = this._getContextEndReader();
          return this._readCallback(completed.token);
        }
      }
      // ### `_readFormulaTail` reads the end of a formula
      _readFormulaTail(token) {
        if (token.type !== "}")
          return this._readPunctuation(token);
        if (this._subject !== null)
          this._emit(this._subject, this._predicate, this._object, this._graph);
        this._restoreContext("formula", token);
        return this._object === null ? this._readPredicate : this._getContextEndReader();
      }
      // ### `_readPunctuation` reads punctuation between quads or quad parts
      _readPunctuation(token) {
        let next, graph = this._graph;
        const subject = this._subject, inversePredicate = this._inversePredicate;
        switch (token.type) {
          case "}":
            if (this._graph === null)
              return this._error("Unexpected graph closing", token);
            if (this._n3Mode)
              return this._readFormulaTail(token);
            this._graph = null;
          case ".":
            this._subject = null;
            next = this._contextStack.length ? this._readSubject : this._readInTopContext;
            if (inversePredicate)
              this._inversePredicate = false;
            break;
          case ";":
            next = this._readPredicate;
            break;
          case ",":
            next = this._readObject;
            break;
          case "{|":
            if (!this._supportsRDFStar)
              return this._error("Unexpected RDF* syntax", token);
            const predicate = this._predicate, object = this._object;
            this._subject = this._quad(subject, predicate, object, this.DEFAULTGRAPH);
            next = this._readPredicate;
            break;
          case "|}":
            if (this._subject.termType !== "Quad")
              return this._error("Unexpected asserted triple closing", token);
            this._subject = null;
            next = this._readPunctuation;
            break;
          default:
            if (this._supportsQuads && this._graph === null && (graph = this._readEntity(token)) !== void 0) {
              next = this._readQuadPunctuation;
              break;
            }
            return this._error(`Expected punctuation to follow "${this._object.id}"`, token);
        }
        if (subject !== null) {
          const predicate = this._predicate, object = this._object;
          if (!inversePredicate)
            this._emit(subject, predicate, object, graph);
          else
            this._emit(object, predicate, subject, graph);
        }
        return next;
      }
      // ### `_readBlankNodePunctuation` reads punctuation in a blank node
      _readBlankNodePunctuation(token) {
        let next;
        switch (token.type) {
          case ";":
            next = this._readPredicate;
            break;
          case ",":
            next = this._readObject;
            break;
          default:
            return this._error(`Expected punctuation to follow "${this._object.id}"`, token);
        }
        this._emit(this._subject, this._predicate, this._object, this._graph);
        return next;
      }
      // ### `_readQuadPunctuation` reads punctuation after a quad
      _readQuadPunctuation(token) {
        if (token.type !== ".")
          return this._error("Expected dot to follow quad", token);
        return this._readInTopContext;
      }
      // ### `_readPrefix` reads the prefix of a prefix declaration
      _readPrefix(token) {
        if (token.type !== "prefix")
          return this._error("Expected prefix to follow @prefix", token);
        this._prefix = token.value;
        return this._readPrefixIRI;
      }
      // ### `_readPrefixIRI` reads the IRI of a prefix declaration
      _readPrefixIRI(token) {
        if (token.type !== "IRI")
          return this._error(`Expected IRI to follow prefix "${this._prefix}:"`, token);
        const prefixNode = this._readEntity(token);
        this._prefixes[this._prefix] = prefixNode.value;
        this._prefixCallback(this._prefix, prefixNode);
        return this._readDeclarationPunctuation;
      }
      // ### `_readBaseIRI` reads the IRI of a base declaration
      _readBaseIRI(token) {
        const iri = token.type === "IRI" && this._resolveIRI(token.value);
        if (!iri)
          return this._error("Expected valid IRI to follow base declaration", token);
        this._setBase(iri);
        return this._readDeclarationPunctuation;
      }
      // ### `_readNamedGraphLabel` reads the label of a named graph
      _readNamedGraphLabel(token) {
        switch (token.type) {
          case "IRI":
          case "blank":
          case "prefixed":
            return this._readSubject(token), this._readGraph;
          case "[":
            return this._readNamedGraphBlankLabel;
          default:
            return this._error("Invalid graph label", token);
        }
      }
      // ### `_readNamedGraphLabel` reads a blank node label of a named graph
      _readNamedGraphBlankLabel(token) {
        if (token.type !== "]")
          return this._error("Invalid graph label", token);
        this._subject = this._blankNode();
        return this._readGraph;
      }
      // ### `_readDeclarationPunctuation` reads the punctuation of a declaration
      _readDeclarationPunctuation(token) {
        if (this._sparqlStyle) {
          this._sparqlStyle = false;
          return this._readInTopContext(token);
        }
        if (token.type !== ".")
          return this._error("Expected declaration to end with a dot", token);
        return this._readInTopContext;
      }
      // Reads a list of quantified symbols from a @forSome or @forAll statement
      _readQuantifierList(token) {
        let entity;
        switch (token.type) {
          case "IRI":
          case "prefixed":
            if ((entity = this._readEntity(token, true)) !== void 0)
              break;
          default:
            return this._error(`Unexpected ${token.type}`, token);
        }
        if (!this._explicitQuantifiers)
          this._quantified[entity.id] = this._quantifier(this._blankNode().value);
        else {
          if (this._subject === null)
            this._emit(
              this._graph || this.DEFAULTGRAPH,
              this._predicate,
              this._subject = this._blankNode(),
              this.QUANTIFIERS_GRAPH
            );
          else
            this._emit(
              this._subject,
              this.RDF_REST,
              this._subject = this._blankNode(),
              this.QUANTIFIERS_GRAPH
            );
          this._emit(this._subject, this.RDF_FIRST, entity, this.QUANTIFIERS_GRAPH);
        }
        return this._readQuantifierPunctuation;
      }
      // Reads punctuation from a @forSome or @forAll statement
      _readQuantifierPunctuation(token) {
        if (token.type === ",")
          return this._readQuantifierList;
        else {
          if (this._explicitQuantifiers) {
            this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH);
            this._subject = null;
          }
          this._readCallback = this._getContextEndReader();
          return this._readCallback(token);
        }
      }
      // ### `_getPathReader` reads a potential path and then resumes with the given function
      _getPathReader(afterPath) {
        this._afterPath = afterPath;
        return this._readPath;
      }
      // ### `_readPath` reads a potential path
      _readPath(token) {
        switch (token.type) {
          case "!":
            return this._readForwardPath;
          case "^":
            return this._readBackwardPath;
          default:
            const stack = this._contextStack, parent = stack.length && stack[stack.length - 1];
            if (parent && parent.type === "item") {
              const item = this._subject;
              this._restoreContext("item", token);
              this._emit(this._subject, this.RDF_FIRST, item, this._graph);
            }
            return this._afterPath(token);
        }
      }
      // ### `_readForwardPath` reads a '!' path
      _readForwardPath(token) {
        let subject, predicate;
        const object = this._blankNode();
        if ((predicate = this._readEntity(token)) === void 0)
          return;
        if (this._predicate === null)
          subject = this._subject, this._subject = object;
        else
          subject = this._object, this._object = object;
        this._emit(subject, predicate, object, this._graph);
        return this._readPath;
      }
      // ### `_readBackwardPath` reads a '^' path
      _readBackwardPath(token) {
        const subject = this._blankNode();
        let predicate, object;
        if ((predicate = this._readEntity(token)) === void 0)
          return;
        if (this._predicate === null)
          object = this._subject, this._subject = subject;
        else
          object = this._object, this._object = subject;
        this._emit(subject, predicate, object, this._graph);
        return this._readPath;
      }
      // ### `_readRDFStarTailOrGraph` reads the graph of a nested RDF* quad or the end of a nested RDF* triple
      _readRDFStarTailOrGraph(token) {
        if (token.type !== ">>") {
          if (this._supportsQuads && this._graph === null && (this._graph = this._readEntity(token)) !== void 0)
            return this._readRDFStarTail;
          return this._error(`Expected >> to follow "${this._object.id}"`, token);
        }
        return this._readRDFStarTail(token);
      }
      // ### `_readRDFStarTail` reads the end of a nested RDF* triple
      _readRDFStarTail(token) {
        if (token.type !== ">>")
          return this._error(`Expected >> but got ${token.type}`, token);
        const quad2 = this._quad(
          this._subject,
          this._predicate,
          this._object,
          this._graph || this.DEFAULTGRAPH
        );
        this._restoreContext("<<", token);
        if (this._subject === null) {
          this._subject = quad2;
          return this._readPredicate;
        } else {
          this._object = quad2;
          return this._getContextEndReader();
        }
      }
      // ### `_getContextEndReader` gets the next reader function at the end of a context
      _getContextEndReader() {
        const contextStack = this._contextStack;
        if (!contextStack.length)
          return this._readPunctuation;
        switch (contextStack[contextStack.length - 1].type) {
          case "blank":
            return this._readBlankNodeTail;
          case "list":
            return this._readListItem;
          case "formula":
            return this._readFormulaTail;
          case "<<":
            return this._readRDFStarTailOrGraph;
        }
      }
      // ### `_emit` sends a quad through the callback
      _emit(subject, predicate, object, graph) {
        this._callback(null, this._quad(subject, predicate, object, graph || this.DEFAULTGRAPH));
      }
      // ### `_error` emits an error message through the callback
      _error(message, token) {
        const err = new Error(`${message} on line ${token.line}.`);
        err.context = {
          token,
          line: token.line,
          previousToken: this._lexer.previousToken
        };
        this._callback(err);
        this._callback = noop;
      }
      // ### `_resolveIRI` resolves an IRI against the base path
      _resolveIRI(iri) {
        return /^[a-z][a-z0-9+.-]*:/i.test(iri) ? iri : this._resolveRelativeIRI(iri);
      }
      // ### `_resolveRelativeIRI` resolves an IRI against the base path,
      // assuming that a base path has been set and that the IRI is indeed relative
      _resolveRelativeIRI(iri) {
        if (!iri.length)
          return this._base;
        switch (iri[0]) {
          case "#":
            return this._base + iri;
          case "?":
            return this._base.replace(/(?:\?.*)?$/, iri);
          case "/":
            return (iri[1] === "/" ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);
          default:
            return /^[^/:]*:/.test(iri) ? null : this._removeDotSegments(this._basePath + iri);
        }
      }
      // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986
      _removeDotSegments(iri) {
        if (!/(^|\/)\.\.?($|[/#?])/.test(iri))
          return iri;
        const length = iri.length;
        let result = "", i = -1, pathStart = -1, segmentStart = 0, next = "/";
        while (i < length) {
          switch (next) {
            case ":":
              if (pathStart < 0) {
                if (iri[++i] === "/" && iri[++i] === "/")
                  while ((pathStart = i + 1) < length && iri[pathStart] !== "/")
                    i = pathStart;
              }
              break;
            case "?":
            case "#":
              i = length;
              break;
            case "/":
              if (iri[i + 1] === ".") {
                next = iri[++i + 1];
                switch (next) {
                  case "/":
                    result += iri.substring(segmentStart, i - 1);
                    segmentStart = i + 1;
                    break;
                  case void 0:
                  case "?":
                  case "#":
                    return result + iri.substring(segmentStart, i) + iri.substr(i + 1);
                  case ".":
                    next = iri[++i + 1];
                    if (next === void 0 || next === "/" || next === "?" || next === "#") {
                      result += iri.substring(segmentStart, i - 2);
                      if ((segmentStart = result.lastIndexOf("/")) >= pathStart)
                        result = result.substr(0, segmentStart);
                      if (next !== "/")
                        return `${result}/${iri.substr(i + 1)}`;
                      segmentStart = i + 1;
                    }
                }
              }
          }
          next = iri[++i];
        }
        return result + iri.substring(segmentStart);
      }
      // ## Public methods
      // ### `parse` parses the N3 input and emits each parsed quad through the callback
      parse(input, quadCallback, prefixCallback) {
        this._readCallback = this._readInTopContext;
        this._sparqlStyle = false;
        this._prefixes = /* @__PURE__ */ Object.create(null);
        this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2) : `b${blankNodePrefix++}_`;
        this._prefixCallback = prefixCallback || noop;
        this._inversePredicate = false;
        this._quantified = /* @__PURE__ */ Object.create(null);
        if (!quadCallback) {
          const quads = [];
          let error;
          this._callback = (e, t) => {
            e ? error = e : t && quads.push(t);
          };
          this._lexer.tokenize(input).every((token) => {
            return this._readCallback = this._readCallback(token);
          });
          if (error)
            throw error;
          return quads;
        }
        this._callback = quadCallback;
        this._lexer.tokenize(input, (error, token) => {
          if (error !== null)
            this._callback(error), this._callback = noop;
          else if (this._readCallback)
            this._readCallback = this._readCallback(token);
        });
      }
    };
    initDataFactory(N3Parser.prototype, N3DataFactory_default);
  }
});

// node_modules/n3/src/N3Writer.js
function characterReplacer(character) {
  let result = escapedCharacters[character];
  if (result === void 0) {
    if (character.length === 1) {
      result = character.charCodeAt(0).toString(16);
      result = "\\u0000".substr(0, 6 - result.length) + result;
    } else {
      result = ((character.charCodeAt(0) - 55296) * 1024 + character.charCodeAt(1) + 9216).toString(16);
      result = "\\U00000000".substr(0, 10 - result.length) + result;
    }
  }
  return result;
}
function escapeRegex(regex) {
  return regex.replace(/[\]\/\(\)\*\+\?\.\\\$]/g, "\\$&");
}
var DEFAULTGRAPH2, rdf2, xsd3, escape, escapeAll, escapedCharacters, SerializedTerm, N3Writer;
var init_N3Writer = __esm({
  "node_modules/n3/src/N3Writer.js"() {
    init_IRIs();
    init_N3DataFactory();
    init_N3Util();
    DEFAULTGRAPH2 = N3DataFactory_default.defaultGraph();
    ({ rdf: rdf2, xsd: xsd3 } = IRIs_default);
    escape = /["\\\t\n\r\b\f\u0000-\u0019\ud800-\udbff]/;
    escapeAll = /["\\\t\n\r\b\f\u0000-\u0019]|[\ud800-\udbff][\udc00-\udfff]/g;
    escapedCharacters = {
      "\\": "\\\\",
      '"': '\\"',
      "	": "\\t",
      "\n": "\\n",
      "\r": "\\r",
      "\b": "\\b",
      "\f": "\\f"
    };
    SerializedTerm = class extends Term {
      // Pretty-printed nodes are not equal to any other node
      // (e.g., [] does not equal [])
      equals(other) {
        return other === this;
      }
    };
    N3Writer = class {
      constructor(outputStream, options) {
        this._prefixRegex = /$0^/;
        if (outputStream && typeof outputStream.write !== "function")
          options = outputStream, outputStream = null;
        options = options || {};
        this._lists = options.lists;
        if (!outputStream) {
          let output = "";
          this._outputStream = {
            write(chunk, encoding, done) {
              output += chunk;
              done && done();
            },
            end: (done) => {
              done && done(null, output);
            }
          };
          this._endStream = true;
        } else {
          this._outputStream = outputStream;
          this._endStream = options.end === void 0 ? true : !!options.end;
        }
        this._subject = null;
        if (!/triple|quad/i.test(options.format)) {
          this._lineMode = false;
          this._graph = DEFAULTGRAPH2;
          this._prefixIRIs = /* @__PURE__ */ Object.create(null);
          options.prefixes && this.addPrefixes(options.prefixes);
          if (options.baseIRI) {
            this._baseMatcher = new RegExp(`^${escapeRegex(options.baseIRI)}${options.baseIRI.endsWith("/") ? "" : "[#?]"}`);
            this._baseLength = options.baseIRI.length;
          }
        } else {
          this._lineMode = true;
          this._writeQuad = this._writeQuadLine;
        }
      }
      // ## Private methods
      // ### Whether the current graph is the default graph
      get _inDefaultGraph() {
        return DEFAULTGRAPH2.equals(this._graph);
      }
      // ### `_write` writes the argument to the output stream
      _write(string, callback) {
        this._outputStream.write(string, "utf8", callback);
      }
      // ### `_writeQuad` writes the quad to the output stream
      _writeQuad(subject, predicate, object, graph, done) {
        try {
          if (!graph.equals(this._graph)) {
            this._write((this._subject === null ? "" : this._inDefaultGraph ? ".\n" : "\n}\n") + (DEFAULTGRAPH2.equals(graph) ? "" : `${this._encodeIriOrBlank(graph)} {
`));
            this._graph = graph;
            this._subject = null;
          }
          if (subject.equals(this._subject)) {
            if (predicate.equals(this._predicate))
              this._write(`, ${this._encodeObject(object)}`, done);
            else
              this._write(`;
    ${this._encodePredicate(this._predicate = predicate)} ${this._encodeObject(object)}`, done);
          } else
            this._write(`${(this._subject === null ? "" : ".\n") + this._encodeSubject(this._subject = subject)} ${this._encodePredicate(this._predicate = predicate)} ${this._encodeObject(object)}`, done);
        } catch (error) {
          done && done(error);
        }
      }
      // ### `_writeQuadLine` writes the quad to the output stream as a single line
      _writeQuadLine(subject, predicate, object, graph, done) {
        delete this._prefixMatch;
        this._write(this.quadToString(subject, predicate, object, graph), done);
      }
      // ### `quadToString` serializes a quad as a string
      quadToString(subject, predicate, object, graph) {
        return `${this._encodeSubject(subject)} ${this._encodeIriOrBlank(predicate)} ${this._encodeObject(object)}${graph && graph.value ? ` ${this._encodeIriOrBlank(graph)} .
` : " .\n"}`;
      }
      // ### `quadsToString` serializes an array of quads as a string
      quadsToString(quads) {
        return quads.map((t) => {
          return this.quadToString(t.subject, t.predicate, t.object, t.graph);
        }).join("");
      }
      // ### `_encodeSubject` represents a subject
      _encodeSubject(entity) {
        return entity.termType === "Quad" ? this._encodeQuad(entity) : this._encodeIriOrBlank(entity);
      }
      // ### `_encodeIriOrBlank` represents an IRI or blank node
      _encodeIriOrBlank(entity) {
        if (entity.termType !== "NamedNode") {
          if (this._lists && entity.value in this._lists)
            entity = this.list(this._lists[entity.value]);
          return "id" in entity ? entity.id : `_:${entity.value}`;
        }
        let iri = entity.value;
        if (this._baseMatcher && this._baseMatcher.test(iri))
          iri = iri.substr(this._baseLength);
        if (escape.test(iri))
          iri = iri.replace(escapeAll, characterReplacer);
        const prefixMatch = this._prefixRegex.exec(iri);
        return !prefixMatch ? `<${iri}>` : !prefixMatch[1] ? iri : this._prefixIRIs[prefixMatch[1]] + prefixMatch[2];
      }
      // ### `_encodeLiteral` represents a literal
      _encodeLiteral(literal2) {
        let value = literal2.value;
        if (escape.test(value))
          value = value.replace(escapeAll, characterReplacer);
        if (literal2.language)
          return `"${value}"@${literal2.language}`;
        if (this._lineMode) {
          if (literal2.datatype.value === xsd3.string)
            return `"${value}"`;
        } else {
          switch (literal2.datatype.value) {
            case xsd3.string:
              return `"${value}"`;
            case xsd3.boolean:
              if (value === "true" || value === "false")
                return value;
              break;
            case xsd3.integer:
              if (/^[+-]?\d+$/.test(value))
                return value;
              break;
            case xsd3.decimal:
              if (/^[+-]?\d*\.\d+$/.test(value))
                return value;
              break;
            case xsd3.double:
              if (/^[+-]?(?:\d+\.\d*|\.?\d+)[eE][+-]?\d+$/.test(value))
                return value;
              break;
          }
        }
        return `"${value}"^^${this._encodeIriOrBlank(literal2.datatype)}`;
      }
      // ### `_encodePredicate` represents a predicate
      _encodePredicate(predicate) {
        return predicate.value === rdf2.type ? "a" : this._encodeIriOrBlank(predicate);
      }
      // ### `_encodeObject` represents an object
      _encodeObject(object) {
        switch (object.termType) {
          case "Quad":
            return this._encodeQuad(object);
          case "Literal":
            return this._encodeLiteral(object);
          default:
            return this._encodeIriOrBlank(object);
        }
      }
      // ### `_encodeQuad` encodes an RDF* quad
      _encodeQuad({ subject, predicate, object, graph }) {
        return `<<${this._encodeSubject(subject)} ${this._encodePredicate(predicate)} ${this._encodeObject(object)}${isDefaultGraph(graph) ? "" : ` ${this._encodeIriOrBlank(graph)}`}>>`;
      }
      // ### `_blockedWrite` replaces `_write` after the writer has been closed
      _blockedWrite() {
        throw new Error("Cannot write because the writer has been closed.");
      }
      // ### `addQuad` adds the quad to the output stream
      addQuad(subject, predicate, object, graph, done) {
        if (object === void 0)
          this._writeQuad(subject.subject, subject.predicate, subject.object, subject.graph, predicate);
        else if (typeof graph === "function")
          this._writeQuad(subject, predicate, object, DEFAULTGRAPH2, graph);
        else
          this._writeQuad(subject, predicate, object, graph || DEFAULTGRAPH2, done);
      }
      // ### `addQuads` adds the quads to the output stream
      addQuads(quads) {
        for (let i = 0; i < quads.length; i++)
          this.addQuad(quads[i]);
      }
      // ### `addPrefix` adds the prefix to the output stream
      addPrefix(prefix2, iri, done) {
        const prefixes2 = {};
        prefixes2[prefix2] = iri;
        this.addPrefixes(prefixes2, done);
      }
      // ### `addPrefixes` adds the prefixes to the output stream
      addPrefixes(prefixes2, done) {
        if (!this._prefixIRIs)
          return done && done();
        let hasPrefixes = false;
        for (let prefix2 in prefixes2) {
          let iri = prefixes2[prefix2];
          if (typeof iri !== "string")
            iri = iri.value;
          hasPrefixes = true;
          if (this._subject !== null) {
            this._write(this._inDefaultGraph ? ".\n" : "\n}\n");
            this._subject = null, this._graph = "";
          }
          this._prefixIRIs[iri] = prefix2 += ":";
          this._write(`@prefix ${prefix2} <${iri}>.
`);
        }
        if (hasPrefixes) {
          let IRIlist = "", prefixList = "";
          for (const prefixIRI in this._prefixIRIs) {
            IRIlist += IRIlist ? `|${prefixIRI}` : prefixIRI;
            prefixList += (prefixList ? "|" : "") + this._prefixIRIs[prefixIRI];
          }
          IRIlist = escapeRegex(IRIlist, /[\]\/\(\)\*\+\?\.\\\$]/g, "\\$&");
          this._prefixRegex = new RegExp(`^(?:${prefixList})[^/]*$|^(${IRIlist})([_a-zA-Z][\\-_a-zA-Z0-9]*)$`);
        }
        this._write(hasPrefixes ? "\n" : "", done);
      }
      // ### `blank` creates a blank node with the given content
      blank(predicate, object) {
        let children = predicate, child, length;
        if (predicate === void 0)
          children = [];
        else if (predicate.termType)
          children = [{ predicate, object }];
        else if (!("length" in predicate))
          children = [predicate];
        switch (length = children.length) {
          case 0:
            return new SerializedTerm("[]");
          case 1:
            child = children[0];
            if (!(child.object instanceof SerializedTerm))
              return new SerializedTerm(`[ ${this._encodePredicate(child.predicate)} ${this._encodeObject(child.object)} ]`);
          default:
            let contents = "[";
            for (let i = 0; i < length; i++) {
              child = children[i];
              if (child.predicate.equals(predicate))
                contents += `, ${this._encodeObject(child.object)}`;
              else {
                contents += `${(i ? ";\n  " : "\n  ") + this._encodePredicate(child.predicate)} ${this._encodeObject(child.object)}`;
                predicate = child.predicate;
              }
            }
            return new SerializedTerm(`${contents}
]`);
        }
      }
      // ### `list` creates a list node with the given content
      list(elements) {
        const length = elements && elements.length || 0, contents = new Array(length);
        for (let i = 0; i < length; i++)
          contents[i] = this._encodeObject(elements[i]);
        return new SerializedTerm(`(${contents.join(" ")})`);
      }
      // ### `end` signals the end of the output stream
      end(done) {
        if (this._subject !== null) {
          this._write(this._inDefaultGraph ? ".\n" : "\n}\n");
          this._subject = null;
        }
        this._write = this._blockedWrite;
        let singleDone = done && ((error, result) => {
          singleDone = null, done(error, result);
        });
        if (this._endStream) {
          try {
            return this._outputStream.end(singleDone);
          } catch (error) {
          }
        }
        singleDone && singleDone();
      }
    };
  }
});

// node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = __commonJS({
  "node_modules/readable-stream/lib/ours/primordials.js"(exports, module2) {
    "use strict";
    module2.exports = {
      ArrayIsArray(self2) {
        return Array.isArray(self2);
      },
      ArrayPrototypeIncludes(self2, el) {
        return self2.includes(el);
      },
      ArrayPrototypeIndexOf(self2, el) {
        return self2.indexOf(el);
      },
      ArrayPrototypeJoin(self2, sep) {
        return self2.join(sep);
      },
      ArrayPrototypeMap(self2, fn) {
        return self2.map(fn);
      },
      ArrayPrototypePop(self2, el) {
        return self2.pop(el);
      },
      ArrayPrototypePush(self2, el) {
        return self2.push(el);
      },
      ArrayPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      Error,
      FunctionPrototypeCall(fn, thisArgs, ...args) {
        return fn.call(thisArgs, ...args);
      },
      FunctionPrototypeSymbolHasInstance(self2, instance) {
        return Function.prototype[Symbol.hasInstance].call(self2, instance);
      },
      MathFloor: Math.floor,
      Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(self2, props) {
        return Object.defineProperties(self2, props);
      },
      ObjectDefineProperty(self2, name, prop) {
        return Object.defineProperty(self2, name, prop);
      },
      ObjectGetOwnPropertyDescriptor(self2, name) {
        return Object.getOwnPropertyDescriptor(self2, name);
      },
      ObjectKeys(obj) {
        return Object.keys(obj);
      },
      ObjectSetPrototypeOf(target, proto) {
        return Object.setPrototypeOf(target, proto);
      },
      Promise,
      PromisePrototypeCatch(self2, fn) {
        return self2.catch(fn);
      },
      PromisePrototypeThen(self2, thenFn, catchFn) {
        return self2.then(thenFn, catchFn);
      },
      PromiseReject(err) {
        return Promise.reject(err);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(self2, value) {
        return self2.test(value);
      },
      SafeSet: Set,
      String,
      StringPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      StringPrototypeToLowerCase(self2) {
        return self2.toLowerCase();
      },
      StringPrototypeToUpperCase(self2) {
        return self2.toUpperCase();
      },
      StringPrototypeTrim(self2) {
        return self2.trim();
      },
      Symbol,
      SymbolFor: Symbol.for,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      TypedArrayPrototypeSet(self2, buf, len) {
        return self2.set(buf, len);
      },
      Uint8Array
    };
  }
});

// node_modules/readable-stream/lib/ours/util.js
var require_util = __commonJS({
  "node_modules/readable-stream/lib/ours/util.js"(exports, module2) {
    "use strict";
    var bufferModule = require("buffer");
    var AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    var Blob = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob;
    } : function isBlob2(b) {
      return false;
    };
    var AggregateError = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        let message = "";
        for (let i = 0; i < errors.length; i++) {
          message += `    ${errors[i].stack}
`;
        }
        super(message);
        this.name = "AggregateError";
        this.errors = errors;
      }
    };
    module2.exports = {
      AggregateError,
      kEmptyObject: Object.freeze({}),
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: function() {
        let resolve;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        return {
          promise,
          resolve,
          reject
        };
      },
      promisify(fn) {
        return new Promise((resolve, reject) => {
          fn((err, ...args) => {
            if (err) {
              return reject(err);
            }
            return resolve(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format(format, ...args) {
        return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
          const replacement = args.shift();
          if (type === "f") {
            return replacement.toFixed(6);
          } else if (type === "j") {
            return JSON.stringify(replacement);
          } else if (type === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      },
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob
    };
    module2.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }
});

// node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS({
  "node_modules/event-target-shim/dist/event-target-shim.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var privateData = /* @__PURE__ */ new WeakMap();
    var wrappers = /* @__PURE__ */ new WeakMap();
    function pd(event) {
      const retv = privateData.get(event);
      console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
      );
      return retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        if (typeof console !== "undefined" && typeof console.error === "function") {
          console.error(
            "Unable to preventDefault inside passive event listener invocation.",
            data.passiveListener
          );
        }
        return;
      }
      if (!data.event.cancelable) {
        return;
      }
      data.canceled = true;
      if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
      }
    }
    function Event(eventTarget, event) {
      privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now()
      });
      Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      const keys = Object.keys(event);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in this)) {
          Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
      }
    }
    Event.prototype = {
      /**
       * The type of this event.
       * @type {string}
       */
      get type() {
        return pd(this).event.type;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get target() {
        return pd(this).eventTarget;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get currentTarget() {
        return pd(this).currentTarget;
      },
      /**
       * @returns {EventTarget[]} The composed path of this event.
       */
      composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
          return [];
        }
        return [currentTarget];
      },
      /**
       * Constant of NONE.
       * @type {number}
       */
      get NONE() {
        return 0;
      },
      /**
       * Constant of CAPTURING_PHASE.
       * @type {number}
       */
      get CAPTURING_PHASE() {
        return 1;
      },
      /**
       * Constant of AT_TARGET.
       * @type {number}
       */
      get AT_TARGET() {
        return 2;
      },
      /**
       * Constant of BUBBLING_PHASE.
       * @type {number}
       */
      get BUBBLING_PHASE() {
        return 3;
      },
      /**
       * The target of this event.
       * @type {number}
       */
      get eventPhase() {
        return pd(this).eventPhase;
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopPropagation() {
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
          data.event.stopPropagation();
        }
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopImmediatePropagation() {
        const data = pd(this);
        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
          data.event.stopImmediatePropagation();
        }
      },
      /**
       * The flag to be bubbling.
       * @type {boolean}
       */
      get bubbles() {
        return Boolean(pd(this).event.bubbles);
      },
      /**
       * The flag to be cancelable.
       * @type {boolean}
       */
      get cancelable() {
        return Boolean(pd(this).event.cancelable);
      },
      /**
       * Cancel this event.
       * @returns {void}
       */
      preventDefault() {
        setCancelFlag(pd(this));
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       */
      get defaultPrevented() {
        return pd(this).canceled;
      },
      /**
       * The flag to be composed.
       * @type {boolean}
       */
      get composed() {
        return Boolean(pd(this).event.composed);
      },
      /**
       * The unix time of this event.
       * @type {number}
       */
      get timeStamp() {
        return pd(this).timeStamp;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       * @deprecated
       */
      get srcElement() {
        return pd(this).eventTarget;
      },
      /**
       * The flag to stop event bubbling.
       * @type {boolean}
       * @deprecated
       */
      get cancelBubble() {
        return pd(this).stopped;
      },
      set cancelBubble(value) {
        if (!value) {
          return;
        }
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
          data.event.cancelBubble = true;
        }
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       * @deprecated
       */
      get returnValue() {
        return !pd(this).canceled;
      },
      set returnValue(value) {
        if (!value) {
          setCancelFlag(pd(this));
        }
      },
      /**
       * Initialize this event object. But do nothing under event dispatching.
       * @param {string} type The event type.
       * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
       * @param {boolean} [cancelable=false] The flag to be possible to cancel.
       * @deprecated
       */
      initEvent() {
      }
    };
    Object.defineProperty(Event.prototype, "constructor", {
      value: Event,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
      Object.setPrototypeOf(Event.prototype, window.Event.prototype);
      wrappers.set(window.Event.prototype, Event);
    }
    function defineRedirectDescriptor(key) {
      return {
        get() {
          return pd(this).event[key];
        },
        set(value) {
          pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineCallDescriptor(key) {
      return {
        value() {
          const event = pd(this).event;
          return event[key].apply(event, arguments);
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineWrapper(BaseEvent, proto) {
      const keys = Object.keys(proto);
      if (keys.length === 0) {
        return BaseEvent;
      }
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true }
      });
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in BaseEvent.prototype)) {
          const descriptor = Object.getOwnPropertyDescriptor(proto, key);
          const isFunc = typeof descriptor.value === "function";
          Object.defineProperty(
            CustomEvent.prototype,
            key,
            isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
          );
        }
      }
      return CustomEvent;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype) {
        return Event;
      }
      let wrapper = wrappers.get(proto);
      if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
      }
      return wrapper;
    }
    function wrapEvent(eventTarget, event) {
      const Wrapper = getWrapper(Object.getPrototypeOf(event));
      return new Wrapper(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap = /* @__PURE__ */ new WeakMap();
    var CAPTURE = 1;
    var BUBBLE = 2;
    var ATTRIBUTE = 3;
    function isObject(x) {
      return x !== null && typeof x === "object";
    }
    function getListeners(eventTarget) {
      const listeners = listenersMap.get(eventTarget);
      if (listeners == null) {
        throw new TypeError(
          "'this' is expected an EventTarget object, but got another value."
        );
      }
      return listeners;
    }
    function defineEventAttributeDescriptor(eventName) {
      return {
        get() {
          const listeners = getListeners(this);
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              return node.listener;
            }
            node = node.next;
          }
          return null;
        },
        set(listener) {
          if (typeof listener !== "function" && !isObject(listener)) {
            listener = null;
          }
          const listeners = getListeners(this);
          let prev = null;
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              if (prev !== null) {
                prev.next = node.next;
              } else if (node.next !== null) {
                listeners.set(eventName, node.next);
              } else {
                listeners.delete(eventName);
              }
            } else {
              prev = node;
            }
            node = node.next;
          }
          if (listener !== null) {
            const newNode = {
              listener,
              listenerType: ATTRIBUTE,
              passive: false,
              once: false,
              next: null
            };
            if (prev === null) {
              listeners.set(eventName, newNode);
            } else {
              prev.next = newNode;
            }
          }
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(
        eventTargetPrototype,
        `on${eventName}`,
        defineEventAttributeDescriptor(eventName)
      );
    }
    function defineCustomEventTarget(eventNames) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
          value: CustomEventTarget,
          configurable: true,
          writable: true
        }
      });
      for (let i = 0; i < eventNames.length; ++i) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
      }
      return CustomEventTarget;
    }
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0]);
      }
      if (arguments.length > 0) {
        const types = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i) {
          types[i] = arguments[i];
        }
        return defineCustomEventTarget(types);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    EventTarget.prototype = {
      /**
       * Add a given listener to this event target.
       * @param {string} eventName The event name to add.
       * @param {Function} listener The listener to add.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      addEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        if (typeof listener !== "function" && !isObject(listener)) {
          throw new TypeError("'listener' should be a function or an object.");
        }
        const listeners = getListeners(this);
        const optionsIsObj = isObject(options);
        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
          listener,
          listenerType,
          passive: optionsIsObj && Boolean(options.passive),
          once: optionsIsObj && Boolean(options.once),
          next: null
        };
        let node = listeners.get(eventName);
        if (node === void 0) {
          listeners.set(eventName, newNode);
          return;
        }
        let prev = null;
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            return;
          }
          prev = node;
          node = node.next;
        }
        prev.next = newNode;
      },
      /**
       * Remove a given listener from this event target.
       * @param {string} eventName The event name to remove.
       * @param {Function} listener The listener to remove.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      removeEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        const listeners = getListeners(this);
        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
            return;
          }
          prev = node;
          node = node.next;
        }
      },
      /**
       * Dispatch a given event.
       * @param {Event|{type:string}} event The event to dispatch.
       * @returns {boolean} `false` if canceled.
       */
      dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
          throw new TypeError('"event.type" should be a string.');
        }
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
          return true;
        }
        const wrappedEvent = wrapEvent(this, event);
        let prev = null;
        while (node != null) {
          if (node.once) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }
          setPassiveListener(
            wrappedEvent,
            node.passive ? node.listener : null
          );
          if (typeof node.listener === "function") {
            try {
              node.listener.call(this, wrappedEvent);
            } catch (err) {
              if (typeof console !== "undefined" && typeof console.error === "function") {
                console.error(err);
              }
            }
          } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
            node.listener.handleEvent(wrappedEvent);
          }
          if (isStopped(wrappedEvent)) {
            break;
          }
          node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);
        return !wrappedEvent.defaultPrevented;
      }
    };
    Object.defineProperty(EventTarget.prototype, "constructor", {
      value: EventTarget,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
      Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    }
    exports.defineEventAttribute = defineEventAttribute;
    exports.EventTarget = EventTarget;
    exports.default = EventTarget;
    module2.exports = EventTarget;
    module2.exports.EventTarget = module2.exports["default"] = EventTarget;
    module2.exports.defineEventAttribute = defineEventAttribute;
  }
});

// node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS({
  "node_modules/abort-controller/dist/abort-controller.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var eventTargetShim = require_event_target_shim();
    var AbortSignal = class extends eventTargetShim.EventTarget {
      /**
       * AbortSignal cannot be constructed directly.
       */
      constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
      }
      /**
       * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
       */
      get aborted() {
        const aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
      }
    };
    eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
    function createAbortSignal() {
      const signal = Object.create(AbortSignal.prototype);
      eventTargetShim.EventTarget.call(signal);
      abortedFlags.set(signal, false);
      return signal;
    }
    function abortSignal(signal) {
      if (abortedFlags.get(signal) !== false) {
        return;
      }
      abortedFlags.set(signal, true);
      signal.dispatchEvent({ type: "abort" });
    }
    var abortedFlags = /* @__PURE__ */ new WeakMap();
    Object.defineProperties(AbortSignal.prototype, {
      aborted: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortSignal"
      });
    }
    var AbortController = class {
      /**
       * Initialize this controller.
       */
      constructor() {
        signals.set(this, createAbortSignal());
      }
      /**
       * Returns the `AbortSignal` object associated with this object.
       */
      get signal() {
        return getSignal(this);
      }
      /**
       * Abort and signal to any observers that the associated activity is to be aborted.
       */
      abort() {
        abortSignal(getSignal(this));
      }
    };
    var signals = /* @__PURE__ */ new WeakMap();
    function getSignal(controller) {
      const signal = signals.get(controller);
      if (signal == null) {
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      }
      return signal;
    }
    Object.defineProperties(AbortController.prototype, {
      signal: { enumerable: true },
      abort: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortController.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortController"
      });
    }
    exports.AbortController = AbortController;
    exports.AbortSignal = AbortSignal;
    exports.default = AbortController;
    module2.exports = AbortController;
    module2.exports.AbortController = module2.exports["default"] = AbortController;
    module2.exports.AbortSignal = AbortSignal;
  }
});

// node_modules/readable-stream/lib/ours/errors.js
var require_errors = __commonJS({
  "node_modules/readable-stream/lib/ours/errors.js"(exports, module2) {
    "use strict";
    var { format, inspect, AggregateError: CustomAggregateError } = require_util();
    var AggregateError = globalThis.AggregateError || CustomAggregateError;
    var kIsNodeError = Symbol("kIsNodeError");
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    var classRegExp = /^([A-Z][a-z0-9]*)+$/;
    var nodeInternalPrefix = "__node_internal_";
    var codes = {};
    function assert(value, message) {
      if (!value) {
        throw new codes.ERR_INTERNAL_ASSERTION(message);
      }
    }
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function") {
        assert(
          msg.length <= args.length,
          // Default options do not count.
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
        );
        return msg(...args);
      }
      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      assert(
        expectedLength === args.length,
        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
      );
      if (args.length === 0) {
        return msg;
      }
      return format(msg, ...args);
    }
    function E(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code, message, args));
        }
        toString() {
          return `${this.name} [${code}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, {
        name: {
          value: Base.name,
          writable: true,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${code}]: ${this.message}`;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      NodeError.prototype.code = code;
      NodeError.prototype[kIsNodeError] = true;
      codes[code] = NodeError;
    }
    function hideStackFrames(fn) {
      const hidden = nodeInternalPrefix + fn.name;
      Object.defineProperty(fn, "name", {
        value: hidden
      });
      return fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err = new AggregateError([outerError, innerError], outerError.message);
        err.code = outerError.code;
        return err;
      }
      return innerError || outerError;
    }
    var AbortError = class extends Error {
      constructor(message = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    E("ERR_ASSERTION", "%s", Error);
    E(
      "ERR_INVALID_ARG_TYPE",
      (name, expected, actual) => {
        assert(typeof name === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let msg = "The ";
        if (name.endsWith(" argument")) {
          msg += `${name} `;
        } else {
          msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
        }
        msg += "must be ";
        const types = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          assert(typeof value === "string", "All expected entries have to be of type string");
          if (kTypes.includes(value)) {
            types.push(value.toLowerCase());
          } else if (classRegExp.test(value)) {
            instances.push(value);
          } else {
            assert(value !== "object", 'The value "object" should be written as "Object"');
            other.push(value);
          }
        }
        if (instances.length > 0) {
          const pos = types.indexOf("object");
          if (pos !== -1) {
            types.splice(types, pos, 1);
            instances.push("Object");
          }
        }
        if (types.length > 0) {
          switch (types.length) {
            case 1:
              msg += `of type ${types[0]}`;
              break;
            case 2:
              msg += `one of type ${types[0]} or ${types[1]}`;
              break;
            default: {
              const last = types.pop();
              msg += `one of type ${types.join(", ")}, or ${last}`;
            }
          }
          if (instances.length > 0 || other.length > 0) {
            msg += " or ";
          }
        }
        if (instances.length > 0) {
          switch (instances.length) {
            case 1:
              msg += `an instance of ${instances[0]}`;
              break;
            case 2:
              msg += `an instance of ${instances[0]} or ${instances[1]}`;
              break;
            default: {
              const last = instances.pop();
              msg += `an instance of ${instances.join(", ")}, or ${last}`;
            }
          }
          if (other.length > 0) {
            msg += " or ";
          }
        }
        switch (other.length) {
          case 0:
            break;
          case 1:
            if (other[0].toLowerCase() !== other[0]) {
              msg += "an ";
            }
            msg += `${other[0]}`;
            break;
          case 2:
            msg += `one of ${other[0]} or ${other[1]}`;
            break;
          default: {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
          }
        }
        if (actual == null) {
          msg += `. Received ${actual}`;
        } else if (typeof actual === "function" && actual.name) {
          msg += `. Received function ${actual.name}`;
        } else if (typeof actual === "object") {
          var _actual$constructor;
          if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
            msg += `. Received an instance of ${actual.constructor.name}`;
          } else {
            const inspected = inspect(actual, {
              depth: -1
            });
            msg += `. Received ${inspected}`;
          }
        } else {
          let inspected = inspect(actual, {
            colors: false
          });
          if (inspected.length > 25) {
            inspected = `${inspected.slice(0, 25)}...`;
          }
          msg += `. Received type ${typeof actual} (${inspected})`;
        }
        return msg;
      },
      TypeError
    );
    E(
      "ERR_INVALID_ARG_VALUE",
      (name, value, reason = "is invalid") => {
        let inspected = inspect(value);
        if (inspected.length > 128) {
          inspected = inspected.slice(0, 128) + "...";
        }
        const type = name.includes(".") ? "property" : "argument";
        return `The ${type} '${name}' ${reason}. Received ${inspected}`;
      },
      TypeError
    );
    E(
      "ERR_INVALID_RETURN_VALUE",
      (input, name, value) => {
        var _value$constructor;
        const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
        return `Expected ${input} to be returned from the "${name}" function but got ${type}.`;
      },
      TypeError
    );
    E(
      "ERR_MISSING_ARGS",
      (...args) => {
        assert(args.length > 0, "At least one arg needs to be specified");
        let msg;
        const len = args.length;
        args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
        switch (len) {
          case 1:
            msg += `The ${args[0]} argument`;
            break;
          case 2:
            msg += `The ${args[0]} and ${args[1]} arguments`;
            break;
          default:
            {
              const last = args.pop();
              msg += `The ${args.join(", ")}, and ${last} arguments`;
            }
            break;
        }
        return `${msg} must be specified`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      (str, range, input) => {
        assert(range, 'Missing "range" argument');
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > 2n ** 32n || input < -(2n ** 32n)) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        } else {
          received = inspect(input);
        }
        return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
      },
      RangeError
    );
    E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module2.exports = {
      AbortError,
      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
      hideStackFrames,
      codes
    };
  }
});

// node_modules/readable-stream/lib/internal/validators.js
var require_validators = __commonJS({
  "node_modules/readable-stream/lib/internal/validators.js"(exports, module2) {
    "use strict";
    var {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypeMap,
      NumberIsInteger,
      NumberIsNaN,
      NumberMAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER,
      NumberParseInt,
      ObjectPrototypeHasOwnProperty,
      RegExpPrototypeExec,
      String: String2,
      StringPrototypeToUpperCase,
      StringPrototypeTrim
    } = require_primordials();
    var {
      hideStackFrames,
      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
    } = require_errors();
    var { normalizeEncoding } = require_util();
    var { isAsyncFunction, isArrayBufferView } = require_util().types;
    var signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/;
    var modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name, def) {
      if (typeof value === "undefined") {
        value = def;
      }
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null) {
          throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
        }
        value = NumberParseInt(value, 8);
      }
      validateUint32(value, name);
      return value;
    }
    var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      if (!NumberIsInteger(value))
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      if (value < min || value > max)
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    });
    var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    var validateUint32 = hideStackFrames((value, name, positive = false) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      const min = positive ? 1 : 0;
      const max = 4294967295;
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    function validateString(value, name) {
      if (typeof value !== "string")
        throw new ERR_INVALID_ARG_TYPE(name, "string", value);
    }
    function validateNumber(value, name, min = void 0, max) {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
        throw new ERR_OUT_OF_RANGE(
          name,
          `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`,
          value
        );
      }
    }
    var validateOneOf = hideStackFrames((value, name, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        const allowed = ArrayPrototypeJoin(
          ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)),
          ", "
        );
        const reason = "must be one of: " + allowed;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateBoolean(value, name) {
      if (typeof value !== "boolean")
        throw new ERR_INVALID_ARG_TYPE(name, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    var validateObject = hideStackFrames((value, name, options = null) => {
      const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
      const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
      if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE(name, "Object", value);
      }
    });
    var validateDictionary = hideStackFrames((value, name) => {
      if (value != null && typeof value !== "object" && typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE(name, "a dictionary", value);
      }
    });
    var validateArray = hideStackFrames((value, name, minLength = 0) => {
      if (!ArrayIsArray(value)) {
        throw new ERR_INVALID_ARG_TYPE(name, "Array", value);
      }
      if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateStringArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateString(value[i], `${name}[${i}]`);
      }
    }
    function validateBooleanArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateBoolean(value[i], `${name}[${i}]`);
      }
    }
    function validateSignalName(signal, name = "signal") {
      validateString(signal, name);
      if (signals[signal] === void 0) {
        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        }
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
      if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE(name, ["Buffer", "TypedArray", "DataView"], buffer);
      }
    });
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding(encoding);
      const length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
      }
    }
    function validatePort(port, name = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
      }
      return port | 0;
    }
    var validateAbortSignal = hideStackFrames((signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    });
    var validateFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validatePlainFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function" || isAsyncFunction(value))
        throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validateUndefined = hideStackFrames((value, name) => {
      if (value !== void 0)
        throw new ERR_INVALID_ARG_TYPE(name, "undefined", value);
    });
    function validateUnion(value, name, union) {
      if (!ArrayPrototypeIncludes(union, value)) {
        throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, "|")}')`, value);
      }
    }
    var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name) {
      if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
        throw new ERR_INVALID_ARG_VALUE(
          name,
          value,
          'must be an array or string of format "</styles.css>; rel=preload; as=style"'
        );
      }
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string") {
        validateLinkHeaderFormat(hints, "hints");
        return hints;
      } else if (ArrayIsArray(hints)) {
        const hintsLength = hints.length;
        let result = "";
        if (hintsLength === 0) {
          return result;
        }
        for (let i = 0; i < hintsLength; i++) {
          const link = hints[i];
          validateLinkHeaderFormat(link, "hints");
          result += link;
          if (i !== hintsLength - 1) {
            result += ", ";
          }
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE(
        "hints",
        hints,
        'must be an array or string of format "</styles.css>; rel=preload; as=style"'
      );
    }
    module2.exports = {
      isInt32,
      isUint32,
      parseFileMode,
      validateArray,
      validateStringArray,
      validateBooleanArray,
      validateBoolean,
      validateBuffer,
      validateDictionary,
      validateEncoding,
      validateFunction,
      validateInt32,
      validateInteger,
      validateNumber,
      validateObject,
      validateOneOf,
      validatePlainFunction,
      validatePort,
      validateSignalName,
      validateString,
      validateUint32,
      validateUndefined,
      validateUnion,
      validateAbortSignal,
      validateLinkHeaderValue
    };
  }
});

// node_modules/process/index.js
var require_process = __commonJS({
  "node_modules/process/index.js"(exports, module2) {
    module2.exports = global.process;
  }
});

// node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/utils.js"(exports, module2) {
    "use strict";
    var { Symbol: Symbol2, SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
    var kDestroyed = Symbol2("kDestroyed");
    var kIsErrored = Symbol2("kIsErrored");
    var kIsReadable = Symbol2("kIsReadable");
    var kIsDisturbed = Symbol2("kIsDisturbed");
    var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
    var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
      (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isReadableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    function isWebStream(obj) {
      return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    function isIterable(obj, isAsync) {
      if (obj == null)
        return false;
      if (isAsync === true)
        return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false)
        return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !!(stream.destroyed || stream[kDestroyed] || state !== null && state !== void 0 && state.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableEnded === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean")
        return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableFinished === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean")
        return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream))
        return null;
      if (stream.readableEnded === true)
        return true;
      const rState = stream._readableState;
      if (!rState || rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean")
        return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream))
        return null;
      const rState = stream._readableState;
      if (rState !== null && rState !== void 0 && rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean")
        return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null)
        return stream[kIsReadable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (isDestroyed(stream)) {
        return true;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
        return false;
      }
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.writableErrored) {
        return stream.writableErrored;
      }
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.readableErrored) {
        return stream.readableErrored;
      }
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (typeof stream.closed === "boolean") {
        return stream.closed;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
        return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
      }
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
        return stream._closed;
      }
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
    }
    module2.exports = {
      kDestroyed,
      isDisturbed,
      kIsDisturbed,
      isErrored,
      kIsErrored,
      isReadable,
      kIsReadable,
      kIsClosedPromise,
      kControllerErrorFunction,
      isClosed,
      isDestroyed,
      isDuplexNodeStream,
      isFinished,
      isIterable,
      isReadableNodeStream,
      isReadableStream,
      isReadableEnded,
      isReadableFinished,
      isReadableErrored,
      isNodeStream,
      isWebStream,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableEnded,
      isWritableFinished,
      isWritableErrored,
      isServerRequest,
      isServerResponse,
      willEmitClose,
      isTransformStream
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module2) {
    var process2 = require_process();
    var { AbortError, codes } = require_errors();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;
    var { kEmptyObject, once } = require_util();
    var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators();
    var { Promise: Promise2, PromisePrototypeThen } = require_primordials();
    var {
      isClosed,
      isReadable,
      isReadableNodeStream,
      isReadableStream,
      isReadableFinished,
      isReadableErrored,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableFinished,
      isWritableErrored,
      isNodeStream,
      willEmitClose: _willEmitClose,
      kIsClosedPromise
    } = require_utils();
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop = () => {
    };
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2) {
        callback = options;
        options = kEmptyObject;
      } else if (options == null) {
        options = kEmptyObject;
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once(callback);
      if (isReadableStream(stream) || isWritableStream(stream)) {
        return eosWeb(stream, options, callback);
      }
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
      const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
      const wState = stream._writableState;
      const rState = stream._readableState;
      const onlegacyfinish = () => {
        if (!stream.writable) {
          onfinish();
        }
      };
      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
      let writableFinished = isWritableFinished(stream, false);
      const onfinish = () => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableFinished) {
          callback.call(stream);
        }
      };
      let readableFinished = isReadableFinished(stream, false);
      const onend = () => {
        readableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      };
      const onerror = (err) => {
        callback.call(stream, err);
      };
      let closed = isClosed(stream);
      const onclose = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        callback.call(stream);
      };
      const onclosed = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        callback.call(stream);
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      if (closed) {
        process2.nextTick(onclose);
      } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
        if (!willEmitClose) {
          process2.nextTick(onclosed);
        }
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
        process2.nextTick(onclosed);
      } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
        process2.nextTick(onclosed);
      } else if (rState && stream.req && stream.aborted) {
        process2.nextTick(onclosed);
      }
      const cleanup = () => {
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        const abort = () => {
          const endCallback = callback;
          cleanup();
          endCallback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process2.nextTick(abort);
        } else {
          const originalCallback = callback;
          callback = once((...args) => {
            options.signal.removeEventListener("abort", abort);
            originalCallback.apply(stream, args);
          });
          options.signal.addEventListener("abort", abort);
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options, callback) {
      let isAborted = false;
      let abort = nop;
      if (options.signal) {
        abort = () => {
          isAborted = true;
          callback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process2.nextTick(abort);
        } else {
          const originalCallback = callback;
          callback = once((...args) => {
            options.signal.removeEventListener("abort", abort);
            originalCallback.apply(stream, args);
          });
          options.signal.addEventListener("abort", abort);
        }
      }
      const resolverFn = (...args) => {
        if (!isAborted) {
          process2.nextTick(() => callback.apply(stream, args));
        }
      };
      PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
      return nop;
    }
    function finished(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null) {
        opts = kEmptyObject;
      }
      if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
        validateBoolean(opts.cleanup, "cleanup");
        autoCleanup = opts.cleanup;
      }
      return new Promise2((resolve, reject) => {
        const cleanup = eos(stream, opts, (err) => {
          if (autoCleanup) {
            cleanup();
          }
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
    module2.exports = eos;
    module2.exports.finished = finished;
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module2) {
    "use strict";
    var process2 = require_process();
    var {
      aggregateTwoErrors,
      codes: { ERR_MULTIPLE_CALLBACK },
      AbortError
    } = require_errors();
    var { Symbol: Symbol2 } = require_primordials();
    var { kDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils();
    var kDestroy = Symbol2("kDestroy");
    var kConstruct = Symbol2("kConstruct");
    function checkError(err, w, r) {
      if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
      }
    }
    function destroy(err, cb) {
      const r = this._readableState;
      const w = this._writableState;
      const s = w || r;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err, w, r);
      if (w) {
        w.destroyed = true;
      }
      if (r) {
        r.destroyed = true;
      }
      if (!s.constructed) {
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      } else {
        _destroy(this, err, cb);
      }
      return this;
    }
    function _destroy(self2, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called) {
          return;
        }
        called = true;
        const r = self2._readableState;
        const w = self2._writableState;
        checkError(err2, w, r);
        if (w) {
          w.closed = true;
        }
        if (r) {
          r.closed = true;
        }
        if (typeof cb === "function") {
          cb(err2);
        }
        if (err2) {
          process2.nextTick(emitErrorCloseNT, self2, err2);
        } else {
          process2.nextTick(emitCloseNT, self2);
        }
      }
      try {
        self2._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w) {
        w.closeEmitted = true;
      }
      if (r) {
        r.closeEmitted = true;
      }
      if (w !== null && w !== void 0 && w.emitClose || r !== null && r !== void 0 && r.emitClose) {
        self2.emit("close");
      }
    }
    function emitErrorNT(self2, err) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w !== null && w !== void 0 && w.errorEmitted || r !== null && r !== void 0 && r.errorEmitted) {
        return;
      }
      if (w) {
        w.errorEmitted = true;
      }
      if (r) {
        r.errorEmitted = true;
      }
      self2.emit("error", err);
    }
    function undestroy() {
      const r = this._readableState;
      const w = this._writableState;
      if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = r.readable === false;
        r.endEmitted = r.readable === false;
      }
      if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.ended = w.writable === false;
        w.ending = w.writable === false;
        w.finished = w.writable === false;
      }
    }
    function errorOrDestroy(stream, err, sync) {
      const r = stream._readableState;
      const w = stream._writableState;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        return this;
      }
      if (r !== null && r !== void 0 && r.autoDestroy || w !== null && w !== void 0 && w.autoDestroy)
        stream.destroy(err);
      else if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
        if (sync) {
          process2.nextTick(emitErrorNT, stream, err);
        } else {
          emitErrorNT(stream, err);
        }
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function") {
        return;
      }
      const r = stream._readableState;
      const w = stream._writableState;
      if (r) {
        r.constructed = false;
      }
      if (w) {
        w.constructed = false;
      }
      stream.once(kConstruct, cb);
      if (stream.listenerCount(kConstruct) > 1) {
        return;
      }
      process2.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
          r.constructed = true;
        }
        if (w) {
          w.constructed = true;
        }
        if (s.destroyed) {
          stream.emit(kDestroy, err);
        } else if (err) {
          errorOrDestroy(stream, err, true);
        } else {
          process2.nextTick(emitConstructNT, stream);
        }
      }
      try {
        stream._construct((err) => {
          process2.nextTick(onConstruct, err);
        });
      } catch (err) {
        process2.nextTick(onConstruct, err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err);
      process2.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream)) {
        return;
      }
      if (!err && !isFinished(stream)) {
        err = new AbortError();
      }
      if (isServerRequest(stream)) {
        stream.socket = null;
        stream.destroy(err);
      } else if (isRequest(stream)) {
        stream.abort();
      } else if (isRequest(stream.req)) {
        stream.req.abort();
      } else if (typeof stream.destroy === "function") {
        stream.destroy(err);
      } else if (typeof stream.close === "function") {
        stream.close();
      } else if (err) {
        process2.nextTick(emitErrorCloseLegacy, stream, err);
      } else {
        process2.nextTick(emitCloseLegacy, stream);
      }
      if (!stream.destroyed) {
        stream[kDestroyed] = true;
      }
    }
    module2.exports = {
      construct,
      destroyer,
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/legacy.js"(exports, module2) {
    "use strict";
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
    var { EventEmitter: EE } = require("events");
    function Stream(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream, EE);
    Stream.prototype.pipe = function(dest, options) {
      const source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      let didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          this.emit("error", er);
        }
      }
      prependListener(source, "error", onerror);
      prependListener(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    module2.exports = {
      Stream,
      prependListener
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/add-abort-signal.js"(exports, module2) {
    "use strict";
    var { AbortError, codes } = require_errors();
    var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils();
    var eos = require_end_of_stream();
    var { ERR_INVALID_ARG_TYPE } = codes;
    var validateAbortSignal = (signal, name) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    };
    module2.exports.addAbortSignal = function addAbortSignal(signal, stream) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream) && !isWebStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      return module2.exports.addAbortSignalNoValidate(signal, stream);
    };
    module2.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = isNodeStream(stream) ? () => {
        stream.destroy(
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      } : () => {
        stream[kControllerErrorFunction](
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      };
      if (signal.aborted) {
        onAbort();
      } else {
        signal.addEventListener("abort", onAbort);
        eos(stream, () => signal.removeEventListener("abort", onAbort));
      }
      return stream;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module2) {
    "use strict";
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
    var { Buffer: Buffer2 } = require("buffer");
    var { inspect } = require_util();
    module2.exports = class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v) {
        const entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v) {
        const entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        const ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s) {
        if (this.length === 0)
          return "";
        let p = this.head;
        let ret = "" + p.data;
        while ((p = p.next) !== null)
          ret += s + p.data;
        return ret;
      }
      concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        const ret = Buffer2.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while (p) {
          TypedArrayPrototypeSet(ret, p.data, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
      consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
          const slice = data.slice(0, n);
          this.head.data = data.slice(n);
          return slice;
        }
        if (n === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p = this.head; p; p = p.next) {
          yield p.data;
        }
      }
      // Consumes a specified amount of characters from the buffered data.
      _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
          const str = p.data;
          if (n > str.length) {
            ret += str;
            n -= str.length;
          } else {
            if (n === str.length) {
              ret += str;
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              ret += StringPrototypeSlice(str, 0, n);
              this.head = p;
              p.data = StringPrototypeSlice(str, n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
      _getBuffer(n) {
        const ret = Buffer2.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
          const buf = p.data;
          if (n > buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            n -= buf.length;
          } else {
            if (n === buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n);
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
              this.head = p;
              p.data = buf.slice(n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
      [Symbol.for("nodejs.util.inspect.custom")](_, options) {
        return inspect(this, {
          ...options,
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        });
      }
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports, module2) {
    "use strict";
    var { MathFloor, NumberIsInteger } = require_primordials();
    var { ERR_INVALID_ARG_VALUE } = require_errors().codes;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? 16 : 16 * 1024;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    module2.exports = {
      getHighWaterMark,
      getDefaultHighWaterMark
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from.js"(exports, module2) {
    "use strict";
    var process2 = require_process();
    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
    var { Buffer: Buffer2 } = require("buffer");
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors().codes;
    function from(Readable2, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer2) {
        return new Readable2({
          objectMode: true,
          ...opts,
          read() {
            this.push(iterable);
            this.push(null);
          }
        });
      }
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator]) {
        isAsync = true;
        iterator = iterable[SymbolAsyncIterator]();
      } else if (iterable && iterable[SymbolIterator]) {
        isAsync = false;
        iterator = iterable[SymbolIterator]();
      } else {
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      }
      const readable = new Readable2({
        objectMode: true,
        highWaterMark: 1,
        // TODO(ronag): What options should be allowed?
        ...opts
      });
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      readable._destroy = function(error, cb) {
        PromisePrototypeThen(
          close(error),
          () => process2.nextTick(cb, error),
          // nextTick is here in case cb throws
          (e) => process2.nextTick(cb, e || error)
        );
      };
      async function close(error) {
        const hadError = error !== void 0 && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          const { value, done } = await iterator.throw(error);
          await value;
          if (done) {
            return;
          }
        }
        if (typeof iterator.return === "function") {
          const { value } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (; ; ) {
          try {
            const { value, done } = isAsync ? await iterator.next() : iterator.next();
            if (done) {
              readable.push(null);
            } else {
              const res = value && typeof value.then === "function" ? await value : value;
              if (res === null) {
                reading = false;
                throw new ERR_STREAM_NULL_VALUES();
              } else if (readable.push(res)) {
                continue;
              } else {
                reading = false;
              }
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    module2.exports = from;
  }
});

// node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/readable.js"(exports, module2) {
    var process2 = require_process();
    var {
      ArrayPrototypeIndexOf,
      NumberIsInteger,
      NumberIsNaN,
      NumberParseInt,
      ObjectDefineProperties,
      ObjectKeys,
      ObjectSetPrototypeOf,
      Promise: Promise2,
      SafeSet,
      SymbolAsyncIterator,
      Symbol: Symbol2
    } = require_primordials();
    module2.exports = Readable2;
    Readable2.ReadableState = ReadableState;
    var { EventEmitter: EE } = require("events");
    var { Stream, prependListener } = require_legacy();
    var { Buffer: Buffer2 } = require("buffer");
    var { addAbortSignal } = require_add_abort_signal();
    var eos = require_end_of_stream();
    var debug = require_util().debuglog("stream", (fn) => {
      debug = fn;
    });
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_OUT_OF_RANGE,
        ERR_STREAM_PUSH_AFTER_EOF,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT
      }
    } = require_errors();
    var { validateObject } = require_validators();
    var kPaused = Symbol2("kPaused");
    var { StringDecoder } = require("string_decoder");
    var from = require_from();
    ObjectSetPrototypeOf(Readable2.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Readable2, Stream);
    var nop = () => {
    };
    var { errorOrDestroy } = destroyImpl;
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex)
        this.objectMode = this.objectMode || !!(options && options.readableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = [];
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.constructed = true;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this[kPaused] = null;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.destroyed = false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.awaitDrainWriters = null;
      this.multiAwaitDrain = false;
      this.readingMore = false;
      this.dataEmitted = false;
      this.decoder = null;
      this.encoding = null;
      if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      if (!(this instanceof Readable2))
        return new Readable2(options);
      const isDuplex = this instanceof require_duplex();
      this._readableState = new ReadableState(options, this, isDuplex);
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal && !isDuplex)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        if (this._readableState.needReadable) {
          maybeReadMore(this, this._readableState);
        }
      });
    }
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable2.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      const state = stream._readableState;
      let err;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (state.encoding !== encoding) {
            if (addToFront && state.encoding) {
              chunk = Buffer2.from(chunk, encoding).toString(state.encoding);
            } else {
              chunk = Buffer2.from(chunk, encoding);
              encoding = "";
            }
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "";
        } else if (chunk != null) {
          err = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      if (err) {
        errorOrDestroy(stream, err);
      } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else if (state.destroyed || state.errored)
            return false;
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    Readable2.prototype.isPaused = function() {
      const state = this._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      const decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      const buffer = this._readableState.buffer;
      let content = "";
      for (const data of buffer) {
        content += decoder.write(data);
      }
      buffer.clear();
      if (content !== "")
        buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n > MAX_HWM) {
        throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (NumberIsNaN(n)) {
        if (state.flowing && state.length)
          return state.buffer.first().length;
        return state.length;
      }
      if (n <= state.length)
        return n;
      return state.ended ? state.length : 0;
    }
    Readable2.prototype.read = function(n) {
      debug("read", n);
      if (n === void 0) {
        n = NaN;
      } else if (!NumberIsInteger(n)) {
        n = NumberParseInt(n, 10);
      }
      const state = this._readableState;
      const nOrig = n;
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      let doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        try {
          this._read(state.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
        state.dataEmitted = true;
        this.emit("data", ret);
      }
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
    function emitReadable(stream) {
      const state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process2.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      const state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        process2.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      const src = this;
      const state = this._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
          state.multiAwaitDrain = true;
          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
        }
      }
      state.pipes.push(dest);
      debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr;
      const endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process2.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      let ondrain;
      let cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
          dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest) {
            debug("false write response, pause", 0);
            state.awaitDrainWriters = dest;
            state.multiAwaitDrain = false;
          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
            debug("false write response, pause", state.awaitDrainWriters.size);
            state.awaitDrainWriters.add(dest);
          }
          src.pause();
        }
        if (!ondrain) {
          ondrain = pipeOnDrain(src, dest);
          dest.on("drain", ondrain);
        }
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (dest.listenerCount("error") === 0) {
          const s = dest._writableState || dest._readableState;
          if (s && !s.errorEmitted) {
            errorOrDestroy(dest, er);
          } else {
            dest.emit("error", er);
          }
        }
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (dest.writableNeedDrain === true) {
        if (state.flowing) {
          pause();
        }
      } else if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        const state = src._readableState;
        if (state.awaitDrainWriters === dest) {
          debug("pipeOnDrain", 1);
          state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
          debug("pipeOnDrain", state.awaitDrainWriters.size);
          state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
          src.resume();
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      const state = this._readableState;
      const unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipes.length === 0)
        return this;
      if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for (let i = 0; i < dests.length; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      const index = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      if (state.pipes.length === 0)
        this.pause();
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      const res = Stream.prototype.on.call(this, ev, fn);
      const state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process2.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      const res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.off = Readable2.prototype.removeListener;
    Readable2.prototype.removeAllListeners = function(ev) {
      const res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      const state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && state[kPaused] === false) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      } else if (!state.readableListening) {
        state.flowing = null;
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      const state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state[kPaused] = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process2.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState[kPaused] = true;
      return this;
    };
    function flow(stream) {
      const state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable2.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
          paused = true;
          stream.pause();
        }
      });
      stream.on("end", () => {
        this.push(null);
      });
      stream.on("error", (err) => {
        errorOrDestroy(this, err);
      });
      stream.on("close", () => {
        this.destroy();
      });
      stream.on("destroy", () => {
        this.destroy();
      });
      this._read = () => {
        if (paused && stream.resume) {
          paused = false;
          stream.resume();
        }
      };
      const streamKeys = ObjectKeys(stream);
      for (let j = 1; j < streamKeys.length; j++) {
        const i = streamKeys[j];
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = stream[i].bind(stream);
        }
      }
      return this;
    };
    Readable2.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable2.prototype.iterator = function(options) {
      if (options !== void 0) {
        validateObject(options, "options");
      }
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function") {
        stream = Readable2.wrap(stream, {
          objectMode: true
        });
      }
      const iter = createAsyncIterator(stream, options);
      iter.stream = stream;
      return iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve) {
        if (this === stream) {
          callback();
          callback = nop;
        } else {
          callback = resolve;
        }
      }
      stream.on("readable", next);
      let error;
      const cleanup = eos(
        stream,
        {
          writable: false
        },
        (err) => {
          error = err ? aggregateTwoErrors(error, err) : null;
          callback();
          callback = nop;
        }
      );
      try {
        while (true) {
          const chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null) {
            yield chunk;
          } else if (error) {
            throw error;
          } else if (error === null) {
            return;
          } else {
            await new Promise2(next);
          }
        }
      } catch (err) {
        error = aggregateTwoErrors(error, err);
        throw error;
      } finally {
        if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream._readableState.autoDestroy)) {
          destroyImpl.destroyer(stream, null);
        } else {
          stream.off("readable", next);
          cleanup();
        }
      }
    }
    ObjectDefineProperties(Readable2.prototype, {
      readable: {
        __proto__: null,
        get() {
          const r = this._readableState;
          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set(val) {
          if (this._readableState) {
            this._readableState.readable = !!val;
          }
        }
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.dataEmitted;
        }
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
        }
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.highWaterMark;
        }
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState && this._readableState.buffer;
        }
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.flowing;
        },
        set: function(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.length;
        }
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.objectMode : false;
        }
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.encoding : null;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.errored : null;
        }
      },
      closed: {
        __proto__: null,
        get() {
          return this._readableState ? this._readableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.destroyed : false;
        },
        set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.endEmitted : false;
        }
      }
    });
    ObjectDefineProperties(ReadableState.prototype, {
      // Legacy getter for `pipesCount`.
      pipesCount: {
        __proto__: null,
        get() {
          return this.pipes.length;
        }
      },
      // Legacy property for `paused`.
      paused: {
        __proto__: null,
        get() {
          return this[kPaused] !== false;
        },
        set(value) {
          this[kPaused] = !!value;
        }
      }
    });
    Readable2._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      let ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      const state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process2.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
          process2.nextTick(endWritableNT, stream);
        } else if (state.autoDestroy) {
          const wState = stream._writableState;
          const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
    }
    function endWritableNT(stream) {
      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
      if (writable) {
        stream.end();
      }
    }
    Readable2.from = function(iterable, opts) {
      return from(Readable2, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable2.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable2.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable2.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable2({
        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
        ...options,
        destroy(err, callback) {
          destroyImpl.destroyer(src, err);
          callback(err);
        }
      }).wrap(src);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/writable.js"(exports, module2) {
    var process2 = require_process();
    var {
      ArrayPrototypeSlice,
      Error: Error2,
      FunctionPrototypeSymbolHasInstance,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectSetPrototypeOf,
      StringPrototypeToLowerCase,
      Symbol: Symbol2,
      SymbolHasInstance
    } = require_primordials();
    module2.exports = Writable;
    Writable.WritableState = WritableState;
    var { EventEmitter: EE } = require("events");
    var Stream = require_legacy().Stream;
    var { Buffer: Buffer2 } = require("buffer");
    var destroyImpl = require_destroy();
    var { addAbortSignal } = require_add_abort_signal();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_ALREADY_FINISHED,
      ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING
    } = require_errors().codes;
    var { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Writable, Stream);
    function nop() {
    }
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex)
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      const noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = onwrite.bind(void 0, stream);
      this.writecb = null;
      this.writelen = 0;
      this.afterWriteTickInfo = null;
      resetBuffer(this);
      this.pendingcb = 0;
      this.constructed = true;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this[kOnFinished] = [];
    }
    function resetBuffer(state) {
      state.buffered = [];
      state.bufferedIndex = 0;
      state.allBuffers = true;
      state.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
      __proto__: null,
      get() {
        return this.buffered.length - this.bufferedIndex;
      }
    });
    function Writable(options) {
      const isDuplex = this instanceof require_duplex();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        const state = this._writableState;
        if (!state.writing) {
          clearBuffer(this, state);
        }
        finishMaybe(this, state);
      });
    }
    ObjectDefineProperty(Writable, SymbolHasInstance, {
      __proto__: null,
      value: function(object) {
        if (FunctionPrototypeSymbolHasInstance(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function _write(stream, chunk, encoding, cb) {
      const state = stream._writableState;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
      } else {
        if (!encoding)
          encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer2.isEncoding(encoding))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function")
          cb = nop;
      }
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (!state.objectMode) {
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "buffer";
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "buffer";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "buffer";
        } else {
          throw new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      let err;
      if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
      }
      if (err) {
        process2.nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
      }
      state.pendingcb++;
      return writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      const state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer2.isEncoding(encoding))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      const len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      const ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
          chunk,
          encoding,
          callback
        });
        if (state.allBuffers && encoding !== "buffer") {
          state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop) {
          state.allNoop = false;
        }
      } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      return ret && !state.errored && !state.destroyed;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, er, cb) {
      --state.pendingcb;
      cb(er);
      errorBuffer(state);
      errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      const state = stream._writableState;
      const sync = state.sync;
      const cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
      }
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
      if (er) {
        er.stack;
        if (!state.errored) {
          state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
          stream._readableState.errored = er;
        }
        if (sync) {
          process2.nextTick(onwriteError, stream, state, er, cb);
        } else {
          onwriteError(stream, state, er, cb);
        }
      } else {
        if (state.buffered.length > state.bufferedIndex) {
          clearBuffer(stream, state);
        }
        if (sync) {
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
            state.afterWriteTickInfo.count++;
          } else {
            state.afterWriteTickInfo = {
              count: 1,
              cb,
              stream,
              state
            };
            process2.nextTick(afterWriteTick, state.afterWriteTickInfo);
          }
        } else {
          afterWrite(stream, state, 1, cb);
        }
      }
    }
    function afterWriteTick({ stream, state, count, cb }) {
      state.afterWriteTickInfo = null;
      return afterWrite(stream, state, count, cb);
    }
    function afterWrite(stream, state, count, cb) {
      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
      if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
      while (count-- > 0) {
        state.pendingcb--;
        cb();
      }
      if (state.destroyed) {
        errorBuffer(state);
      }
      finishMaybe(stream, state);
    }
    function errorBuffer(state) {
      if (state.writing) {
        return;
      }
      for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
        var _state$errored;
        const { chunk, callback } = state.buffered[n];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback(
          (_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write")
        );
      }
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        var _state$errored2;
        onfinishCallbacks[i](
          (_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end")
        );
      }
      resetBuffer(state);
    }
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
      }
      const { buffered, bufferedIndex, objectMode } = state;
      const bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength) {
        return;
      }
      let i = bufferedIndex;
      state.bufferProcessing = true;
      if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop : (err) => {
          for (let n = i; n < buffered.length; ++n) {
            buffered[n].callback(err);
          }
        };
        const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
        chunks.allBuffers = state.allBuffers;
        doWrite(stream, state, true, state.length, chunks, "", callback);
        resetBuffer(state);
      } else {
        do {
          const { chunk, encoding, callback } = buffered[i];
          buffered[i++] = null;
          const len = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, callback);
        } while (i < buffered.length && !state.writing);
        if (i === buffered.length) {
          resetBuffer(state);
        } else if (i > 256) {
          buffered.splice(0, i);
          state.bufferedIndex = 0;
        } else {
          state.bufferedIndex = i;
        }
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      if (this._writev) {
        this._writev(
          [
            {
              chunk,
              encoding
            }
          ],
          cb
        );
      } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      }
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      const state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      let err;
      if (chunk !== null && chunk !== void 0) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error2) {
          err = ret;
        }
      }
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (err) {
      } else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe(this, state, true);
        state.ended = true;
      } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
      }
      if (typeof cb === "function") {
        if (err || state.finished) {
          process2.nextTick(cb, err);
        } else {
          state[kOnFinished].push(cb);
        }
      }
      return this;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
          const onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i = 0; i < onfinishCallbacks.length; i++) {
            onfinishCallbacks[i](err);
          }
          errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state)) {
          state.prefinished = true;
          stream.emit("prefinish");
          state.pendingcb++;
          process2.nextTick(finish, stream, state);
        }
      }
      state.sync = true;
      state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state.sync = false;
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.finalCalled = true;
          callFinal(stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          if (sync) {
            state.pendingcb++;
            process2.nextTick(
              (stream2, state2) => {
                if (needFinish(state2)) {
                  finish(stream2, state2);
                } else {
                  state2.pendingcb--;
                }
              },
              stream,
              state
            );
          } else if (needFinish(state)) {
            state.pendingcb++;
            finish(stream, state);
          }
        }
      }
    }
    function finish(stream, state) {
      state.pendingcb--;
      state.finished = true;
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i]();
      }
      stream.emit("finish");
      if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
    ObjectDefineProperties(Writable.prototype, {
      closed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.destroyed : false;
        },
        set(value) {
          if (this._writableState) {
            this._writableState.destroyed = value;
          }
        }
      },
      writable: {
        __proto__: null,
        get() {
          const w = this._writableState;
          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set(val) {
          if (this._writableState) {
            this._writableState.writable = !!val;
          }
        }
      },
      writableFinished: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.finished : false;
        }
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.objectMode : false;
        }
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.getBuffer();
        }
      },
      writableEnded: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.ending : false;
        }
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          const wState = this._writableState;
          if (!wState)
            return false;
          return !wState.destroyed && !wState.ending && wState.needDrain;
        }
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.highWaterMark;
        }
      },
      writableCorked: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.corked : 0;
        }
      },
      writableLength: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.length;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._writableState ? this._writableState.errored : null;
        }
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
        }
      }
    });
    var destroy = destroyImpl.destroy;
    Writable.prototype.destroy = function(err, cb) {
      const state = this._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
        process2.nextTick(errorBuffer, state);
      }
      destroy.call(this, err, cb);
      return this;
    };
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/duplexify.js"(exports, module2) {
    var process2 = require_process();
    var bufferModule = require("buffer");
    var {
      isReadable,
      isWritable,
      isIterable,
      isNodeStream,
      isReadableNodeStream,
      isWritableNodeStream,
      isDuplexNodeStream
    } = require_utils();
    var eos = require_end_of_stream();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
    } = require_errors();
    var { destroyer } = require_destroy();
    var Duplex = require_duplex();
    var Readable2 = require_readable();
    var { createDeferredPromise } = require_util();
    var from = require_from();
    var Blob = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob;
    } : function isBlob2(b) {
      return false;
    };
    var AbortController = globalThis.AbortController || require_abort_controller().AbortController;
    var { FunctionPrototypeCall } = require_primordials();
    var Duplexify = class extends Duplex {
      constructor(options) {
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    };
    module2.exports = function duplexify(body, name) {
      if (isDuplexNodeStream(body)) {
        return body;
      }
      if (isReadableNodeStream(body)) {
        return _duplexify({
          readable: body
        });
      }
      if (isWritableNodeStream(body)) {
        return _duplexify({
          writable: body
        });
      }
      if (isNodeStream(body)) {
        return _duplexify({
          writable: false,
          readable: false
        });
      }
      if (typeof body === "function") {
        const { value, write, final, destroy } = fromAsyncGen(body);
        if (isIterable(value)) {
          return from(Duplexify, value, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            write,
            final,
            destroy
          });
        }
        const then2 = value === null || value === void 0 ? void 0 : value.then;
        if (typeof then2 === "function") {
          let d;
          const promise = FunctionPrototypeCall(
            then2,
            value,
            (val) => {
              if (val != null) {
                throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
              }
            },
            (err) => {
              destroyer(d, err);
            }
          );
          return d = new Duplexify({
            // TODO (ronag): highWaterMark?
            objectMode: true,
            readable: false,
            write,
            final(cb) {
              final(async () => {
                try {
                  await promise;
                  process2.nextTick(cb, null);
                } catch (err) {
                  process2.nextTick(cb, err);
                }
              });
            },
            destroy
          });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
      }
      if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
      }
      if (isIterable(body)) {
        return from(Duplexify, body, {
          // TODO (ronag): highWaterMark?
          objectMode: true,
          writable: false
        });
      }
      if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
        const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
        const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
        return _duplexify({
          readable,
          writable
        });
      }
      const then = body === null || body === void 0 ? void 0 : body.then;
      if (typeof then === "function") {
        let d;
        FunctionPrototypeCall(
          then,
          body,
          (val) => {
            if (val != null) {
              d.push(val);
            }
            d.push(null);
          },
          (err) => {
            destroyer(d, err);
          }
        );
        return d = new Duplexify({
          objectMode: true,
          writable: false,
          read() {
          }
        });
      }
      throw new ERR_INVALID_ARG_TYPE(
        name,
        [
          "Blob",
          "ReadableStream",
          "WritableStream",
          "Stream",
          "Iterable",
          "AsyncIterable",
          "Function",
          "{ readable, writable } pair",
          "Promise"
        ],
        body
      );
    };
    function fromAsyncGen(fn) {
      let { promise, resolve } = createDeferredPromise();
      const ac = new AbortController();
      const signal = ac.signal;
      const value = fn(
        async function* () {
          while (true) {
            const _promise = promise;
            promise = null;
            const { chunk, done, cb } = await _promise;
            process2.nextTick(cb);
            if (done)
              return;
            if (signal.aborted)
              throw new AbortError(void 0, {
                cause: signal.reason
              });
            ({ promise, resolve } = createDeferredPromise());
            yield chunk;
          }
        }(),
        {
          signal
        }
      );
      return {
        value,
        write(chunk, encoding, cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            chunk,
            done: false,
            cb
          });
        },
        final(cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            done: true,
            cb
          });
        },
        destroy(err, cb) {
          ac.abort();
          cb(err);
        }
      };
    }
    function _duplexify(pair) {
      const r = pair.readable && typeof pair.readable.read !== "function" ? Readable2.wrap(pair.readable) : pair.readable;
      const w = pair.writable;
      let readable = !!isReadable(r);
      let writable = !!isWritable(w);
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        }
      }
      d = new Duplexify({
        // TODO (ronag): highWaterMark?
        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
        readable,
        writable
      });
      if (writable) {
        eos(w, (err) => {
          writable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
          if (w.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          w.end();
          onfinish = callback;
        };
        w.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        w.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        eos(r, (err) => {
          readable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        r.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        r.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = r.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(w, err);
          destroyer(r, err);
        }
      };
      return d;
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/duplex.js"(exports, module2) {
    "use strict";
    var {
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectKeys,
      ObjectSetPrototypeOf
    } = require_primordials();
    module2.exports = Duplex;
    var Readable2 = require_readable();
    var Writable = require_writable();
    ObjectSetPrototypeOf(Duplex.prototype, Readable2.prototype);
    ObjectSetPrototypeOf(Duplex, Readable2);
    {
      const keys = ObjectKeys(Writable.prototype);
      for (let i = 0; i < keys.length; i++) {
        const method = keys[i];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable2.call(this, options);
      Writable.call(this, options);
      if (options) {
        this.allowHalfOpen = options.allowHalfOpen !== false;
        if (options.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (options.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    ObjectDefineProperties(Duplex.prototype, {
      writable: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
      },
      writableHighWaterMark: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
      },
      writableObjectMode: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
      },
      writableBuffer: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
      },
      writableLength: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
      },
      writableFinished: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
      },
      writableCorked: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
      },
      writableEnded: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
      },
      writableNeedDrain: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        }
      }
    });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body) {
      if (!duplexify) {
        duplexify = require_duplexify();
      }
      return duplexify(body, "body");
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/transform.js"(exports, module2) {
    "use strict";
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
    module2.exports = Transform3;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes;
    var Duplex = require_duplex();
    var { getHighWaterMark } = require_state();
    ObjectSetPrototypeOf(Transform3.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform3, Duplex);
    var kCallback = Symbol2("kCallback");
    function Transform3(options) {
      if (!(this instanceof Transform3))
        return new Transform3(options);
      const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0) {
        options = {
          ...options,
          highWaterMark: null,
          readableHighWaterMark,
          // TODO (ronag): 0 is not optimal since we have
          // a "bug" where we check needDrain before calling _write and not after.
          // Refs: https://github.com/nodejs/node/pull/32887
          // Refs: https://github.com/nodejs/node/pull/35941
          writableHighWaterMark: options.writableHighWaterMark || 0
        };
      }
      Duplex.call(this, options);
      this._readableState.sync = false;
      this[kCallback] = null;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed) {
        this._flush((er, data) => {
          if (er) {
            if (cb) {
              cb(er);
            } else {
              this.destroy(er);
            }
            return;
          }
          if (data != null) {
            this.push(data);
          }
          this.push(null);
          if (cb) {
            cb();
          }
        });
      } else {
        this.push(null);
        if (cb) {
          cb();
        }
      }
    }
    function prefinish() {
      if (this._final !== final) {
        final.call(this);
      }
    }
    Transform3.prototype._final = final;
    Transform3.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform3.prototype._write = function(chunk, encoding, callback) {
      const rState = this._readableState;
      const wState = this._writableState;
      const length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null) {
          this.push(val);
        }
        if (wState.ended || // Backwards compat.
        length === rState.length || // Backwards compat.
        rState.length < rState.highWaterMark) {
          callback();
        } else {
          this[kCallback] = callback;
        }
      });
    };
    Transform3.prototype._read = function() {
      if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
      }
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/passthrough.js"(exports, module2) {
    "use strict";
    var { ObjectSetPrototypeOf } = require_primordials();
    module2.exports = PassThrough;
    var Transform3 = require_transform();
    ObjectSetPrototypeOf(PassThrough.prototype, Transform3.prototype);
    ObjectSetPrototypeOf(PassThrough, Transform3);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform3.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module2) {
    var process2 = require_process();
    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator } = require_primordials();
    var eos = require_end_of_stream();
    var { once } = require_util();
    var destroyImpl = require_destroy();
    var Duplex = require_duplex();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_INVALID_RETURN_VALUE,
        ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED,
        ERR_STREAM_PREMATURE_CLOSE
      },
      AbortError
    } = require_errors();
    var { validateFunction, validateAbortSignal } = require_validators();
    var {
      isIterable,
      isReadable,
      isReadableNodeStream,
      isNodeStream,
      isTransformStream,
      isWebStream,
      isReadableStream,
      isReadableEnded
    } = require_utils();
    var AbortController = globalThis.AbortController || require_abort_controller().AbortController;
    var PassThrough;
    var Readable2;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      const cleanup = eos(
        stream,
        {
          readable: reading,
          writable: writing
        },
        (err) => {
          finished = !err;
        }
      );
      return {
        destroy: (err) => {
          if (finished)
            return;
          finished = true;
          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
        },
        cleanup
      };
    }
    function popCallback(streams) {
      validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
      return streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable(val)) {
        return val;
      } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
      }
      throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable2) {
        Readable2 = require_readable();
      }
      yield* Readable2.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, { end }) {
      let error;
      let onresolve = null;
      const resume = (err) => {
        if (err) {
          error = err;
        }
        if (onresolve) {
          const callback = onresolve;
          onresolve = null;
          callback();
        }
      };
      const wait = () => new Promise2((resolve, reject) => {
        if (error) {
          reject(error);
        } else {
          onresolve = () => {
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          };
        }
      });
      writable.on("drain", resume);
      const cleanup = eos(
        writable,
        {
          readable: false
        },
        resume
      );
      try {
        if (writable.writableNeedDrain) {
          await wait();
        }
        for await (const chunk of iterable) {
          if (!writable.write(chunk)) {
            await wait();
          }
        }
        if (end) {
          writable.end();
        }
        await wait();
        finish();
      } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
      } finally {
        cleanup();
        writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, { end }) {
      if (isTransformStream(writable)) {
        writable = writable.writable;
      }
      const writer = writable.getWriter();
      try {
        for await (const chunk of readable) {
          await writer.ready;
          writer.write(chunk).catch(() => {
          });
        }
        await writer.ready;
        if (end) {
          await writer.close();
        }
        finish();
      } catch (err) {
        try {
          await writer.abort(err);
          finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    function pipeline(...streams) {
      return pipelineImpl(streams, once(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0])) {
        streams = streams[0];
      }
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      const ac = new AbortController();
      const signal = ac.signal;
      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
      const lastStreamCleanup = [];
      validateAbortSignal(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError());
      }
      outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.addEventListener("abort", abort);
      let error;
      let value;
      const destroys = [];
      let finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
          error = err;
        }
        if (!error && !final) {
          return;
        }
        while (destroys.length) {
          destroys.shift()(error);
        }
        outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.removeEventListener("abort", abort);
        ac.abort();
        if (final) {
          if (!error) {
            lastStreamCleanup.forEach((fn) => fn());
          }
          process2.nextTick(callback, error, value);
        }
      }
      let ret;
      for (let i = 0; i < streams.length; i++) {
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;
        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
        const isLastStream = i === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              finish(err);
            }
          };
          var onError = onError2;
          if (end) {
            const { destroy, cleanup } = destroyer(stream, reading, writing);
            destroys.push(destroy);
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
          stream.on("error", onError2);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
          }
        }
        if (i === 0) {
          if (typeof stream === "function") {
            ret = stream({
              signal
            });
            if (!isIterable(ret)) {
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            }
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
            ret = stream;
          } else {
            ret = Duplex.from(stream);
          }
        } else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
          } else {
            ret = makeAsyncIterable(ret);
          }
          ret = stream(ret, {
            signal
          });
          if (reading) {
            if (!isIterable(ret, true)) {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
            }
          } else {
            var _ret2;
            if (!PassThrough) {
              PassThrough = require_passthrough();
            }
            const pt = new PassThrough({
              objectMode: true
            });
            const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
            if (typeof then === "function") {
              finishCount++;
              then.call(
                ret,
                (val) => {
                  value = val;
                  if (val != null) {
                    pt.write(val);
                  }
                  if (end) {
                    pt.end();
                  }
                  process2.nextTick(finish);
                },
                (err) => {
                  pt.destroy(err);
                  process2.nextTick(finish, err);
                }
              );
            } else if (isIterable(ret, true)) {
              finishCount++;
              pumpToNode(ret, pt, finish, {
                end
              });
            } else if (isReadableStream(ret) || isTransformStream(ret)) {
              const toRead = ret.readable || ret;
              finishCount++;
              pumpToNode(toRead, pt, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            }
            ret = pt;
            const { destroy, cleanup } = destroyer(ret, false, true);
            destroys.push(destroy);
            if (isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            const cleanup = pipe(ret, stream, finish, {
              end
            });
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          } else if (isTransformStream(ret) || isReadableStream(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, stream, finish, {
              end
            });
          } else if (isIterable(ret)) {
            finishCount++;
            pumpToNode(ret, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount++;
            pumpToWeb(makeAsyncIterable(ret), stream, finish, {
              end
            });
          } else if (isReadableStream(ret) || isIterable(ret)) {
            finishCount++;
            pumpToWeb(ret, stream, finish, {
              end
            });
          } else if (isTransformStream(ret)) {
            finishCount++;
            pumpToWeb(ret.readable, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      }
      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
        process2.nextTick(abort);
      }
      return ret;
    }
    function pipe(src, dst, finish, { end }) {
      let ended = false;
      dst.on("close", () => {
        if (!ended) {
          finish(new ERR_STREAM_PREMATURE_CLOSE());
        }
      });
      src.pipe(dst, {
        end: false
      });
      if (end) {
        let endFn2 = function() {
          ended = true;
          dst.end();
        };
        var endFn = endFn2;
        if (isReadableEnded(src)) {
          process2.nextTick(endFn2);
        } else {
          src.once("end", endFn2);
        }
      } else {
        finish();
      }
      eos(
        src,
        {
          readable: true,
          writable: false
        },
        (err) => {
          const rState = src._readableState;
          if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            src.once("end", finish).once("error", finish);
          } else {
            finish(err);
          }
        }
      );
      return eos(
        dst,
        {
          readable: false,
          writable: true
        },
        finish
      );
    }
    module2.exports = {
      pipelineImpl,
      pipeline
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/compose.js"(exports, module2) {
    "use strict";
    var { pipeline } = require_pipeline();
    var Duplex = require_duplex();
    var { destroyer } = require_destroy();
    var {
      isNodeStream,
      isReadable,
      isWritable,
      isWebStream,
      isTransformStream,
      isWritableStream,
      isReadableStream
    } = require_utils();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
    } = require_errors();
    var eos = require_end_of_stream();
    module2.exports = function compose(...streams) {
      if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (streams.length === 1) {
        return Duplex.from(streams[0]);
      }
      const orgStreams = [...streams];
      if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
      }
      if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n = 0; n < streams.length; ++n) {
        if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
          continue;
        }
        if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
      }
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        } else if (!readable && !writable) {
          d.destroy();
        }
      }
      const head = streams[0];
      const tail = pipeline(streams, onfinished);
      const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
      const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
      d = new Duplex({
        // TODO (ronag): highWaterMark?
        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.writableObjectMode),
        writable,
        readable
      });
      if (writable) {
        if (isNodeStream(head)) {
          d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
              callback();
            } else {
              ondrain = callback;
            }
          };
          d._final = function(callback) {
            head.end();
            onfinish = callback;
          };
          head.on("drain", function() {
            if (ondrain) {
              const cb = ondrain;
              ondrain = null;
              cb();
            }
          });
        } else if (isWebStream(head)) {
          const writable2 = isTransformStream(head) ? head.writable : head;
          const writer = writable2.getWriter();
          d._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready;
              writer.write(chunk).catch(() => {
              });
              callback();
            } catch (err) {
              callback(err);
            }
          };
          d._final = async function(callback) {
            try {
              await writer.ready;
              writer.close().catch(() => {
              });
              onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        const toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail)) {
          tail.on("readable", function() {
            if (onreadable) {
              const cb = onreadable;
              onreadable = null;
              cb();
            }
          });
          tail.on("end", function() {
            d.push(null);
          });
          d._read = function() {
            while (true) {
              const buf = tail.read();
              if (buf === null) {
                onreadable = d._read;
                return;
              }
              if (!d.push(buf)) {
                return;
              }
            }
          };
        } else if (isWebStream(tail)) {
          const readable2 = isTransformStream(tail) ? tail.readable : tail;
          const reader = readable2.getReader();
          d._read = async function() {
            while (true) {
              try {
                const { value, done } = await reader.read();
                if (!d.push(value)) {
                  return;
                }
                if (done) {
                  d.push(null);
                  return;
                }
              } catch {
                return;
              }
            }
          };
        }
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          if (isNodeStream(tail)) {
            destroyer(tail, err);
          }
        }
      };
      return d;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/operators.js"(exports, module2) {
    "use strict";
    var AbortController = globalThis.AbortController || require_abort_controller().AbortController;
    var {
      codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
      AbortError
    } = require_errors();
    var { validateAbortSignal, validateInteger, validateObject } = require_validators();
    var kWeakHandler = require_primordials().Symbol("kWeak");
    var { finished } = require_end_of_stream();
    var staticCompose = require_compose();
    var { addAbortSignalNoValidate } = require_add_abort_signal();
    var { isWritable, isNodeStream } = require_utils();
    var {
      ArrayPrototypePush,
      MathFloor,
      Number: Number2,
      NumberIsNaN,
      Promise: Promise2,
      PromiseReject,
      PromisePrototypeThen,
      Symbol: Symbol2
    } = require_primordials();
    var kEmpty = Symbol2("kEmpty");
    var kEof = Symbol2("kEof");
    function compose(stream, options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      if (isNodeStream(stream) && !isWritable(stream)) {
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      }
      const composedStream = staticCompose(this, stream);
      if (options !== null && options !== void 0 && options.signal) {
        addAbortSignalNoValidate(options.signal, composedStream);
      }
      return composedStream;
    }
    function map(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let concurrency = 1;
      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
        concurrency = MathFloor(options.concurrency);
      }
      validateInteger(concurrency, "concurrency", 1);
      return async function* map2() {
        var _options$signal, _options$signal2;
        const ac = new AbortController();
        const stream = this;
        const queue = [];
        const signal = ac.signal;
        const signalOpt = {
          signal
        };
        const abort = () => ac.abort();
        if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
          abort();
        }
        options === null || options === void 0 ? void 0 : (_options$signal2 = options.signal) === null || _options$signal2 === void 0 ? void 0 : _options$signal2.addEventListener("abort", abort);
        let next;
        let resume;
        let done = false;
        function onDone() {
          done = true;
        }
        async function pump() {
          try {
            for await (let val of stream) {
              var _val;
              if (done) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              try {
                val = fn(val, signalOpt);
              } catch (err) {
                val = PromiseReject(err);
              }
              if (val === kEmpty) {
                continue;
              }
              if (typeof ((_val = val) === null || _val === void 0 ? void 0 : _val.catch) === "function") {
                val.catch(onDone);
              }
              queue.push(val);
              if (next) {
                next();
                next = null;
              }
              if (!done && queue.length && queue.length >= concurrency) {
                await new Promise2((resolve) => {
                  resume = resolve;
                });
              }
            }
            queue.push(kEof);
          } catch (err) {
            const val = PromiseReject(err);
            PromisePrototypeThen(val, void 0, onDone);
            queue.push(val);
          } finally {
            var _options$signal3;
            done = true;
            if (next) {
              next();
              next = null;
            }
            options === null || options === void 0 ? void 0 : (_options$signal3 = options.signal) === null || _options$signal3 === void 0 ? void 0 : _options$signal3.removeEventListener("abort", abort);
          }
        }
        pump();
        try {
          while (true) {
            while (queue.length > 0) {
              const val = await queue[0];
              if (val === kEof) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              if (val !== kEmpty) {
                yield val;
              }
              queue.shift();
              if (resume) {
                resume();
                resume = null;
              }
            }
            await new Promise2((resolve) => {
              next = resolve;
            });
          }
        } finally {
          ac.abort();
          done = true;
          if (resume) {
            resume();
            resume = null;
          }
        }
      }.call(this);
    }
    function asIndexedPairs(options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return async function* asIndexedPairs2() {
        let index = 0;
        for await (const val of this) {
          var _options$signal4;
          if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
            throw new AbortError({
              cause: options.signal.reason
            });
          }
          yield [index++, val];
        }
      }.call(this);
    }
    async function some(fn, options = void 0) {
      for await (const unused of filter.call(this, fn, options)) {
        return true;
      }
      return false;
    }
    async function every(fn, options = void 0) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      return !await some.call(
        this,
        async (...args) => {
          return !await fn(...args);
        },
        options
      );
    }
    async function find(fn, options) {
      for await (const result of filter.call(this, fn, options)) {
        return result;
      }
      return void 0;
    }
    async function forEach(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function forEachFn(value, options2) {
        await fn(value, options2);
        return kEmpty;
      }
      for await (const unused of map.call(this, forEachFn, options))
        ;
    }
    function filter(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function filterFn(value, options2) {
        if (await fn(value, options2)) {
          return value;
        }
        return kEmpty;
      }
      return map.call(this, filterFn, options);
    }
    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function reduce(reducer, initialValue, options) {
      var _options$signal5;
      if (typeof reducer !== "function") {
        throw new ERR_INVALID_ARG_TYPE("reducer", ["Function", "AsyncFunction"], reducer);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
        const err = new AbortError(void 0, {
          cause: options.signal.reason
        });
        this.once("error", () => {
        });
        await finished(this.destroy(err));
        throw err;
      }
      const ac = new AbortController();
      const signal = ac.signal;
      if (options !== null && options !== void 0 && options.signal) {
        const opts = {
          once: true,
          [kWeakHandler]: this
        };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (const value of this) {
          var _options$signal6;
          gotAnyItemFromStream = true;
          if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
            throw new AbortError();
          }
          if (!hasInitialValue) {
            initialValue = value;
            hasInitialValue = true;
          } else {
            initialValue = await reducer(initialValue, value, {
              signal
            });
          }
        }
        if (!gotAnyItemFromStream && !hasInitialValue) {
          throw new ReduceAwareErrMissingArgs();
        }
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      const result = [];
      for await (const val of this) {
        var _options$signal7;
        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
          throw new AbortError(void 0, {
            cause: options.signal.reason
          });
        }
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options) {
      const values = map.call(this, fn, options);
      return async function* flatMap2() {
        for await (const val of values) {
          yield* val;
        }
      }.call(this);
    }
    function toIntegerOrInfinity(number) {
      number = Number2(number);
      if (NumberIsNaN(number)) {
        return 0;
      }
      if (number < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
      }
      return number;
    }
    function drop(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return async function* drop2() {
        var _options$signal8;
        if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal9;
          if (options !== null && options !== void 0 && (_options$signal9 = options.signal) !== null && _options$signal9 !== void 0 && _options$signal9.aborted) {
            throw new AbortError();
          }
          if (number-- <= 0) {
            yield val;
          }
        }
      }.call(this);
    }
    function take(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return async function* take2() {
        var _options$signal10;
        if (options !== null && options !== void 0 && (_options$signal10 = options.signal) !== null && _options$signal10 !== void 0 && _options$signal10.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal11;
          if (options !== null && options !== void 0 && (_options$signal11 = options.signal) !== null && _options$signal11 !== void 0 && _options$signal11.aborted) {
            throw new AbortError();
          }
          if (number-- > 0) {
            yield val;
          } else {
            return;
          }
        }
      }.call(this);
    }
    module2.exports.streamReturningOperators = {
      asIndexedPairs,
      drop,
      filter,
      flatMap,
      map,
      take,
      compose
    };
    module2.exports.promiseReturningOperators = {
      every,
      forEach,
      reduce,
      toArray,
      some,
      find
    };
  }
});

// node_modules/readable-stream/lib/stream/promises.js
var require_promises = __commonJS({
  "node_modules/readable-stream/lib/stream/promises.js"(exports, module2) {
    "use strict";
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
    var { isIterable, isNodeStream, isWebStream } = require_utils();
    var { pipelineImpl: pl } = require_pipeline();
    var { finished } = require_end_of_stream();
    require_stream();
    function pipeline(...streams) {
      return new Promise2((resolve, reject) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          const options = ArrayPrototypePop(streams);
          signal = options.signal;
          end = options.end;
        }
        pl(
          streams,
          (err, value) => {
            if (err) {
              reject(err);
            } else {
              resolve(value);
            }
          },
          {
            signal,
            end
          }
        );
      });
    }
    module2.exports = {
      finished,
      pipeline
    };
  }
});

// node_modules/readable-stream/lib/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/stream.js"(exports, module2) {
    var { Buffer: Buffer2 } = require("buffer");
    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
    var {
      promisify: { custom: customPromisify }
    } = require_util();
    var { streamReturningOperators, promiseReturningOperators } = require_operators();
    var {
      codes: { ERR_ILLEGAL_CONSTRUCTOR }
    } = require_errors();
    var compose = require_compose();
    var { pipeline } = require_pipeline();
    var { destroyer } = require_destroy();
    var eos = require_end_of_stream();
    var promises = require_promises();
    var utils = require_utils();
    var Stream = module2.exports = require_legacy().Stream;
    Stream.isDisturbed = utils.isDisturbed;
    Stream.isErrored = utils.isErrored;
    Stream.isReadable = utils.isReadable;
    Stream.Readable = require_readable();
    for (const key of ObjectKeys(streamReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return Stream.Readable.from(ReflectApply(op, this, args));
      };
      fn = fn2;
      const op = streamReturningOperators[key];
      ObjectDefineProperty(fn2, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn2, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn2,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    var fn;
    for (const key of ObjectKeys(promiseReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return ReflectApply(op, this, args);
      };
      fn = fn2;
      const op = promiseReturningOperators[key];
      ObjectDefineProperty(fn2, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn2, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn2,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    var fn;
    Stream.Writable = require_writable();
    Stream.Duplex = require_duplex();
    Stream.Transform = require_transform();
    Stream.PassThrough = require_passthrough();
    Stream.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal();
    Stream.addAbortSignal = addAbortSignal;
    Stream.finished = eos;
    Stream.destroy = destroyer;
    Stream.compose = compose;
    ObjectDefineProperty(Stream, "promises", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    ObjectDefineProperty(pipeline, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.pipeline;
      }
    });
    ObjectDefineProperty(eos, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.finished;
      }
    });
    Stream.Stream = Stream;
    Stream._isUint8Array = function isUint8Array(value) {
      return value instanceof Uint8Array;
    };
    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  }
});

// node_modules/readable-stream/lib/ours/index.js
var require_ours = __commonJS({
  "node_modules/readable-stream/lib/ours/index.js"(exports, module2) {
    "use strict";
    var Stream = require("stream");
    if (Stream && process.env.READABLE_STREAM === "disable") {
      const promises = Stream.promises;
      module2.exports._uint8ArrayToBuffer = Stream._uint8ArrayToBuffer;
      module2.exports._isUint8Array = Stream._isUint8Array;
      module2.exports.isDisturbed = Stream.isDisturbed;
      module2.exports.isErrored = Stream.isErrored;
      module2.exports.isReadable = Stream.isReadable;
      module2.exports.Readable = Stream.Readable;
      module2.exports.Writable = Stream.Writable;
      module2.exports.Duplex = Stream.Duplex;
      module2.exports.Transform = Stream.Transform;
      module2.exports.PassThrough = Stream.PassThrough;
      module2.exports.addAbortSignal = Stream.addAbortSignal;
      module2.exports.finished = Stream.finished;
      module2.exports.destroy = Stream.destroy;
      module2.exports.pipeline = Stream.pipeline;
      module2.exports.compose = Stream.compose;
      Object.defineProperty(Stream, "promises", {
        configurable: true,
        enumerable: true,
        get() {
          return promises;
        }
      });
      module2.exports.Stream = Stream.Stream;
    } else {
      const CustomStream = require_stream();
      const promises = require_promises();
      const originalDestroy = CustomStream.Readable.destroy;
      module2.exports = CustomStream.Readable;
      module2.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
      module2.exports._isUint8Array = CustomStream._isUint8Array;
      module2.exports.isDisturbed = CustomStream.isDisturbed;
      module2.exports.isErrored = CustomStream.isErrored;
      module2.exports.isReadable = CustomStream.isReadable;
      module2.exports.Readable = CustomStream.Readable;
      module2.exports.Writable = CustomStream.Writable;
      module2.exports.Duplex = CustomStream.Duplex;
      module2.exports.Transform = CustomStream.Transform;
      module2.exports.PassThrough = CustomStream.PassThrough;
      module2.exports.addAbortSignal = CustomStream.addAbortSignal;
      module2.exports.finished = CustomStream.finished;
      module2.exports.destroy = CustomStream.destroy;
      module2.exports.destroy = originalDestroy;
      module2.exports.pipeline = CustomStream.pipeline;
      module2.exports.compose = CustomStream.compose;
      Object.defineProperty(CustomStream, "promises", {
        configurable: true,
        enumerable: true,
        get() {
          return promises;
        }
      });
      module2.exports.Stream = CustomStream.Stream;
    }
    module2.exports.default = module2.exports;
  }
});

// node_modules/n3/src/N3Store.js
function isString(s) {
  return typeof s === "string" || s instanceof String;
}
var import_readable_stream, N3Store, DatasetCoreAndReadableStream;
var init_N3Store = __esm({
  "node_modules/n3/src/N3Store.js"() {
    init_N3DataFactory();
    import_readable_stream = __toESM(require_ours());
    init_IRIs();
    init_N3Util();
    N3Store = class {
      constructor(quads, options) {
        this._size = 0;
        this._graphs = /* @__PURE__ */ Object.create(null);
        this._id = 0;
        this._ids = /* @__PURE__ */ Object.create(null);
        this._entities = /* @__PURE__ */ Object.create(null);
        this._blankNodeIndex = 0;
        if (!options && quads && !quads[0])
          options = quads, quads = null;
        options = options || {};
        this._factory = options.factory || N3DataFactory_default;
        if (quads)
          this.addQuads(quads);
      }
      _termFromId(id, factory) {
        if (id[0] === ".") {
          const entities = this._entities;
          const terms = id.split(".");
          const q = this._factory.quad(
            this._termFromId(entities[terms[1]]),
            this._termFromId(entities[terms[2]]),
            this._termFromId(entities[terms[3]]),
            terms[4] && this._termFromId(entities[terms[4]])
          );
          return q;
        }
        return termFromId(id, factory);
      }
      _termToNumericId(term) {
        if (term.termType === "Quad") {
          const s = this._termToNumericId(term.subject), p = this._termToNumericId(term.predicate), o = this._termToNumericId(term.object);
          let g;
          return s && p && o && (isDefaultGraph(term.graph) || (g = this._termToNumericId(term.graph))) && this._ids[g ? `.${s}.${p}.${o}.${g}` : `.${s}.${p}.${o}`];
        }
        return this._ids[termToId(term)];
      }
      _termToNewNumericId(term) {
        const str = term && term.termType === "Quad" ? `.${this._termToNewNumericId(term.subject)}.${this._termToNewNumericId(term.predicate)}.${this._termToNewNumericId(term.object)}${isDefaultGraph(term.graph) ? "" : `.${this._termToNewNumericId(term.graph)}`}` : termToId(term);
        return this._ids[str] || (this._ids[this._entities[++this._id] = str] = this._id);
      }
      // ## Public properties
      // ### `size` returns the number of quads in the store
      get size() {
        let size = this._size;
        if (size !== null)
          return size;
        size = 0;
        const graphs = this._graphs;
        let subjects, subject;
        for (const graphKey in graphs)
          for (const subjectKey in subjects = graphs[graphKey].subjects)
            for (const predicateKey in subject = subjects[subjectKey])
              size += Object.keys(subject[predicateKey]).length;
        return this._size = size;
      }
      // ## Private methods
      // ### `_addToIndex` adds a quad to a three-layered index.
      // Returns if the index has changed, if the entry did not already exist.
      _addToIndex(index0, key0, key1, key2) {
        const index1 = index0[key0] || (index0[key0] = {});
        const index2 = index1[key1] || (index1[key1] = {});
        const existed = key2 in index2;
        if (!existed)
          index2[key2] = null;
        return !existed;
      }
      // ### `_removeFromIndex` removes a quad from a three-layered index
      _removeFromIndex(index0, key0, key1, key2) {
        const index1 = index0[key0], index2 = index1[key1];
        delete index2[key2];
        for (const key in index2)
          return;
        delete index1[key1];
        for (const key in index1)
          return;
        delete index0[key0];
      }
      // ### `_findInIndex` finds a set of quads in a three-layered index.
      // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.
      // Any of these keys can be undefined, which is interpreted as a wildcard.
      // `name0`, `name1`, and `name2` are the names of the keys at each level,
      // used when reconstructing the resulting quad
      // (for instance: _subject_, _predicate_, and _object_).
      // Finally, `graphId` will be the graph of the created quads.
      *_findInIndex(index0, key0, key1, key2, name0, name1, name2, graphId) {
        let tmp, index1, index2;
        const entityKeys = this._entities;
        const graph = this._termFromId(graphId, this._factory);
        const parts = { subject: null, predicate: null, object: null };
        if (key0)
          (tmp = index0, index0 = {})[key0] = tmp[key0];
        for (const value0 in index0) {
          if (index1 = index0[value0]) {
            parts[name0] = this._termFromId(entityKeys[value0], this._factory);
            if (key1)
              (tmp = index1, index1 = {})[key1] = tmp[key1];
            for (const value1 in index1) {
              if (index2 = index1[value1]) {
                parts[name1] = this._termFromId(entityKeys[value1], this._factory);
                const values = key2 ? key2 in index2 ? [key2] : [] : Object.keys(index2);
                for (let l = 0; l < values.length; l++) {
                  parts[name2] = this._termFromId(entityKeys[values[l]], this._factory);
                  yield this._factory.quad(parts.subject, parts.predicate, parts.object, graph);
                }
              }
            }
          }
        }
      }
      // ### `_loop` executes the callback on all keys of index 0
      _loop(index0, callback) {
        for (const key0 in index0)
          callback(key0);
      }
      // ### `_loopByKey0` executes the callback on all keys of a certain entry in index 0
      _loopByKey0(index0, key0, callback) {
        let index1, key1;
        if (index1 = index0[key0]) {
          for (key1 in index1)
            callback(key1);
        }
      }
      // ### `_loopByKey1` executes the callback on given keys of all entries in index 0
      _loopByKey1(index0, key1, callback) {
        let key0, index1;
        for (key0 in index0) {
          index1 = index0[key0];
          if (index1[key1])
            callback(key0);
        }
      }
      // ### `_loopBy2Keys` executes the callback on given keys of certain entries in index 2
      _loopBy2Keys(index0, key0, key1, callback) {
        let index1, index2, key2;
        if ((index1 = index0[key0]) && (index2 = index1[key1])) {
          for (key2 in index2)
            callback(key2);
        }
      }
      // ### `_countInIndex` counts matching quads in a three-layered index.
      // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.
      // Any of these keys can be undefined, which is interpreted as a wildcard.
      _countInIndex(index0, key0, key1, key2) {
        let count = 0, tmp, index1, index2;
        if (key0)
          (tmp = index0, index0 = {})[key0] = tmp[key0];
        for (const value0 in index0) {
          if (index1 = index0[value0]) {
            if (key1)
              (tmp = index1, index1 = {})[key1] = tmp[key1];
            for (const value1 in index1) {
              if (index2 = index1[value1]) {
                if (key2)
                  key2 in index2 && count++;
                else
                  count += Object.keys(index2).length;
              }
            }
          }
        }
        return count;
      }
      // ### `_getGraphs` returns an array with the given graph,
      // or all graphs if the argument is null or undefined.
      _getGraphs(graph) {
        if (!isString(graph))
          return this._graphs;
        const graphs = {};
        graphs[graph] = this._graphs[graph];
        return graphs;
      }
      // ### `_uniqueEntities` returns a function that accepts an entity ID
      // and passes the corresponding entity to callback if it hasn't occurred before.
      _uniqueEntities(callback) {
        const uniqueIds = /* @__PURE__ */ Object.create(null);
        return (id) => {
          if (!(id in uniqueIds)) {
            uniqueIds[id] = true;
            callback(this._termFromId(this._entities[id], this._factory));
          }
        };
      }
      // ## Public methods
      // ### `add` adds the specified quad to the dataset.
      // Returns the dataset instance it was called on.
      // Existing quads, as defined in Quad.equals, will be ignored.
      add(quad2) {
        this.addQuad(quad2);
        return this;
      }
      // ### `addQuad` adds a new quad to the store.
      // Returns if the quad index has changed, if the quad did not already exist.
      addQuad(subject, predicate, object, graph) {
        if (!predicate)
          graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject;
        graph = termToId(graph);
        let graphItem = this._graphs[graph];
        if (!graphItem) {
          graphItem = this._graphs[graph] = { subjects: {}, predicates: {}, objects: {} };
          Object.freeze(graphItem);
        }
        subject = this._termToNewNumericId(subject);
        predicate = this._termToNewNumericId(predicate);
        object = this._termToNewNumericId(object);
        const changed = this._addToIndex(graphItem.subjects, subject, predicate, object);
        this._addToIndex(graphItem.predicates, predicate, object, subject);
        this._addToIndex(graphItem.objects, object, subject, predicate);
        this._size = null;
        return changed;
      }
      // ### `addQuads` adds multiple quads to the store
      addQuads(quads) {
        for (let i = 0; i < quads.length; i++)
          this.addQuad(quads[i]);
      }
      // ### `delete` removes the specified quad from the dataset.
      // Returns the dataset instance it was called on.
      delete(quad2) {
        this.removeQuad(quad2);
        return this;
      }
      // ### `has` determines whether a dataset includes a certain quad or quad pattern.
      has(subjectOrQuad, predicate, object, graph) {
        if (subjectOrQuad && subjectOrQuad.subject)
          ({ subject: subjectOrQuad, predicate, object, graph } = subjectOrQuad);
        return !this.readQuads(subjectOrQuad, predicate, object, graph).next().done;
      }
      // ### `import` adds a stream of quads to the store
      import(stream) {
        stream.on("data", (quad2) => {
          this.addQuad(quad2);
        });
        return stream;
      }
      // ### `removeQuad` removes a quad from the store if it exists
      removeQuad(subject, predicate, object, graph) {
        if (!predicate)
          graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject;
        graph = termToId(graph);
        const graphs = this._graphs;
        let graphItem, subjects, predicates;
        if (!(subject = subject && this._termToNumericId(subject)) || !(predicate = predicate && this._termToNumericId(predicate)) || !(object = object && this._termToNumericId(object)) || !(graphItem = graphs[graph]) || !(subjects = graphItem.subjects[subject]) || !(predicates = subjects[predicate]) || !(object in predicates))
          return false;
        this._removeFromIndex(graphItem.subjects, subject, predicate, object);
        this._removeFromIndex(graphItem.predicates, predicate, object, subject);
        this._removeFromIndex(graphItem.objects, object, subject, predicate);
        if (this._size !== null)
          this._size--;
        for (subject in graphItem.subjects)
          return true;
        delete graphs[graph];
        return true;
      }
      // ### `removeQuads` removes multiple quads from the store
      removeQuads(quads) {
        for (let i = 0; i < quads.length; i++)
          this.removeQuad(quads[i]);
      }
      // ### `remove` removes a stream of quads from the store
      remove(stream) {
        stream.on("data", (quad2) => {
          this.removeQuad(quad2);
        });
        return stream;
      }
      // ### `removeMatches` removes all matching quads from the store
      // Setting any field to `undefined` or `null` indicates a wildcard.
      removeMatches(subject, predicate, object, graph) {
        const stream = new import_readable_stream.Readable({ objectMode: true });
        stream._read = () => {
          for (const quad2 of this.readQuads(subject, predicate, object, graph))
            stream.push(quad2);
          stream.push(null);
        };
        return this.remove(stream);
      }
      // ### `deleteGraph` removes all triples with the given graph from the store
      deleteGraph(graph) {
        return this.removeMatches(null, null, null, graph);
      }
      // ### `getQuads` returns an array of quads matching a pattern.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      getQuads(subject, predicate, object, graph) {
        return [...this.readQuads(subject, predicate, object, graph)];
      }
      // ### `readQuads` returns an generator of quads matching a pattern.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      *readQuads(subject, predicate, object, graph) {
        graph = graph && termToId(graph);
        const graphs = this._getGraphs(graph);
        let content, subjectId, predicateId, objectId;
        if (subject && !(subjectId = this._termToNumericId(subject)) || predicate && !(predicateId = this._termToNumericId(predicate)) || object && !(objectId = this._termToNumericId(object)))
          return;
        for (const graphId in graphs) {
          if (content = graphs[graphId]) {
            if (subjectId) {
              if (objectId)
                yield* this._findInIndex(
                  content.objects,
                  objectId,
                  subjectId,
                  predicateId,
                  "object",
                  "subject",
                  "predicate",
                  graphId
                );
              else
                yield* this._findInIndex(
                  content.subjects,
                  subjectId,
                  predicateId,
                  null,
                  "subject",
                  "predicate",
                  "object",
                  graphId
                );
            } else if (predicateId)
              yield* this._findInIndex(
                content.predicates,
                predicateId,
                objectId,
                null,
                "predicate",
                "object",
                "subject",
                graphId
              );
            else if (objectId)
              yield* this._findInIndex(
                content.objects,
                objectId,
                null,
                null,
                "object",
                "subject",
                "predicate",
                graphId
              );
            else
              yield* this._findInIndex(
                content.subjects,
                null,
                null,
                null,
                "subject",
                "predicate",
                "object",
                graphId
              );
          }
        }
      }
      // ### `match` returns a new dataset that is comprised of all quads in the current instance matching the given arguments.
      // The logic described in Quad Matching is applied for each quad in this dataset to check if it should be included in the output dataset.
      // Note: This method always returns a new DatasetCore, even if that dataset contains no quads.
      // Note: Since a DatasetCore is an unordered set, the order of the quads within the returned sequence is arbitrary.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      // For backwards compatibility, the object return also implements the Readable stream interface.
      match(subject, predicate, object, graph) {
        return new DatasetCoreAndReadableStream(this, subject, predicate, object, graph);
      }
      // ### `countQuads` returns the number of quads matching a pattern.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      countQuads(subject, predicate, object, graph) {
        graph = graph && termToId(graph);
        const graphs = this._getGraphs(graph);
        let count = 0, content, subjectId, predicateId, objectId;
        if (subject && !(subjectId = this._termToNumericId(subject)) || predicate && !(predicateId = this._termToNumericId(predicate)) || object && !(objectId = this._termToNumericId(object)))
          return 0;
        for (const graphId in graphs) {
          if (content = graphs[graphId]) {
            if (subject) {
              if (object)
                count += this._countInIndex(content.objects, objectId, subjectId, predicateId);
              else
                count += this._countInIndex(content.subjects, subjectId, predicateId, objectId);
            } else if (predicate) {
              count += this._countInIndex(content.predicates, predicateId, objectId, subjectId);
            } else {
              count += this._countInIndex(content.objects, objectId, subjectId, predicateId);
            }
          }
        }
        return count;
      }
      // ### `forEach` executes the callback on all quads.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      forEach(callback, subject, predicate, object, graph) {
        this.some((quad2) => {
          callback(quad2);
          return false;
        }, subject, predicate, object, graph);
      }
      // ### `every` executes the callback on all quads,
      // and returns `true` if it returns truthy for all them.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      every(callback, subject, predicate, object, graph) {
        let some = false;
        const every = !this.some((quad2) => {
          some = true;
          return !callback(quad2);
        }, subject, predicate, object, graph);
        return some && every;
      }
      // ### `some` executes the callback on all quads,
      // and returns `true` if it returns truthy for any of them.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      some(callback, subject, predicate, object, graph) {
        for (const quad2 of this.readQuads(subject, predicate, object, graph))
          if (callback(quad2))
            return true;
        return false;
      }
      // ### `getSubjects` returns all subjects that match the pattern.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      getSubjects(predicate, object, graph) {
        const results = [];
        this.forSubjects((s) => {
          results.push(s);
        }, predicate, object, graph);
        return results;
      }
      // ### `forSubjects` executes the callback on all subjects that match the pattern.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      forSubjects(callback, predicate, object, graph) {
        graph = graph && termToId(graph);
        const graphs = this._getGraphs(graph);
        let content, predicateId, objectId;
        callback = this._uniqueEntities(callback);
        if (predicate && !(predicateId = this._termToNumericId(predicate)) || object && !(objectId = this._termToNumericId(object)))
          return;
        for (graph in graphs) {
          if (content = graphs[graph]) {
            if (predicateId) {
              if (objectId)
                this._loopBy2Keys(content.predicates, predicateId, objectId, callback);
              else
                this._loopByKey1(content.subjects, predicateId, callback);
            } else if (objectId)
              this._loopByKey0(content.objects, objectId, callback);
            else
              this._loop(content.subjects, callback);
          }
        }
      }
      // ### `getPredicates` returns all predicates that match the pattern.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      getPredicates(subject, object, graph) {
        const results = [];
        this.forPredicates((p) => {
          results.push(p);
        }, subject, object, graph);
        return results;
      }
      // ### `forPredicates` executes the callback on all predicates that match the pattern.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      forPredicates(callback, subject, object, graph) {
        graph = graph && termToId(graph);
        const graphs = this._getGraphs(graph);
        let content, subjectId, objectId;
        callback = this._uniqueEntities(callback);
        if (subject && !(subjectId = this._termToNumericId(subject)) || object && !(objectId = this._termToNumericId(object)))
          return;
        for (graph in graphs) {
          if (content = graphs[graph]) {
            if (subjectId) {
              if (objectId)
                this._loopBy2Keys(content.objects, objectId, subjectId, callback);
              else
                this._loopByKey0(content.subjects, subjectId, callback);
            } else if (objectId)
              this._loopByKey1(content.predicates, objectId, callback);
            else
              this._loop(content.predicates, callback);
          }
        }
      }
      // ### `getObjects` returns all objects that match the pattern.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      getObjects(subject, predicate, graph) {
        const results = [];
        this.forObjects((o) => {
          results.push(o);
        }, subject, predicate, graph);
        return results;
      }
      // ### `forObjects` executes the callback on all objects that match the pattern.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      forObjects(callback, subject, predicate, graph) {
        graph = graph && termToId(graph);
        const graphs = this._getGraphs(graph);
        let content, subjectId, predicateId;
        callback = this._uniqueEntities(callback);
        if (subject && !(subjectId = this._termToNumericId(subject)) || predicate && !(predicateId = this._termToNumericId(predicate)))
          return;
        for (graph in graphs) {
          if (content = graphs[graph]) {
            if (subjectId) {
              if (predicateId)
                this._loopBy2Keys(content.subjects, subjectId, predicateId, callback);
              else
                this._loopByKey1(content.objects, subjectId, callback);
            } else if (predicateId)
              this._loopByKey0(content.predicates, predicateId, callback);
            else
              this._loop(content.objects, callback);
          }
        }
      }
      // ### `getGraphs` returns all graphs that match the pattern.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      getGraphs(subject, predicate, object) {
        const results = [];
        this.forGraphs((g) => {
          results.push(g);
        }, subject, predicate, object);
        return results;
      }
      // ### `forGraphs` executes the callback on all graphs that match the pattern.
      // Setting any field to `undefined` or `null` indicates a wildcard.
      forGraphs(callback, subject, predicate, object) {
        for (const graph in this._graphs) {
          this.some((quad2) => {
            callback(quad2.graph);
            return true;
          }, subject, predicate, object, graph);
        }
      }
      // ### `createBlankNode` creates a new blank node, returning its name
      createBlankNode(suggestedName) {
        let name, index;
        if (suggestedName) {
          name = suggestedName = `_:${suggestedName}`, index = 1;
          while (this._ids[name])
            name = suggestedName + index++;
        } else {
          do {
            name = `_:b${this._blankNodeIndex++}`;
          } while (this._ids[name]);
        }
        this._ids[name] = ++this._id;
        this._entities[this._id] = name;
        return this._factory.blankNode(name.substr(2));
      }
      // ### `extractLists` finds and removes all list triples
      // and returns the items per list.
      extractLists({ remove = false, ignoreErrors = false } = {}) {
        const lists = {};
        const onError = ignoreErrors ? () => true : (node, message) => {
          throw new Error(`${node.value} ${message}`);
        };
        const tails = this.getQuads(null, IRIs_default.rdf.rest, IRIs_default.rdf.nil, null);
        const toRemove = remove ? [...tails] : [];
        tails.forEach((tailQuad) => {
          const items = [];
          let malformed = false;
          let head;
          let headPos;
          const graph = tailQuad.graph;
          let current = tailQuad.subject;
          while (current && !malformed) {
            const objectQuads = this.getQuads(null, null, current, null);
            const subjectQuads = this.getQuads(current, null, null, null);
            let quad2, first = null, rest = null, parent = null;
            for (let i = 0; i < subjectQuads.length && !malformed; i++) {
              quad2 = subjectQuads[i];
              if (!quad2.graph.equals(graph))
                malformed = onError(current, "not confined to single graph");
              else if (head)
                malformed = onError(current, "has non-list arcs out");
              else if (quad2.predicate.value === IRIs_default.rdf.first) {
                if (first)
                  malformed = onError(current, "has multiple rdf:first arcs");
                else
                  toRemove.push(first = quad2);
              } else if (quad2.predicate.value === IRIs_default.rdf.rest) {
                if (rest)
                  malformed = onError(current, "has multiple rdf:rest arcs");
                else
                  toRemove.push(rest = quad2);
              } else if (objectQuads.length)
                malformed = onError(current, "can't be subject and object");
              else {
                head = quad2;
                headPos = "subject";
              }
            }
            for (let i = 0; i < objectQuads.length && !malformed; ++i) {
              quad2 = objectQuads[i];
              if (head)
                malformed = onError(current, "can't have coreferences");
              else if (quad2.predicate.value === IRIs_default.rdf.rest) {
                if (parent)
                  malformed = onError(current, "has incoming rdf:rest arcs");
                else
                  parent = quad2;
              } else {
                head = quad2;
                headPos = "object";
              }
            }
            if (!first)
              malformed = onError(current, "has no list head");
            else
              items.unshift(first.object);
            current = parent && parent.subject;
          }
          if (malformed)
            remove = false;
          else if (head)
            lists[head[headPos].value] = items;
        });
        if (remove)
          this.removeQuads(toRemove);
        return lists;
      }
      // ### Store is an iterable.
      // Can be used where iterables are expected: for...of loops, array spread operator,
      // `yield*`, and destructuring assignment (order is not guaranteed).
      *[Symbol.iterator]() {
        yield* this.readQuads();
      }
    };
    DatasetCoreAndReadableStream = class extends import_readable_stream.Readable {
      constructor(n3Store, subject, predicate, object, graph) {
        super({ objectMode: true });
        Object.assign(this, { n3Store, subject, predicate, object, graph });
      }
      get filtered() {
        if (!this._filtered) {
          const { n3Store, graph, object, predicate, subject } = this;
          const newStore = this._filtered = new N3Store({ factory: n3Store._factory });
          for (const quad2 of n3Store.readQuads(subject, predicate, object, graph))
            newStore.addQuad(quad2);
        }
        return this._filtered;
      }
      get size() {
        return this.filtered.size;
      }
      _read() {
        for (const quad2 of this)
          this.push(quad2);
        this.push(null);
      }
      add(quad2) {
        return this.filtered.add(quad2);
      }
      delete(quad2) {
        return this.filtered.delete(quad2);
      }
      has(quad2) {
        return this.filtered.has(quad2);
      }
      match(subject, predicate, object, graph) {
        return new DatasetCoreAndReadableStream(this.filtered, subject, predicate, object, graph);
      }
      *[Symbol.iterator]() {
        yield* this._filtered || this.n3Store.readQuads(this.subject, this.predicate, this.object, this.graph);
      }
    };
  }
});

// node_modules/n3/src/N3StreamParser.js
var import_readable_stream2, N3StreamParser;
var init_N3StreamParser = __esm({
  "node_modules/n3/src/N3StreamParser.js"() {
    init_N3Parser();
    import_readable_stream2 = __toESM(require_ours());
    N3StreamParser = class extends import_readable_stream2.Transform {
      constructor(options) {
        super({ decodeStrings: true });
        this._readableState.objectMode = true;
        const parser = new N3Parser(options);
        let onData, onEnd;
        parser.parse(
          {
            on: (event, callback) => {
              switch (event) {
                case "data":
                  onData = callback;
                  break;
                case "end":
                  onEnd = callback;
                  break;
              }
            }
          },
          // Handle quads by pushing them down the pipeline
          (error, quad2) => {
            error && this.emit("error", error) || quad2 && this.push(quad2);
          },
          // Emit prefixes through the `prefix` event
          (prefix2, uri) => {
            this.emit("prefix", prefix2, uri);
          }
        );
        this._transform = (chunk, encoding, done) => {
          onData(chunk);
          done();
        };
        this._flush = (done) => {
          onEnd();
          done();
        };
      }
      // ### Parses a stream of strings
      import(stream) {
        stream.on("data", (chunk) => {
          this.write(chunk);
        });
        stream.on("end", () => {
          this.end();
        });
        stream.on("error", (error) => {
          this.emit("error", error);
        });
        return this;
      }
    };
  }
});

// node_modules/n3/src/N3StreamWriter.js
var import_readable_stream3, N3StreamWriter;
var init_N3StreamWriter = __esm({
  "node_modules/n3/src/N3StreamWriter.js"() {
    import_readable_stream3 = __toESM(require_ours());
    init_N3Writer();
    N3StreamWriter = class extends import_readable_stream3.Transform {
      constructor(options) {
        super({ encoding: "utf8", writableObjectMode: true });
        const writer = this._writer = new N3Writer({
          write: (quad2, encoding, callback) => {
            this.push(quad2);
            callback && callback();
          },
          end: (callback) => {
            this.push(null);
            callback && callback();
          }
        }, options);
        this._transform = (quad2, encoding, done) => {
          writer.addQuad(quad2, done);
        };
        this._flush = (done) => {
          writer.end(done);
        };
      }
      // ### Serializes a stream of quads
      import(stream) {
        stream.on("data", (quad2) => {
          this.write(quad2);
        });
        stream.on("end", () => {
          this.end();
        });
        stream.on("error", (error) => {
          this.emit("error", error);
        });
        stream.on("prefix", (prefix2, iri) => {
          this._writer.addPrefix(prefix2, iri);
        });
        return this;
      }
    };
  }
});

// node_modules/n3/src/index.js
var src_exports = {};
__export(src_exports, {
  BlankNode: () => BlankNode,
  DataFactory: () => N3DataFactory_default,
  DefaultGraph: () => DefaultGraph,
  Lexer: () => N3Lexer,
  Literal: () => Literal,
  NamedNode: () => NamedNode,
  Parser: () => N3Parser,
  Quad: () => Quad,
  Store: () => N3Store,
  StreamParser: () => N3StreamParser,
  StreamWriter: () => N3StreamWriter,
  Term: () => Term,
  Triple: () => Quad,
  Util: () => N3Util_exports,
  Variable: () => Variable,
  Writer: () => N3Writer,
  default: () => src_default,
  termFromId: () => termFromId,
  termToId: () => termToId
});
var src_default;
var init_src = __esm({
  "node_modules/n3/src/index.js"() {
    init_N3Lexer();
    init_N3Parser();
    init_N3Writer();
    init_N3Store();
    init_N3StreamParser();
    init_N3StreamWriter();
    init_N3Util();
    init_N3DataFactory();
    src_default = {
      Lexer: N3Lexer,
      Parser: N3Parser,
      Writer: N3Writer,
      Store: N3Store,
      StreamParser: N3StreamParser,
      StreamWriter: N3StreamWriter,
      Util: N3Util_exports,
      DataFactory: N3DataFactory_default,
      Term,
      NamedNode,
      Literal,
      BlankNode,
      Variable,
      DefaultGraph,
      Quad,
      Triple: Quad,
      termFromId,
      termToId
    };
  }
});

// node_modules/@faubulous/mentor-rdf/dist/ontologies/owl.js
var require_owl = __commonJS({
  "node_modules/@faubulous/mentor-rdf/dist/ontologies/owl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.owl = exports.OWL = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var n3 = tslib_1.__importStar((init_src(), __toCommonJS(src_exports)));
    exports.OWL = {
      /** The class of collections of pairwise different individuals. */
      "AllDifferent": "http://www.w3.org/2002/07/owl#AllDifferent",
      /** The class of collections of pairwise disjoint classes. */
      "AllDisjointClasses": "http://www.w3.org/2002/07/owl#AllDisjointClasses",
      /** The class of collections of pairwise disjoint properties. */
      "AllDisjointProperties": "http://www.w3.org/2002/07/owl#AllDisjointProperties",
      /** The class of annotated annotations for which the RDF serialization consists of an annotated subject, predicate and object. */
      "Annotation": "http://www.w3.org/2002/07/owl#Annotation",
      /** The class of annotation properties. */
      "AnnotationProperty": "http://www.w3.org/2002/07/owl#AnnotationProperty",
      /** The class of asymmetric properties. */
      "AsymmetricProperty": "http://www.w3.org/2002/07/owl#AsymmetricProperty",
      /** The class of annotated axioms for which the RDF serialization consists of an annotated subject, predicate and object. */
      "Axiom": "http://www.w3.org/2002/07/owl#Axiom",
      /** The class of OWL classes. */
      "Class": "http://www.w3.org/2002/07/owl#Class",
      /** The class of OWL data ranges, which are special kinds of datatypes. Note: The use of the IRI owl:DataRange has been deprecated as of OWL 2. The IRI rdfs:Datatype SHOULD be used instead. */
      "DataRange": "http://www.w3.org/2002/07/owl#DataRange",
      /** The class of data properties. */
      "DatatypeProperty": "http://www.w3.org/2002/07/owl#DatatypeProperty",
      /** The class of deprecated classes. */
      "DeprecatedClass": "http://www.w3.org/2002/07/owl#DeprecatedClass",
      /** The class of deprecated properties. */
      "DeprecatedProperty": "http://www.w3.org/2002/07/owl#DeprecatedProperty",
      /** The class of functional properties. */
      "FunctionalProperty": "http://www.w3.org/2002/07/owl#FunctionalProperty",
      /** The class of inverse-functional properties. */
      "InverseFunctionalProperty": "http://www.w3.org/2002/07/owl#InverseFunctionalProperty",
      /** The class of irreflexive properties. */
      "IrreflexiveProperty": "http://www.w3.org/2002/07/owl#IrreflexiveProperty",
      /** The class of named individuals. */
      "NamedIndividual": "http://www.w3.org/2002/07/owl#NamedIndividual",
      /** The class of negative property assertions. */
      "NegativePropertyAssertion": "http://www.w3.org/2002/07/owl#NegativePropertyAssertion",
      /** This is the empty class. */
      "Nothing": "http://www.w3.org/2002/07/owl#Nothing",
      /** The class of object properties. */
      "ObjectProperty": "http://www.w3.org/2002/07/owl#ObjectProperty",
      /** The class of ontologies. */
      "Ontology": "http://www.w3.org/2002/07/owl#Ontology",
      /** The class of ontology properties. */
      "OntologyProperty": "http://www.w3.org/2002/07/owl#OntologyProperty",
      /** The class of reflexive properties. */
      "ReflexiveProperty": "http://www.w3.org/2002/07/owl#ReflexiveProperty",
      /** The class of property restrictions. */
      "Restriction": "http://www.w3.org/2002/07/owl#Restriction",
      /** The class of symmetric properties. */
      "SymmetricProperty": "http://www.w3.org/2002/07/owl#SymmetricProperty",
      /** The class of OWL individuals. */
      "Thing": "http://www.w3.org/2002/07/owl#Thing",
      /** The class of transitive properties. */
      "TransitiveProperty": "http://www.w3.org/2002/07/owl#TransitiveProperty",
      /** The property that determines the class that a universal property restriction refers to. */
      "allValuesFrom": "http://www.w3.org/2002/07/owl#allValuesFrom",
      /** The property that determines the predicate of an annotated axiom or annotated annotation. */
      "annotatedProperty": "http://www.w3.org/2002/07/owl#annotatedProperty",
      /** The property that determines the subject of an annotated axiom or annotated annotation. */
      "annotatedSource": "http://www.w3.org/2002/07/owl#annotatedSource",
      /** The property that determines the object of an annotated axiom or annotated annotation. */
      "annotatedTarget": "http://www.w3.org/2002/07/owl#annotatedTarget",
      /** The property that determines the predicate of a negative property assertion. */
      "assertionProperty": "http://www.w3.org/2002/07/owl#assertionProperty",
      /** The annotation property that indicates that a given ontology is backward compatible with another ontology. */
      "backwardCompatibleWith": "http://www.w3.org/2002/07/owl#backwardCompatibleWith",
      /** The data property that does not relate any individual to any data value. */
      "bottomDataProperty": "http://www.w3.org/2002/07/owl#bottomDataProperty",
      /** The object property that does not relate any two individuals. */
      "bottomObjectProperty": "http://www.w3.org/2002/07/owl#bottomObjectProperty",
      /** The property that determines the cardinality of an exact cardinality restriction. */
      "cardinality": "http://www.w3.org/2002/07/owl#cardinality",
      /** The property that determines that a given class is the complement of another class. */
      "complementOf": "http://www.w3.org/2002/07/owl#complementOf",
      /** The property that determines that a given data range is the complement of another data range with respect to the data domain. */
      "datatypeComplementOf": "http://www.w3.org/2002/07/owl#datatypeComplementOf",
      /** The annotation property that indicates that a given entity has been deprecated. */
      "deprecated": "http://www.w3.org/2002/07/owl#deprecated",
      /** The property that determines that two given individuals are different. */
      "differentFrom": "http://www.w3.org/2002/07/owl#differentFrom",
      /** The property that determines that a given class is equivalent to the disjoint union of a collection of other classes. */
      "disjointUnionOf": "http://www.w3.org/2002/07/owl#disjointUnionOf",
      /** The property that determines that two given classes are disjoint. */
      "disjointWith": "http://www.w3.org/2002/07/owl#disjointWith",
      /** The property that determines the collection of pairwise different individuals in a owl:AllDifferent axiom. */
      "distinctMembers": "http://www.w3.org/2002/07/owl#distinctMembers",
      /** The property that determines that two given classes are equivalent, and that is used to specify datatype definitions. */
      "equivalentClass": "http://www.w3.org/2002/07/owl#equivalentClass",
      /** The property that determines that two given properties are equivalent. */
      "equivalentProperty": "http://www.w3.org/2002/07/owl#equivalentProperty",
      /** The property that determines the collection of properties that jointly build a key. */
      "hasKey": "http://www.w3.org/2002/07/owl#hasKey",
      /** The property that determines the property that a self restriction refers to. */
      "hasSelf": "http://www.w3.org/2002/07/owl#hasSelf",
      /** The property that determines the individual that a has-value restriction refers to. */
      "hasValue": "http://www.w3.org/2002/07/owl#hasValue",
      /** The property that is used for importing other ontologies into a given ontology. */
      "imports": "http://www.w3.org/2002/07/owl#imports",
      /** The annotation property that indicates that a given ontology is incompatible with another ontology. */
      "incompatibleWith": "http://www.w3.org/2002/07/owl#incompatibleWith",
      /** The property that determines the collection of classes or data ranges that build an intersection. */
      "intersectionOf": "http://www.w3.org/2002/07/owl#intersectionOf",
      /** The property that determines that two given properties are inverse. */
      "inverseOf": "http://www.w3.org/2002/07/owl#inverseOf",
      /** The property that determines the cardinality of a maximum cardinality restriction. */
      "maxCardinality": "http://www.w3.org/2002/07/owl#maxCardinality",
      /** The property that determines the cardinality of a maximum qualified cardinality restriction. */
      "maxQualifiedCardinality": "http://www.w3.org/2002/07/owl#maxQualifiedCardinality",
      /** The property that determines the collection of members in either a owl:AllDifferent, owl:AllDisjointClasses or owl:AllDisjointProperties axiom. */
      "members": "http://www.w3.org/2002/07/owl#members",
      /** The property that determines the cardinality of a minimum cardinality restriction. */
      "minCardinality": "http://www.w3.org/2002/07/owl#minCardinality",
      /** The property that determines the cardinality of a minimum qualified cardinality restriction. */
      "minQualifiedCardinality": "http://www.w3.org/2002/07/owl#minQualifiedCardinality",
      /** The property that determines the class that a qualified object cardinality restriction refers to. */
      "onClass": "http://www.w3.org/2002/07/owl#onClass",
      /** The property that determines the data range that a qualified data cardinality restriction refers to. */
      "onDataRange": "http://www.w3.org/2002/07/owl#onDataRange",
      /** The property that determines the datatype that a datatype restriction refers to. */
      "onDatatype": "http://www.w3.org/2002/07/owl#onDatatype",
      /** The property that determines the n-tuple of properties that a property restriction on an n-ary data range refers to. */
      "onProperties": "http://www.w3.org/2002/07/owl#onProperties",
      /** The property that determines the property that a property restriction refers to. */
      "onProperty": "http://www.w3.org/2002/07/owl#onProperty",
      /** The property that determines the collection of individuals or data values that build an enumeration. */
      "oneOf": "http://www.w3.org/2002/07/owl#oneOf",
      /** The annotation property that indicates the predecessor ontology of a given ontology. */
      "priorVersion": "http://www.w3.org/2002/07/owl#priorVersion",
      /** The property that determines the n-tuple of properties that build a sub property chain of a given property. */
      "propertyChainAxiom": "http://www.w3.org/2002/07/owl#propertyChainAxiom",
      /** The property that determines that two given properties are disjoint. */
      "propertyDisjointWith": "http://www.w3.org/2002/07/owl#propertyDisjointWith",
      /** The property that determines the cardinality of an exact qualified cardinality restriction. */
      "qualifiedCardinality": "http://www.w3.org/2002/07/owl#qualifiedCardinality",
      /** The property that determines that two given individuals are equal. */
      "sameAs": "http://www.w3.org/2002/07/owl#sameAs",
      /** The property that determines the class that an existential property restriction refers to. */
      "someValuesFrom": "http://www.w3.org/2002/07/owl#someValuesFrom",
      /** The property that determines the subject of a negative property assertion. */
      "sourceIndividual": "http://www.w3.org/2002/07/owl#sourceIndividual",
      /** The property that determines the object of a negative object property assertion. */
      "targetIndividual": "http://www.w3.org/2002/07/owl#targetIndividual",
      /** The property that determines the value of a negative data property assertion. */
      "targetValue": "http://www.w3.org/2002/07/owl#targetValue",
      /** The data property that relates every individual to every data value. */
      "topDataProperty": "http://www.w3.org/2002/07/owl#topDataProperty",
      /** The object property that relates every two individuals. */
      "topObjectProperty": "http://www.w3.org/2002/07/owl#topObjectProperty",
      /** The property that determines the collection of classes or data ranges that build a union. */
      "unionOf": "http://www.w3.org/2002/07/owl#unionOf",
      /** The property that identifies the version IRI of an ontology. */
      "versionIRI": "http://www.w3.org/2002/07/owl#versionIRI",
      /** The annotation property that provides version information for an ontology or another OWL construct. */
      "versionInfo": "http://www.w3.org/2002/07/owl#versionInfo",
      /** The property that determines the collection of facet-value pairs that define a datatype restriction. */
      "withRestrictions": "http://www.w3.org/2002/07/owl#withRestrictions"
    };
    exports.owl = {
      /** The class of collections of pairwise different individuals. */
      "AllDifferent": new n3.NamedNode("http://www.w3.org/2002/07/owl#AllDifferent"),
      /** The class of collections of pairwise disjoint classes. */
      "AllDisjointClasses": new n3.NamedNode("http://www.w3.org/2002/07/owl#AllDisjointClasses"),
      /** The class of collections of pairwise disjoint properties. */
      "AllDisjointProperties": new n3.NamedNode("http://www.w3.org/2002/07/owl#AllDisjointProperties"),
      /** The class of annotated annotations for which the RDF serialization consists of an annotated subject, predicate and object. */
      "Annotation": new n3.NamedNode("http://www.w3.org/2002/07/owl#Annotation"),
      /** The class of annotation properties. */
      "AnnotationProperty": new n3.NamedNode("http://www.w3.org/2002/07/owl#AnnotationProperty"),
      /** The class of asymmetric properties. */
      "AsymmetricProperty": new n3.NamedNode("http://www.w3.org/2002/07/owl#AsymmetricProperty"),
      /** The class of annotated axioms for which the RDF serialization consists of an annotated subject, predicate and object. */
      "Axiom": new n3.NamedNode("http://www.w3.org/2002/07/owl#Axiom"),
      /** The class of OWL classes. */
      "Class": new n3.NamedNode("http://www.w3.org/2002/07/owl#Class"),
      /** The class of OWL data ranges, which are special kinds of datatypes. Note: The use of the IRI owl:DataRange has been deprecated as of OWL 2. The IRI rdfs:Datatype SHOULD be used instead. */
      "DataRange": new n3.NamedNode("http://www.w3.org/2002/07/owl#DataRange"),
      /** The class of data properties. */
      "DatatypeProperty": new n3.NamedNode("http://www.w3.org/2002/07/owl#DatatypeProperty"),
      /** The class of deprecated classes. */
      "DeprecatedClass": new n3.NamedNode("http://www.w3.org/2002/07/owl#DeprecatedClass"),
      /** The class of deprecated properties. */
      "DeprecatedProperty": new n3.NamedNode("http://www.w3.org/2002/07/owl#DeprecatedProperty"),
      /** The class of functional properties. */
      "FunctionalProperty": new n3.NamedNode("http://www.w3.org/2002/07/owl#FunctionalProperty"),
      /** The class of inverse-functional properties. */
      "InverseFunctionalProperty": new n3.NamedNode("http://www.w3.org/2002/07/owl#InverseFunctionalProperty"),
      /** The class of irreflexive properties. */
      "IrreflexiveProperty": new n3.NamedNode("http://www.w3.org/2002/07/owl#IrreflexiveProperty"),
      /** The class of named individuals. */
      "NamedIndividual": new n3.NamedNode("http://www.w3.org/2002/07/owl#NamedIndividual"),
      /** The class of negative property assertions. */
      "NegativePropertyAssertion": new n3.NamedNode("http://www.w3.org/2002/07/owl#NegativePropertyAssertion"),
      /** This is the empty class. */
      "Nothing": new n3.NamedNode("http://www.w3.org/2002/07/owl#Nothing"),
      /** The class of object properties. */
      "ObjectProperty": new n3.NamedNode("http://www.w3.org/2002/07/owl#ObjectProperty"),
      /** The class of ontologies. */
      "Ontology": new n3.NamedNode("http://www.w3.org/2002/07/owl#Ontology"),
      /** The class of ontology properties. */
      "OntologyProperty": new n3.NamedNode("http://www.w3.org/2002/07/owl#OntologyProperty"),
      /** The class of reflexive properties. */
      "ReflexiveProperty": new n3.NamedNode("http://www.w3.org/2002/07/owl#ReflexiveProperty"),
      /** The class of property restrictions. */
      "Restriction": new n3.NamedNode("http://www.w3.org/2002/07/owl#Restriction"),
      /** The class of symmetric properties. */
      "SymmetricProperty": new n3.NamedNode("http://www.w3.org/2002/07/owl#SymmetricProperty"),
      /** The class of OWL individuals. */
      "Thing": new n3.NamedNode("http://www.w3.org/2002/07/owl#Thing"),
      /** The class of transitive properties. */
      "TransitiveProperty": new n3.NamedNode("http://www.w3.org/2002/07/owl#TransitiveProperty"),
      /** The property that determines the class that a universal property restriction refers to. */
      "allValuesFrom": new n3.NamedNode("http://www.w3.org/2002/07/owl#allValuesFrom"),
      /** The property that determines the predicate of an annotated axiom or annotated annotation. */
      "annotatedProperty": new n3.NamedNode("http://www.w3.org/2002/07/owl#annotatedProperty"),
      /** The property that determines the subject of an annotated axiom or annotated annotation. */
      "annotatedSource": new n3.NamedNode("http://www.w3.org/2002/07/owl#annotatedSource"),
      /** The property that determines the object of an annotated axiom or annotated annotation. */
      "annotatedTarget": new n3.NamedNode("http://www.w3.org/2002/07/owl#annotatedTarget"),
      /** The property that determines the predicate of a negative property assertion. */
      "assertionProperty": new n3.NamedNode("http://www.w3.org/2002/07/owl#assertionProperty"),
      /** The annotation property that indicates that a given ontology is backward compatible with another ontology. */
      "backwardCompatibleWith": new n3.NamedNode("http://www.w3.org/2002/07/owl#backwardCompatibleWith"),
      /** The data property that does not relate any individual to any data value. */
      "bottomDataProperty": new n3.NamedNode("http://www.w3.org/2002/07/owl#bottomDataProperty"),
      /** The object property that does not relate any two individuals. */
      "bottomObjectProperty": new n3.NamedNode("http://www.w3.org/2002/07/owl#bottomObjectProperty"),
      /** The property that determines the cardinality of an exact cardinality restriction. */
      "cardinality": new n3.NamedNode("http://www.w3.org/2002/07/owl#cardinality"),
      /** The property that determines that a given class is the complement of another class. */
      "complementOf": new n3.NamedNode("http://www.w3.org/2002/07/owl#complementOf"),
      /** The property that determines that a given data range is the complement of another data range with respect to the data domain. */
      "datatypeComplementOf": new n3.NamedNode("http://www.w3.org/2002/07/owl#datatypeComplementOf"),
      /** The annotation property that indicates that a given entity has been deprecated. */
      "deprecated": new n3.NamedNode("http://www.w3.org/2002/07/owl#deprecated"),
      /** The property that determines that two given individuals are different. */
      "differentFrom": new n3.NamedNode("http://www.w3.org/2002/07/owl#differentFrom"),
      /** The property that determines that a given class is equivalent to the disjoint union of a collection of other classes. */
      "disjointUnionOf": new n3.NamedNode("http://www.w3.org/2002/07/owl#disjointUnionOf"),
      /** The property that determines that two given classes are disjoint. */
      "disjointWith": new n3.NamedNode("http://www.w3.org/2002/07/owl#disjointWith"),
      /** The property that determines the collection of pairwise different individuals in a owl:AllDifferent axiom. */
      "distinctMembers": new n3.NamedNode("http://www.w3.org/2002/07/owl#distinctMembers"),
      /** The property that determines that two given classes are equivalent, and that is used to specify datatype definitions. */
      "equivalentClass": new n3.NamedNode("http://www.w3.org/2002/07/owl#equivalentClass"),
      /** The property that determines that two given properties are equivalent. */
      "equivalentProperty": new n3.NamedNode("http://www.w3.org/2002/07/owl#equivalentProperty"),
      /** The property that determines the collection of properties that jointly build a key. */
      "hasKey": new n3.NamedNode("http://www.w3.org/2002/07/owl#hasKey"),
      /** The property that determines the property that a self restriction refers to. */
      "hasSelf": new n3.NamedNode("http://www.w3.org/2002/07/owl#hasSelf"),
      /** The property that determines the individual that a has-value restriction refers to. */
      "hasValue": new n3.NamedNode("http://www.w3.org/2002/07/owl#hasValue"),
      /** The property that is used for importing other ontologies into a given ontology. */
      "imports": new n3.NamedNode("http://www.w3.org/2002/07/owl#imports"),
      /** The annotation property that indicates that a given ontology is incompatible with another ontology. */
      "incompatibleWith": new n3.NamedNode("http://www.w3.org/2002/07/owl#incompatibleWith"),
      /** The property that determines the collection of classes or data ranges that build an intersection. */
      "intersectionOf": new n3.NamedNode("http://www.w3.org/2002/07/owl#intersectionOf"),
      /** The property that determines that two given properties are inverse. */
      "inverseOf": new n3.NamedNode("http://www.w3.org/2002/07/owl#inverseOf"),
      /** The property that determines the cardinality of a maximum cardinality restriction. */
      "maxCardinality": new n3.NamedNode("http://www.w3.org/2002/07/owl#maxCardinality"),
      /** The property that determines the cardinality of a maximum qualified cardinality restriction. */
      "maxQualifiedCardinality": new n3.NamedNode("http://www.w3.org/2002/07/owl#maxQualifiedCardinality"),
      /** The property that determines the collection of members in either a owl:AllDifferent, owl:AllDisjointClasses or owl:AllDisjointProperties axiom. */
      "members": new n3.NamedNode("http://www.w3.org/2002/07/owl#members"),
      /** The property that determines the cardinality of a minimum cardinality restriction. */
      "minCardinality": new n3.NamedNode("http://www.w3.org/2002/07/owl#minCardinality"),
      /** The property that determines the cardinality of a minimum qualified cardinality restriction. */
      "minQualifiedCardinality": new n3.NamedNode("http://www.w3.org/2002/07/owl#minQualifiedCardinality"),
      /** The property that determines the class that a qualified object cardinality restriction refers to. */
      "onClass": new n3.NamedNode("http://www.w3.org/2002/07/owl#onClass"),
      /** The property that determines the data range that a qualified data cardinality restriction refers to. */
      "onDataRange": new n3.NamedNode("http://www.w3.org/2002/07/owl#onDataRange"),
      /** The property that determines the datatype that a datatype restriction refers to. */
      "onDatatype": new n3.NamedNode("http://www.w3.org/2002/07/owl#onDatatype"),
      /** The property that determines the n-tuple of properties that a property restriction on an n-ary data range refers to. */
      "onProperties": new n3.NamedNode("http://www.w3.org/2002/07/owl#onProperties"),
      /** The property that determines the property that a property restriction refers to. */
      "onProperty": new n3.NamedNode("http://www.w3.org/2002/07/owl#onProperty"),
      /** The property that determines the collection of individuals or data values that build an enumeration. */
      "oneOf": new n3.NamedNode("http://www.w3.org/2002/07/owl#oneOf"),
      /** The annotation property that indicates the predecessor ontology of a given ontology. */
      "priorVersion": new n3.NamedNode("http://www.w3.org/2002/07/owl#priorVersion"),
      /** The property that determines the n-tuple of properties that build a sub property chain of a given property. */
      "propertyChainAxiom": new n3.NamedNode("http://www.w3.org/2002/07/owl#propertyChainAxiom"),
      /** The property that determines that two given properties are disjoint. */
      "propertyDisjointWith": new n3.NamedNode("http://www.w3.org/2002/07/owl#propertyDisjointWith"),
      /** The property that determines the cardinality of an exact qualified cardinality restriction. */
      "qualifiedCardinality": new n3.NamedNode("http://www.w3.org/2002/07/owl#qualifiedCardinality"),
      /** The property that determines that two given individuals are equal. */
      "sameAs": new n3.NamedNode("http://www.w3.org/2002/07/owl#sameAs"),
      /** The property that determines the class that an existential property restriction refers to. */
      "someValuesFrom": new n3.NamedNode("http://www.w3.org/2002/07/owl#someValuesFrom"),
      /** The property that determines the subject of a negative property assertion. */
      "sourceIndividual": new n3.NamedNode("http://www.w3.org/2002/07/owl#sourceIndividual"),
      /** The property that determines the object of a negative object property assertion. */
      "targetIndividual": new n3.NamedNode("http://www.w3.org/2002/07/owl#targetIndividual"),
      /** The property that determines the value of a negative data property assertion. */
      "targetValue": new n3.NamedNode("http://www.w3.org/2002/07/owl#targetValue"),
      /** The data property that relates every individual to every data value. */
      "topDataProperty": new n3.NamedNode("http://www.w3.org/2002/07/owl#topDataProperty"),
      /** The object property that relates every two individuals. */
      "topObjectProperty": new n3.NamedNode("http://www.w3.org/2002/07/owl#topObjectProperty"),
      /** The property that determines the collection of classes or data ranges that build a union. */
      "unionOf": new n3.NamedNode("http://www.w3.org/2002/07/owl#unionOf"),
      /** The property that identifies the version IRI of an ontology. */
      "versionIRI": new n3.NamedNode("http://www.w3.org/2002/07/owl#versionIRI"),
      /** The annotation property that provides version information for an ontology or another OWL construct. */
      "versionInfo": new n3.NamedNode("http://www.w3.org/2002/07/owl#versionInfo"),
      /** The property that determines the collection of facet-value pairs that define a datatype restriction. */
      "withRestrictions": new n3.NamedNode("http://www.w3.org/2002/07/owl#withRestrictions")
    };
  }
});

// node_modules/@faubulous/mentor-rdf/dist/ontologies/rdf.js
var require_rdf = __commonJS({
  "node_modules/@faubulous/mentor-rdf/dist/ontologies/rdf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rdf = exports.RDF = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var n3 = tslib_1.__importStar((init_src(), __toCommonJS(src_exports)));
    exports.RDF = {
      /** The class of containers of alternatives. */
      "Alt": "http://www.w3.org/1999/02/22-rdf-syntax-ns#Alt",
      /** The class of unordered containers. */
      "Bag": "http://www.w3.org/1999/02/22-rdf-syntax-ns#Bag",
      /** A class representing a compound literal. */
      "CompoundLiteral": "http://www.w3.org/1999/02/22-rdf-syntax-ns#CompoundLiteral",
      /** The datatype of RDF literals storing fragments of HTML content */
      "HTML": "http://www.w3.org/1999/02/22-rdf-syntax-ns#HTML",
      /** The datatype of RDF literals storing JSON content. */
      "JSON": "http://www.w3.org/1999/02/22-rdf-syntax-ns#JSON",
      /** The class of RDF Lists. */
      "List": "http://www.w3.org/1999/02/22-rdf-syntax-ns#List",
      /** The class of plain (i.e. untyped) literal values, as used in RIF and OWL 2 */
      "PlainLiteral": "http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral",
      /** The class of RDF properties. */
      "Property": "http://www.w3.org/1999/02/22-rdf-syntax-ns#Property",
      /** The class of ordered containers. */
      "Seq": "http://www.w3.org/1999/02/22-rdf-syntax-ns#Seq",
      /** The class of RDF statements. */
      "Statement": "http://www.w3.org/1999/02/22-rdf-syntax-ns#Statement",
      /** The datatype of XML literal values. */
      "XMLLiteral": "http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral",
      /** The base direction component of a CompoundLiteral. */
      "direction": "http://www.w3.org/1999/02/22-rdf-syntax-ns#direction",
      /** The first item in the subject RDF list. */
      "first": "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
      /** The datatype of language-tagged string values */
      "langString": "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString",
      /** The language component of a CompoundLiteral. */
      "language": "http://www.w3.org/1999/02/22-rdf-syntax-ns#language",
      /** The empty list, with no items in it. If the rest of a list is nil then the list has no more items in it. */
      "nil": "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil",
      /** The object of the subject RDF statement. */
      "object": "http://www.w3.org/1999/02/22-rdf-syntax-ns#object",
      /** The predicate of the subject RDF statement. */
      "predicate": "http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate",
      /** The rest of the subject RDF list after the first item. */
      "rest": "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
      /** The subject of the subject RDF statement. */
      "subject": "http://www.w3.org/1999/02/22-rdf-syntax-ns#subject",
      /** The subject is an instance of a class. */
      "type": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
      /** Idiomatic property used for structured values. */
      "value": "http://www.w3.org/1999/02/22-rdf-syntax-ns#value"
    };
    exports.rdf = {
      /** The class of containers of alternatives. */
      "Alt": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#Alt"),
      /** The class of unordered containers. */
      "Bag": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#Bag"),
      /** A class representing a compound literal. */
      "CompoundLiteral": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#CompoundLiteral"),
      /** The datatype of RDF literals storing fragments of HTML content */
      "HTML": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#HTML"),
      /** The datatype of RDF literals storing JSON content. */
      "JSON": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#JSON"),
      /** The class of RDF Lists. */
      "List": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#List"),
      /** The class of plain (i.e. untyped) literal values, as used in RIF and OWL 2 */
      "PlainLiteral": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral"),
      /** The class of RDF properties. */
      "Property": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#Property"),
      /** The class of ordered containers. */
      "Seq": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#Seq"),
      /** The class of RDF statements. */
      "Statement": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#Statement"),
      /** The datatype of XML literal values. */
      "XMLLiteral": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral"),
      /** The base direction component of a CompoundLiteral. */
      "direction": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#direction"),
      /** The first item in the subject RDF list. */
      "first": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#first"),
      /** The datatype of language-tagged string values */
      "langString": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString"),
      /** The language component of a CompoundLiteral. */
      "language": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#language"),
      /** The empty list, with no items in it. If the rest of a list is nil then the list has no more items in it. */
      "nil": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#nil"),
      /** The object of the subject RDF statement. */
      "object": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#object"),
      /** The predicate of the subject RDF statement. */
      "predicate": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate"),
      /** The rest of the subject RDF list after the first item. */
      "rest": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#rest"),
      /** The subject of the subject RDF statement. */
      "subject": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#subject"),
      /** The subject is an instance of a class. */
      "type": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"),
      /** Idiomatic property used for structured values. */
      "value": new n3.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#value")
    };
  }
});

// node_modules/@faubulous/mentor-rdf/dist/ontologies/rdfa.js
var require_rdfa = __commonJS({
  "node_modules/@faubulous/mentor-rdf/dist/ontologies/rdfa.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rdfa = exports.RDFA = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var n3 = tslib_1.__importStar((init_src(), __toCommonJS(src_exports)));
    exports.RDFA = {
      "me": "http://www.ivan-herman.net/foaf#me",
      "DocumentError": "http://www.w3.org/ns/rdfa#DocumentError",
      "Error": "http://www.w3.org/ns/rdfa#Error",
      "Info": "http://www.w3.org/ns/rdfa#Info",
      "PGClass": "http://www.w3.org/ns/rdfa#PGClass",
      "Pattern": "http://www.w3.org/ns/rdfa#Pattern",
      "PrefixMapping": "http://www.w3.org/ns/rdfa#PrefixMapping",
      "PrefixOrTermMapping": "http://www.w3.org/ns/rdfa#PrefixOrTermMapping",
      "PrefixRedefinition": "http://www.w3.org/ns/rdfa#PrefixRedefinition",
      "TermMapping": "http://www.w3.org/ns/rdfa#TermMapping",
      "UnresolvedCURIE": "http://www.w3.org/ns/rdfa#UnresolvedCURIE",
      "UnresolvedTerm": "http://www.w3.org/ns/rdfa#UnresolvedTerm",
      "VocabReferenceError": "http://www.w3.org/ns/rdfa#VocabReferenceError",
      "Warning": "http://www.w3.org/ns/rdfa#Warning",
      "context": "http://www.w3.org/ns/rdfa#context",
      "copy": "http://www.w3.org/ns/rdfa#copy",
      "prefix": "http://www.w3.org/ns/rdfa#prefix",
      "term": "http://www.w3.org/ns/rdfa#term",
      "uri": "http://www.w3.org/ns/rdfa#uri",
      "usesVocabulary": "http://www.w3.org/ns/rdfa#usesVocabulary",
      "vocabulary": "http://www.w3.org/ns/rdfa#vocabulary"
    };
    exports.rdfa = {
      "me": new n3.NamedNode("http://www.ivan-herman.net/foaf#me"),
      "DocumentError": new n3.NamedNode("http://www.w3.org/ns/rdfa#DocumentError"),
      "Error": new n3.NamedNode("http://www.w3.org/ns/rdfa#Error"),
      "Info": new n3.NamedNode("http://www.w3.org/ns/rdfa#Info"),
      "PGClass": new n3.NamedNode("http://www.w3.org/ns/rdfa#PGClass"),
      "Pattern": new n3.NamedNode("http://www.w3.org/ns/rdfa#Pattern"),
      "PrefixMapping": new n3.NamedNode("http://www.w3.org/ns/rdfa#PrefixMapping"),
      "PrefixOrTermMapping": new n3.NamedNode("http://www.w3.org/ns/rdfa#PrefixOrTermMapping"),
      "PrefixRedefinition": new n3.NamedNode("http://www.w3.org/ns/rdfa#PrefixRedefinition"),
      "TermMapping": new n3.NamedNode("http://www.w3.org/ns/rdfa#TermMapping"),
      "UnresolvedCURIE": new n3.NamedNode("http://www.w3.org/ns/rdfa#UnresolvedCURIE"),
      "UnresolvedTerm": new n3.NamedNode("http://www.w3.org/ns/rdfa#UnresolvedTerm"),
      "VocabReferenceError": new n3.NamedNode("http://www.w3.org/ns/rdfa#VocabReferenceError"),
      "Warning": new n3.NamedNode("http://www.w3.org/ns/rdfa#Warning"),
      "context": new n3.NamedNode("http://www.w3.org/ns/rdfa#context"),
      "copy": new n3.NamedNode("http://www.w3.org/ns/rdfa#copy"),
      "prefix": new n3.NamedNode("http://www.w3.org/ns/rdfa#prefix"),
      "term": new n3.NamedNode("http://www.w3.org/ns/rdfa#term"),
      "uri": new n3.NamedNode("http://www.w3.org/ns/rdfa#uri"),
      "usesVocabulary": new n3.NamedNode("http://www.w3.org/ns/rdfa#usesVocabulary"),
      "vocabulary": new n3.NamedNode("http://www.w3.org/ns/rdfa#vocabulary")
    };
  }
});

// node_modules/@faubulous/mentor-rdf/dist/ontologies/rdfs.js
var require_rdfs = __commonJS({
  "node_modules/@faubulous/mentor-rdf/dist/ontologies/rdfs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rdfs = exports.RDFS = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var n3 = tslib_1.__importStar((init_src(), __toCommonJS(src_exports)));
    exports.RDFS = {
      /** The class of classes. */
      "Class": "http://www.w3.org/2000/01/rdf-schema#Class",
      /** The class of RDF containers. */
      "Container": "http://www.w3.org/2000/01/rdf-schema#Container",
      /** The class of container membership properties, rdf:_1, rdf:_2, ...,
                      all of which are sub-properties of 'member'. */
      "ContainerMembershipProperty": "http://www.w3.org/2000/01/rdf-schema#ContainerMembershipProperty",
      /** The class of RDF datatypes. */
      "Datatype": "http://www.w3.org/2000/01/rdf-schema#Datatype",
      /** The class of literal values, eg. textual strings and integers. */
      "Literal": "http://www.w3.org/2000/01/rdf-schema#Literal",
      /** The class resource, everything. */
      "Resource": "http://www.w3.org/2000/01/rdf-schema#Resource",
      /** A description of the subject resource. */
      "comment": "http://www.w3.org/2000/01/rdf-schema#comment",
      /** A domain of the subject property. */
      "domain": "http://www.w3.org/2000/01/rdf-schema#domain",
      /** The defininition of the subject resource. */
      "isDefinedBy": "http://www.w3.org/2000/01/rdf-schema#isDefinedBy",
      /** A human-readable name for the subject. */
      "label": "http://www.w3.org/2000/01/rdf-schema#label",
      /** A member of the subject resource. */
      "member": "http://www.w3.org/2000/01/rdf-schema#member",
      /** A range of the subject property. */
      "range": "http://www.w3.org/2000/01/rdf-schema#range",
      /** Further information about the subject resource. */
      "seeAlso": "http://www.w3.org/2000/01/rdf-schema#seeAlso",
      /** The subject is a subclass of a class. */
      "subClassOf": "http://www.w3.org/2000/01/rdf-schema#subClassOf",
      /** The subject is a subproperty of a property. */
      "subPropertyOf": "http://www.w3.org/2000/01/rdf-schema#subPropertyOf"
    };
    exports.rdfs = {
      /** The class of classes. */
      "Class": new n3.NamedNode("http://www.w3.org/2000/01/rdf-schema#Class"),
      /** The class of RDF containers. */
      "Container": new n3.NamedNode("http://www.w3.org/2000/01/rdf-schema#Container"),
      /** The class of container membership properties, rdf:_1, rdf:_2, ...,
                      all of which are sub-properties of 'member'. */
      "ContainerMembershipProperty": new n3.NamedNode("http://www.w3.org/2000/01/rdf-schema#ContainerMembershipProperty"),
      /** The class of RDF datatypes. */
      "Datatype": new n3.NamedNode("http://www.w3.org/2000/01/rdf-schema#Datatype"),
      /** The class of literal values, eg. textual strings and integers. */
      "Literal": new n3.NamedNode("http://www.w3.org/2000/01/rdf-schema#Literal"),
      /** The class resource, everything. */
      "Resource": new n3.NamedNode("http://www.w3.org/2000/01/rdf-schema#Resource"),
      /** A description of the subject resource. */
      "comment": new n3.NamedNode("http://www.w3.org/2000/01/rdf-schema#comment"),
      /** A domain of the subject property. */
      "domain": new n3.NamedNode("http://www.w3.org/2000/01/rdf-schema#domain"),
      /** The defininition of the subject resource. */
      "isDefinedBy": new n3.NamedNode("http://www.w3.org/2000/01/rdf-schema#isDefinedBy"),
      /** A human-readable name for the subject. */
      "label": new n3.NamedNode("http://www.w3.org/2000/01/rdf-schema#label"),
      /** A member of the subject resource. */
      "member": new n3.NamedNode("http://www.w3.org/2000/01/rdf-schema#member"),
      /** A range of the subject property. */
      "range": new n3.NamedNode("http://www.w3.org/2000/01/rdf-schema#range"),
      /** Further information about the subject resource. */
      "seeAlso": new n3.NamedNode("http://www.w3.org/2000/01/rdf-schema#seeAlso"),
      /** The subject is a subclass of a class. */
      "subClassOf": new n3.NamedNode("http://www.w3.org/2000/01/rdf-schema#subClassOf"),
      /** The subject is a subproperty of a property. */
      "subPropertyOf": new n3.NamedNode("http://www.w3.org/2000/01/rdf-schema#subPropertyOf")
    };
  }
});

// node_modules/@faubulous/mentor-rdf/dist/ontologies/shacl.js
var require_shacl = __commonJS({
  "node_modules/@faubulous/mentor-rdf/dist/ontologies/shacl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shacl = exports.SHACL = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var n3 = tslib_1.__importStar((init_src(), __toCommonJS(src_exports)));
    exports.SHACL = {
      /** The base class of validation results, typically not instantiated directly. */
      "AbstractResult": "http://www.w3.org/ns/shacl#AbstractResult",
      /** A constraint component that can be used to test whether a value node conforms to all members of a provided list of shapes. */
      "AndConstraintComponent": "http://www.w3.org/ns/shacl#AndConstraintComponent",
      "AndConstraintComponent-and": "http://www.w3.org/ns/shacl#AndConstraintComponent-and",
      /** The node kind of all blank nodes. */
      "BlankNode": "http://www.w3.org/ns/shacl#BlankNode",
      /** The node kind of all blank nodes or IRIs. */
      "BlankNodeOrIRI": "http://www.w3.org/ns/shacl#BlankNodeOrIRI",
      /** The node kind of all blank nodes or literals. */
      "BlankNodeOrLiteral": "http://www.w3.org/ns/shacl#BlankNodeOrLiteral",
      /** A constraint component that can be used to verify that each value node is an instance of a given type. */
      "ClassConstraintComponent": "http://www.w3.org/ns/shacl#ClassConstraintComponent",
      "ClassConstraintComponent-class": "http://www.w3.org/ns/shacl#ClassConstraintComponent-class",
      /** A constraint component that can be used to indicate that focus nodes must only have values for those properties that have been explicitly enumerated via sh:property/sh:path. */
      "ClosedConstraintComponent": "http://www.w3.org/ns/shacl#ClosedConstraintComponent",
      "ClosedConstraintComponent-closed": "http://www.w3.org/ns/shacl#ClosedConstraintComponent-closed",
      "ClosedConstraintComponent-ignoredProperties": "http://www.w3.org/ns/shacl#ClosedConstraintComponent-ignoredProperties",
      /** The class of constraint components. */
      "ConstraintComponent": "http://www.w3.org/ns/shacl#ConstraintComponent",
      /** A constraint component that can be used to restrict the datatype of all value nodes. */
      "DatatypeConstraintComponent": "http://www.w3.org/ns/shacl#DatatypeConstraintComponent",
      "DatatypeConstraintComponent-datatype": "http://www.w3.org/ns/shacl#DatatypeConstraintComponent-datatype",
      /** A constraint component that can be used to verify that the set of value nodes is disjoint with the the set of nodes that have the focus node as subject and the value of a given property as predicate. */
      "DisjointConstraintComponent": "http://www.w3.org/ns/shacl#DisjointConstraintComponent",
      "DisjointConstraintComponent-disjoint": "http://www.w3.org/ns/shacl#DisjointConstraintComponent-disjoint",
      /** A constraint component that can be used to verify that the set of value nodes is equal to the set of nodes that have the focus node as subject and the value of a given property as predicate. */
      "EqualsConstraintComponent": "http://www.w3.org/ns/shacl#EqualsConstraintComponent",
      "EqualsConstraintComponent-equals": "http://www.w3.org/ns/shacl#EqualsConstraintComponent-equals",
      /** A constraint component that can be used to verify that a given node expression produces true for all value nodes. */
      "ExpressionConstraintComponent": "http://www.w3.org/ns/shacl#ExpressionConstraintComponent",
      "ExpressionConstraintComponent-expression": "http://www.w3.org/ns/shacl#ExpressionConstraintComponent-expression",
      /** The class of SHACL functions. */
      "Function": "http://www.w3.org/ns/shacl#Function",
      /** A constraint component that can be used to verify that one of the value nodes is a given RDF node. */
      "HasValueConstraintComponent": "http://www.w3.org/ns/shacl#HasValueConstraintComponent",
      "HasValueConstraintComponent-hasValue": "http://www.w3.org/ns/shacl#HasValueConstraintComponent-hasValue",
      /** The node kind of all IRIs. */
      "IRI": "http://www.w3.org/ns/shacl#IRI",
      /** The node kind of all IRIs or literals. */
      "IRIOrLiteral": "http://www.w3.org/ns/shacl#IRIOrLiteral",
      /** A constraint component that can be used to exclusively enumerate the permitted value nodes. */
      "InConstraintComponent": "http://www.w3.org/ns/shacl#InConstraintComponent",
      "InConstraintComponent-in": "http://www.w3.org/ns/shacl#InConstraintComponent-in",
      /** The severity for an informational validation result. */
      "Info": "http://www.w3.org/ns/shacl#Info",
      /** The class of constraints backed by a JavaScript function. */
      "JSConstraint": "http://www.w3.org/ns/shacl#JSConstraint",
      "JSConstraint-js": "http://www.w3.org/ns/shacl#JSConstraint-js",
      /** A constraint component with the parameter sh:js linking to a sh:JSConstraint containing a sh:script. */
      "JSConstraintComponent": "http://www.w3.org/ns/shacl#JSConstraintComponent",
      /** Abstract base class of resources that declare an executable JavaScript. */
      "JSExecutable": "http://www.w3.org/ns/shacl#JSExecutable",
      /** The class of SHACL functions that execute a JavaScript function when called. */
      "JSFunction": "http://www.w3.org/ns/shacl#JSFunction",
      /** Represents a JavaScript library, typically identified by one or more URLs of files to include. */
      "JSLibrary": "http://www.w3.org/ns/shacl#JSLibrary",
      /** The class of SHACL rules expressed using JavaScript. */
      "JSRule": "http://www.w3.org/ns/shacl#JSRule",
      /** The class of targets that are based on JavaScript functions. */
      "JSTarget": "http://www.w3.org/ns/shacl#JSTarget",
      /** The (meta) class for parameterizable targets that are based on JavaScript functions. */
      "JSTargetType": "http://www.w3.org/ns/shacl#JSTargetType",
      /** A SHACL validator based on JavaScript. This can be used to declare SHACL constraint components that perform JavaScript-based validation when used. */
      "JSValidator": "http://www.w3.org/ns/shacl#JSValidator",
      /** A constraint component that can be used to enumerate language tags that all value nodes must have. */
      "LanguageInConstraintComponent": "http://www.w3.org/ns/shacl#LanguageInConstraintComponent",
      "LanguageInConstraintComponent-languageIn": "http://www.w3.org/ns/shacl#LanguageInConstraintComponent-languageIn",
      /** A constraint component that can be used to verify that each value node is smaller than all the nodes that have the focus node as subject and the value of a given property as predicate. */
      "LessThanConstraintComponent": "http://www.w3.org/ns/shacl#LessThanConstraintComponent",
      "LessThanConstraintComponent-lessThan": "http://www.w3.org/ns/shacl#LessThanConstraintComponent-lessThan",
      /** A constraint component that can be used to verify that every value node is smaller than all the nodes that have the focus node as subject and the value of a given property as predicate. */
      "LessThanOrEqualsConstraintComponent": "http://www.w3.org/ns/shacl#LessThanOrEqualsConstraintComponent",
      "LessThanOrEqualsConstraintComponent-lessThanOrEquals": "http://www.w3.org/ns/shacl#LessThanOrEqualsConstraintComponent-lessThanOrEquals",
      /** The node kind of all literals. */
      "Literal": "http://www.w3.org/ns/shacl#Literal",
      /** A constraint component that can be used to restrict the maximum number of value nodes. */
      "MaxCountConstraintComponent": "http://www.w3.org/ns/shacl#MaxCountConstraintComponent",
      "MaxCountConstraintComponent-maxCount": "http://www.w3.org/ns/shacl#MaxCountConstraintComponent-maxCount",
      /** A constraint component that can be used to restrict the range of value nodes with a maximum exclusive value. */
      "MaxExclusiveConstraintComponent": "http://www.w3.org/ns/shacl#MaxExclusiveConstraintComponent",
      "MaxExclusiveConstraintComponent-maxExclusive": "http://www.w3.org/ns/shacl#MaxExclusiveConstraintComponent-maxExclusive",
      /** A constraint component that can be used to restrict the range of value nodes with a maximum inclusive value. */
      "MaxInclusiveConstraintComponent": "http://www.w3.org/ns/shacl#MaxInclusiveConstraintComponent",
      "MaxInclusiveConstraintComponent-maxInclusive": "http://www.w3.org/ns/shacl#MaxInclusiveConstraintComponent-maxInclusive",
      /** A constraint component that can be used to restrict the maximum string length of value nodes. */
      "MaxLengthConstraintComponent": "http://www.w3.org/ns/shacl#MaxLengthConstraintComponent",
      "MaxLengthConstraintComponent-maxLength": "http://www.w3.org/ns/shacl#MaxLengthConstraintComponent-maxLength",
      /** A constraint component that can be used to restrict the minimum number of value nodes. */
      "MinCountConstraintComponent": "http://www.w3.org/ns/shacl#MinCountConstraintComponent",
      "MinCountConstraintComponent-minCount": "http://www.w3.org/ns/shacl#MinCountConstraintComponent-minCount",
      /** A constraint component that can be used to restrict the range of value nodes with a minimum exclusive value. */
      "MinExclusiveConstraintComponent": "http://www.w3.org/ns/shacl#MinExclusiveConstraintComponent",
      "MinExclusiveConstraintComponent-minExclusive": "http://www.w3.org/ns/shacl#MinExclusiveConstraintComponent-minExclusive",
      /** A constraint component that can be used to restrict the range of value nodes with a minimum inclusive value. */
      "MinInclusiveConstraintComponent": "http://www.w3.org/ns/shacl#MinInclusiveConstraintComponent",
      "MinInclusiveConstraintComponent-minInclusive": "http://www.w3.org/ns/shacl#MinInclusiveConstraintComponent-minInclusive",
      /** A constraint component that can be used to restrict the minimum string length of value nodes. */
      "MinLengthConstraintComponent": "http://www.w3.org/ns/shacl#MinLengthConstraintComponent",
      "MinLengthConstraintComponent-minLength": "http://www.w3.org/ns/shacl#MinLengthConstraintComponent-minLength",
      /** A constraint component that can be used to verify that all value nodes conform to the given node shape. */
      "NodeConstraintComponent": "http://www.w3.org/ns/shacl#NodeConstraintComponent",
      "NodeConstraintComponent-node": "http://www.w3.org/ns/shacl#NodeConstraintComponent-node",
      /** The class of all node kinds, including sh:BlankNode, sh:IRI, sh:Literal or the combinations of these: sh:BlankNodeOrIRI, sh:BlankNodeOrLiteral, sh:IRIOrLiteral. */
      "NodeKind": "http://www.w3.org/ns/shacl#NodeKind",
      /** A constraint component that can be used to restrict the RDF node kind of each value node. */
      "NodeKindConstraintComponent": "http://www.w3.org/ns/shacl#NodeKindConstraintComponent",
      "NodeKindConstraintComponent-nodeKind": "http://www.w3.org/ns/shacl#NodeKindConstraintComponent-nodeKind",
      /** A node shape is a shape that specifies constraint that need to be met with respect to focus nodes. */
      "NodeShape": "http://www.w3.org/ns/shacl#NodeShape",
      /** A constraint component that can be used to verify that value nodes do not conform to a given shape. */
      "NotConstraintComponent": "http://www.w3.org/ns/shacl#NotConstraintComponent",
      "NotConstraintComponent-not": "http://www.w3.org/ns/shacl#NotConstraintComponent-not",
      /** A constraint component that can be used to restrict the value nodes so that they conform to at least one out of several provided shapes. */
      "OrConstraintComponent": "http://www.w3.org/ns/shacl#OrConstraintComponent",
      "OrConstraintComponent-or": "http://www.w3.org/ns/shacl#OrConstraintComponent-or",
      /** The class of parameter declarations, consisting of a path predicate and (possibly) information about allowed value type, cardinality and other characteristics. */
      "Parameter": "http://www.w3.org/ns/shacl#Parameter",
      /** Superclass of components that can take parameters, especially functions and constraint components. */
      "Parameterizable": "http://www.w3.org/ns/shacl#Parameterizable",
      /** A constraint component that can be used to verify that every value node matches a given regular expression. */
      "PatternConstraintComponent": "http://www.w3.org/ns/shacl#PatternConstraintComponent",
      "PatternConstraintComponent-flags": "http://www.w3.org/ns/shacl#PatternConstraintComponent-flags",
      "PatternConstraintComponent-pattern": "http://www.w3.org/ns/shacl#PatternConstraintComponent-pattern",
      /** The class of prefix declarations, consisting of pairs of a prefix with a namespace. */
      "PrefixDeclaration": "http://www.w3.org/ns/shacl#PrefixDeclaration",
      /** A constraint component that can be used to verify that all value nodes conform to the given property shape. */
      "PropertyConstraintComponent": "http://www.w3.org/ns/shacl#PropertyConstraintComponent",
      "PropertyConstraintComponent-property": "http://www.w3.org/ns/shacl#PropertyConstraintComponent-property",
      /** Instances of this class represent groups of property shapes that belong together. */
      "PropertyGroup": "http://www.w3.org/ns/shacl#PropertyGroup",
      /** A property shape is a shape that specifies constraints on the values of a focus node for a given property or path. */
      "PropertyShape": "http://www.w3.org/ns/shacl#PropertyShape",
      /** A constraint component that can be used to verify that a specified maximum number of value nodes conforms to a given shape. */
      "QualifiedMaxCountConstraintComponent": "http://www.w3.org/ns/shacl#QualifiedMaxCountConstraintComponent",
      "QualifiedMaxCountConstraintComponent-qualifiedMaxCount": "http://www.w3.org/ns/shacl#QualifiedMaxCountConstraintComponent-qualifiedMaxCount",
      "QualifiedMaxCountConstraintComponent-qualifiedValueShape": "http://www.w3.org/ns/shacl#QualifiedMaxCountConstraintComponent-qualifiedValueShape",
      "QualifiedMaxCountConstraintComponent-qualifiedValueShapesDisjoint": "http://www.w3.org/ns/shacl#QualifiedMaxCountConstraintComponent-qualifiedValueShapesDisjoint",
      /** A constraint component that can be used to verify that a specified minimum number of value nodes conforms to a given shape. */
      "QualifiedMinCountConstraintComponent": "http://www.w3.org/ns/shacl#QualifiedMinCountConstraintComponent",
      "QualifiedMinCountConstraintComponent-qualifiedMinCount": "http://www.w3.org/ns/shacl#QualifiedMinCountConstraintComponent-qualifiedMinCount",
      "QualifiedMinCountConstraintComponent-qualifiedValueShape": "http://www.w3.org/ns/shacl#QualifiedMinCountConstraintComponent-qualifiedValueShape",
      "QualifiedMinCountConstraintComponent-qualifiedValueShapesDisjoint": "http://www.w3.org/ns/shacl#QualifiedMinCountConstraintComponent-qualifiedValueShapesDisjoint",
      /** A class of result annotations, which define the rules to derive the values of a given annotation property as extra values for a validation result. */
      "ResultAnnotation": "http://www.w3.org/ns/shacl#ResultAnnotation",
      /** The class of SHACL rules. Never instantiated directly. */
      "Rule": "http://www.w3.org/ns/shacl#Rule",
      /** The class of SPARQL executables that are based on an ASK query. */
      "SPARQLAskExecutable": "http://www.w3.org/ns/shacl#SPARQLAskExecutable",
      /** The class of validators based on SPARQL ASK queries. The queries are evaluated for each value node and are supposed to return true if the given node conforms. */
      "SPARQLAskValidator": "http://www.w3.org/ns/shacl#SPARQLAskValidator",
      /** The class of constraints based on SPARQL SELECT queries. */
      "SPARQLConstraint": "http://www.w3.org/ns/shacl#SPARQLConstraint",
      /** A constraint component that can be used to define constraints based on SPARQL queries. */
      "SPARQLConstraintComponent": "http://www.w3.org/ns/shacl#SPARQLConstraintComponent",
      "SPARQLConstraintComponent-sparql": "http://www.w3.org/ns/shacl#SPARQLConstraintComponent-sparql",
      /** The class of SPARQL executables that are based on a CONSTRUCT query. */
      "SPARQLConstructExecutable": "http://www.w3.org/ns/shacl#SPARQLConstructExecutable",
      /** The class of resources that encapsulate a SPARQL query. */
      "SPARQLExecutable": "http://www.w3.org/ns/shacl#SPARQLExecutable",
      /** A function backed by a SPARQL query - either ASK or SELECT. */
      "SPARQLFunction": "http://www.w3.org/ns/shacl#SPARQLFunction",
      /** The class of SHACL rules based on SPARQL CONSTRUCT queries. */
      "SPARQLRule": "http://www.w3.org/ns/shacl#SPARQLRule",
      /** The class of SPARQL executables based on a SELECT query. */
      "SPARQLSelectExecutable": "http://www.w3.org/ns/shacl#SPARQLSelectExecutable",
      /** The class of validators based on SPARQL SELECT queries. The queries are evaluated for each focus node and are supposed to produce bindings for all focus nodes that do not conform. */
      "SPARQLSelectValidator": "http://www.w3.org/ns/shacl#SPARQLSelectValidator",
      /** The class of targets that are based on SPARQL queries. */
      "SPARQLTarget": "http://www.w3.org/ns/shacl#SPARQLTarget",
      /** The (meta) class for parameterizable targets that are based on SPARQL queries. */
      "SPARQLTargetType": "http://www.w3.org/ns/shacl#SPARQLTargetType",
      /** The class of SPARQL executables based on a SPARQL UPDATE. */
      "SPARQLUpdateExecutable": "http://www.w3.org/ns/shacl#SPARQLUpdateExecutable",
      /** The class of validation result severity levels, including violation and warning levels. */
      "Severity": "http://www.w3.org/ns/shacl#Severity",
      /** A shape is a collection of constraints that may be targeted for certain nodes. */
      "Shape": "http://www.w3.org/ns/shacl#Shape",
      /** The base class of targets such as those based on SPARQL queries. */
      "Target": "http://www.w3.org/ns/shacl#Target",
      /** The (meta) class for parameterizable targets.	Instances of this are instantiated as values of the sh:target property. */
      "TargetType": "http://www.w3.org/ns/shacl#TargetType",
      "TripleRule": "http://www.w3.org/ns/shacl#TripleRule",
      /** A constraint component that can be used to specify that no pair of value nodes may use the same language tag. */
      "UniqueLangConstraintComponent": "http://www.w3.org/ns/shacl#UniqueLangConstraintComponent",
      "UniqueLangConstraintComponent-uniqueLang": "http://www.w3.org/ns/shacl#UniqueLangConstraintComponent-uniqueLang",
      /** The class of SHACL validation reports. */
      "ValidationReport": "http://www.w3.org/ns/shacl#ValidationReport",
      /** The class of validation results. */
      "ValidationResult": "http://www.w3.org/ns/shacl#ValidationResult",
      /** The class of validators, which provide instructions on how to process a constraint definition. This class serves as base class for the SPARQL-based validators and other possible implementations. */
      "Validator": "http://www.w3.org/ns/shacl#Validator",
      /** The severity for a violation validation result. */
      "Violation": "http://www.w3.org/ns/shacl#Violation",
      /** The severity for a warning validation result. */
      "Warning": "http://www.w3.org/ns/shacl#Warning",
      /** A constraint component that can be used to restrict the value nodes so that they conform to exactly one out of several provided shapes. */
      "XoneConstraintComponent": "http://www.w3.org/ns/shacl#XoneConstraintComponent",
      "XoneConstraintComponent-xone": "http://www.w3.org/ns/shacl#XoneConstraintComponent-xone",
      /** The (single) value of this property must be a list of path elements, representing the elements of alternative paths. */
      "alternativePath": "http://www.w3.org/ns/shacl#alternativePath",
      /** RDF list of shapes to validate the value nodes against. */
      "and": "http://www.w3.org/ns/shacl#and",
      /** The annotation property that shall be set. */
      "annotationProperty": "http://www.w3.org/ns/shacl#annotationProperty",
      /** The (default) values of the annotation property. */
      "annotationValue": "http://www.w3.org/ns/shacl#annotationValue",
      /** The name of the SPARQL variable from the SELECT clause that shall be used for the values. */
      "annotationVarName": "http://www.w3.org/ns/shacl#annotationVarName",
      /** The SPARQL ASK query to execute. */
      "ask": "http://www.w3.org/ns/shacl#ask",
      /** The type that all value nodes must have. */
      "class": "http://www.w3.org/ns/shacl#class",
      /** If set to true then the shape is closed. */
      "closed": "http://www.w3.org/ns/shacl#closed",
      /** The shapes that the focus nodes need to conform to before a rule is executed on them. */
      "condition": "http://www.w3.org/ns/shacl#condition",
      /** True if the validation did not produce any validation results, and false otherwise. */
      "conforms": "http://www.w3.org/ns/shacl#conforms",
      /** The SPARQL CONSTRUCT query to execute. */
      "construct": "http://www.w3.org/ns/shacl#construct",
      /** Specifies an RDF datatype that all value nodes must have. */
      "datatype": "http://www.w3.org/ns/shacl#datatype",
      /** If set to true then all nodes conform to this. */
      "deactivated": "http://www.w3.org/ns/shacl#deactivated",
      /** Links a resource with its namespace prefix declarations. */
      "declare": "http://www.w3.org/ns/shacl#declare",
      /** A default value for a property, for example for user interface tools to pre-populate input fields. */
      "defaultValue": "http://www.w3.org/ns/shacl#defaultValue",
      /** Human-readable descriptions for the property in the context of the surrounding shape. */
      "description": "http://www.w3.org/ns/shacl#description",
      /** Links a result with other results that provide more details, for example to describe violations against nested shapes. */
      "detail": "http://www.w3.org/ns/shacl#detail",
      /** Specifies a property where the set of values must be disjoint with the value nodes. */
      "disjoint": "http://www.w3.org/ns/shacl#disjoint",
      /** An entailment regime that indicates what kind of inferencing is required by a shapes graph. */
      "entailment": "http://www.w3.org/ns/shacl#entailment",
      /** Specifies a property that must have the same values as the value nodes. */
      "equals": "http://www.w3.org/ns/shacl#equals",
      /** The node expression that must return true for the value nodes. */
      "expression": "http://www.w3.org/ns/shacl#expression",
      /** The shape that all input nodes of the expression need to conform to. */
      "filterShape": "http://www.w3.org/ns/shacl#filterShape",
      /** An optional flag to be used with regular expression pattern matching. */
      "flags": "http://www.w3.org/ns/shacl#flags",
      /** The focus node that was validated when the result was produced. */
      "focusNode": "http://www.w3.org/ns/shacl#focusNode",
      /** Can be used to link to a property group to indicate that a property shape belongs to a group of related property shapes. */
      "group": "http://www.w3.org/ns/shacl#group",
      /** Specifies a value that must be among the value nodes. */
      "hasValue": "http://www.w3.org/ns/shacl#hasValue",
      /** An optional RDF list of properties that are also permitted in addition to those explicitly enumerated via sh:property/sh:path. */
      "ignoredProperties": "http://www.w3.org/ns/shacl#ignoredProperties",
      /** Specifies a list of allowed values so that each value node must be among the members of the given list. */
      "in": "http://www.w3.org/ns/shacl#in",
      /** A list of node expressions that shall be intersected. */
      "intersection": "http://www.w3.org/ns/shacl#intersection",
      /** The (single) value of this property represents an inverse path (object to subject). */
      "inversePath": "http://www.w3.org/ns/shacl#inversePath",
      /** Constraints expressed in JavaScript. */
      "js": "http://www.w3.org/ns/shacl#js",
      /** The name of the JavaScript function to execute. */
      "jsFunctionName": "http://www.w3.org/ns/shacl#jsFunctionName",
      /** Declares which JavaScript libraries are needed to execute this. */
      "jsLibrary": "http://www.w3.org/ns/shacl#jsLibrary",
      /** Declares the URLs of a JavaScript library. This should be the absolute URL of a JavaScript file. Implementations may redirect those to local files. */
      "jsLibraryURL": "http://www.w3.org/ns/shacl#jsLibraryURL",
      /** Outlines how human-readable labels of instances of the associated Parameterizable shall be produced. The values can contain {?paramName} as placeholders for the actual values of the given parameter. */
      "labelTemplate": "http://www.w3.org/ns/shacl#labelTemplate",
      /** Specifies a list of language tags that all value nodes must have. */
      "languageIn": "http://www.w3.org/ns/shacl#languageIn",
      /** Specifies a property that must have smaller values than the value nodes. */
      "lessThan": "http://www.w3.org/ns/shacl#lessThan",
      /** Specifies a property that must have smaller or equal values than the value nodes. */
      "lessThanOrEquals": "http://www.w3.org/ns/shacl#lessThanOrEquals",
      /** Specifies the maximum number of values in the set of value nodes. */
      "maxCount": "http://www.w3.org/ns/shacl#maxCount",
      /** Specifies the maximum exclusive value of each value node. */
      "maxExclusive": "http://www.w3.org/ns/shacl#maxExclusive",
      /** Specifies the maximum inclusive value of each value node. */
      "maxInclusive": "http://www.w3.org/ns/shacl#maxInclusive",
      /** Specifies the maximum string length of each value node. */
      "maxLength": "http://www.w3.org/ns/shacl#maxLength",
      /** A human-readable message (possibly with placeholders for variables) explaining the cause of the result. */
      "message": "http://www.w3.org/ns/shacl#message",
      /** Specifies the minimum number of values in the set of value nodes. */
      "minCount": "http://www.w3.org/ns/shacl#minCount",
      /** Specifies the minimum exclusive value of each value node. */
      "minExclusive": "http://www.w3.org/ns/shacl#minExclusive",
      /** Specifies the minimum inclusive value of each value node. */
      "minInclusive": "http://www.w3.org/ns/shacl#minInclusive",
      /** Specifies the minimum string length of each value node. */
      "minLength": "http://www.w3.org/ns/shacl#minLength",
      /** Human-readable labels for the property in the context of the surrounding shape. */
      "name": "http://www.w3.org/ns/shacl#name",
      /** The namespace associated with a prefix in a prefix declaration. */
      "namespace": "http://www.w3.org/ns/shacl#namespace",
      /** Specifies the node shape that all value nodes must conform to. */
      "node": "http://www.w3.org/ns/shacl#node",
      /** Specifies the node kind (e.g. IRI or literal) each value node. */
      "nodeKind": "http://www.w3.org/ns/shacl#nodeKind",
      /** The validator(s) used to evaluate a constraint in the context of a node shape. */
      "nodeValidator": "http://www.w3.org/ns/shacl#nodeValidator",
      /** The node expression producing the input nodes of a filter shape expression. */
      "nodes": "http://www.w3.org/ns/shacl#nodes",
      /** Specifies a shape that the value nodes must not conform to. */
      "not": "http://www.w3.org/ns/shacl#not",
      /** An expression producing the nodes that shall be inferred as objects. */
      "object": "http://www.w3.org/ns/shacl#object",
      /** The (single) value of this property represents a path that is matched one or more times. */
      "oneOrMorePath": "http://www.w3.org/ns/shacl#oneOrMorePath",
      /** Indicates whether a parameter is optional. */
      "optional": "http://www.w3.org/ns/shacl#optional",
      /** Specifies a list of shapes so that the value nodes must conform to at least one of the shapes. */
      "or": "http://www.w3.org/ns/shacl#or",
      /** Specifies the relative order of this compared to its siblings. For example use 0 for the first, 1 for the second. */
      "order": "http://www.w3.org/ns/shacl#order",
      /** The parameters of a function or constraint component. */
      "parameter": "http://www.w3.org/ns/shacl#parameter",
      /** Specifies the property path of a property shape. */
      "path": "http://www.w3.org/ns/shacl#path",
      /** Specifies a regular expression pattern that the string representations of the value nodes must match. */
      "pattern": "http://www.w3.org/ns/shacl#pattern",
      /** An expression producing the properties that shall be inferred as predicates. */
      "predicate": "http://www.w3.org/ns/shacl#predicate",
      /** The prefix of a prefix declaration. */
      "prefix": "http://www.w3.org/ns/shacl#prefix",
      /** The prefixes that shall be applied before parsing the associated SPARQL query. */
      "prefixes": "http://www.w3.org/ns/shacl#prefixes",
      /** Links a shape to its property shapes. */
      "property": "http://www.w3.org/ns/shacl#property",
      /** The validator(s) used to evaluate a constraint in the context of a property shape. */
      "propertyValidator": "http://www.w3.org/ns/shacl#propertyValidator",
      /** The maximum number of value nodes that can conform to the shape. */
      "qualifiedMaxCount": "http://www.w3.org/ns/shacl#qualifiedMaxCount",
      /** The minimum number of value nodes that must conform to the shape. */
      "qualifiedMinCount": "http://www.w3.org/ns/shacl#qualifiedMinCount",
      /** The shape that a specified number of values must conform to. */
      "qualifiedValueShape": "http://www.w3.org/ns/shacl#qualifiedValueShape",
      /** Can be used to mark the qualified value shape to be disjoint with its sibling shapes. */
      "qualifiedValueShapesDisjoint": "http://www.w3.org/ns/shacl#qualifiedValueShapesDisjoint",
      /** The validation results contained in a validation report. */
      "result": "http://www.w3.org/ns/shacl#result",
      /** Links a SPARQL validator with zero or more sh:ResultAnnotation instances, defining how to derive additional result properties based on the variables of the SELECT query. */
      "resultAnnotation": "http://www.w3.org/ns/shacl#resultAnnotation",
      /** Human-readable messages explaining the cause of the result. */
      "resultMessage": "http://www.w3.org/ns/shacl#resultMessage",
      /** The path of a validation result, based on the path of the validated property shape. */
      "resultPath": "http://www.w3.org/ns/shacl#resultPath",
      /** The severity of the result, e.g. warning. */
      "resultSeverity": "http://www.w3.org/ns/shacl#resultSeverity",
      /** The expected type of values returned by the associated function. */
      "returnType": "http://www.w3.org/ns/shacl#returnType",
      /** The rules linked to a shape. */
      "rule": "http://www.w3.org/ns/shacl#rule",
      /** The SPARQL SELECT query to execute. */
      "select": "http://www.w3.org/ns/shacl#select",
      /** Defines the severity that validation results produced by a shape must have. Defaults to sh:Violation. */
      "severity": "http://www.w3.org/ns/shacl#severity",
      /** Shapes graphs that should be used when validating this data graph. */
      "shapesGraph": "http://www.w3.org/ns/shacl#shapesGraph",
      /** If true then the validation engine was certain that the shapes graph has passed all SHACL syntax requirements during the validation process. */
      "shapesGraphWellFormed": "http://www.w3.org/ns/shacl#shapesGraphWellFormed",
      /** The constraint that was validated when the result was produced. */
      "sourceConstraint": "http://www.w3.org/ns/shacl#sourceConstraint",
      /** The constraint component that is the source of the result. */
      "sourceConstraintComponent": "http://www.w3.org/ns/shacl#sourceConstraintComponent",
      /** The shape that is was validated when the result was produced. */
      "sourceShape": "http://www.w3.org/ns/shacl#sourceShape",
      /** Links a shape with SPARQL constraints. */
      "sparql": "http://www.w3.org/ns/shacl#sparql",
      /** An expression producing the resources that shall be inferred as subjects. */
      "subject": "http://www.w3.org/ns/shacl#subject",
      /** Suggested shapes graphs for this ontology. The values of this property may be used in the absence of specific sh:shapesGraph statements. */
      "suggestedShapesGraph": "http://www.w3.org/ns/shacl#suggestedShapesGraph",
      /** Links a shape to a target specified by an extension language, for example instances of sh:SPARQLTarget. */
      "target": "http://www.w3.org/ns/shacl#target",
      /** Links a shape to a class, indicating that all instances of the class must conform to the shape. */
      "targetClass": "http://www.w3.org/ns/shacl#targetClass",
      /** Links a shape to individual nodes, indicating that these nodes must conform to the shape. */
      "targetNode": "http://www.w3.org/ns/shacl#targetNode",
      /** Links a shape to a property, indicating that all all objects of triples that have the given property as their predicate must conform to the shape. */
      "targetObjectsOf": "http://www.w3.org/ns/shacl#targetObjectsOf",
      /** Links a shape to a property, indicating that all subjects of triples that have the given property as their predicate must conform to the shape. */
      "targetSubjectsOf": "http://www.w3.org/ns/shacl#targetSubjectsOf",
      /** A node expression that represents the current focus node. */
      "this": "http://www.w3.org/ns/shacl#this",
      /** A list of node expressions that shall be used together. */
      "union": "http://www.w3.org/ns/shacl#union",
      /** Specifies whether all node values must have a unique (or no) language tag. */
      "uniqueLang": "http://www.w3.org/ns/shacl#uniqueLang",
      /** The SPARQL UPDATE to execute. */
      "update": "http://www.w3.org/ns/shacl#update",
      /** The validator(s) used to evaluate constraints of either node or property shapes. */
      "validator": "http://www.w3.org/ns/shacl#validator",
      /** An RDF node that has caused the result. */
      "value": "http://www.w3.org/ns/shacl#value",
      /** Specifies a list of shapes so that the value nodes must conform to exactly one of the shapes. */
      "xone": "http://www.w3.org/ns/shacl#xone",
      /** The (single) value of this property represents a path that is matched zero or more times. */
      "zeroOrMorePath": "http://www.w3.org/ns/shacl#zeroOrMorePath",
      /** The (single) value of this property represents a path that is matched zero or one times. */
      "zeroOrOnePath": "http://www.w3.org/ns/shacl#zeroOrOnePath"
    };
    exports.shacl = {
      /** The base class of validation results, typically not instantiated directly. */
      "AbstractResult": new n3.NamedNode("http://www.w3.org/ns/shacl#AbstractResult"),
      /** A constraint component that can be used to test whether a value node conforms to all members of a provided list of shapes. */
      "AndConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#AndConstraintComponent"),
      "AndConstraintComponent-and": new n3.NamedNode("http://www.w3.org/ns/shacl#AndConstraintComponent-and"),
      /** The node kind of all blank nodes. */
      "BlankNode": new n3.NamedNode("http://www.w3.org/ns/shacl#BlankNode"),
      /** The node kind of all blank nodes or IRIs. */
      "BlankNodeOrIRI": new n3.NamedNode("http://www.w3.org/ns/shacl#BlankNodeOrIRI"),
      /** The node kind of all blank nodes or literals. */
      "BlankNodeOrLiteral": new n3.NamedNode("http://www.w3.org/ns/shacl#BlankNodeOrLiteral"),
      /** A constraint component that can be used to verify that each value node is an instance of a given type. */
      "ClassConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#ClassConstraintComponent"),
      "ClassConstraintComponent-class": new n3.NamedNode("http://www.w3.org/ns/shacl#ClassConstraintComponent-class"),
      /** A constraint component that can be used to indicate that focus nodes must only have values for those properties that have been explicitly enumerated via sh:property/sh:path. */
      "ClosedConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#ClosedConstraintComponent"),
      "ClosedConstraintComponent-closed": new n3.NamedNode("http://www.w3.org/ns/shacl#ClosedConstraintComponent-closed"),
      "ClosedConstraintComponent-ignoredProperties": new n3.NamedNode("http://www.w3.org/ns/shacl#ClosedConstraintComponent-ignoredProperties"),
      /** The class of constraint components. */
      "ConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#ConstraintComponent"),
      /** A constraint component that can be used to restrict the datatype of all value nodes. */
      "DatatypeConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#DatatypeConstraintComponent"),
      "DatatypeConstraintComponent-datatype": new n3.NamedNode("http://www.w3.org/ns/shacl#DatatypeConstraintComponent-datatype"),
      /** A constraint component that can be used to verify that the set of value nodes is disjoint with the the set of nodes that have the focus node as subject and the value of a given property as predicate. */
      "DisjointConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#DisjointConstraintComponent"),
      "DisjointConstraintComponent-disjoint": new n3.NamedNode("http://www.w3.org/ns/shacl#DisjointConstraintComponent-disjoint"),
      /** A constraint component that can be used to verify that the set of value nodes is equal to the set of nodes that have the focus node as subject and the value of a given property as predicate. */
      "EqualsConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#EqualsConstraintComponent"),
      "EqualsConstraintComponent-equals": new n3.NamedNode("http://www.w3.org/ns/shacl#EqualsConstraintComponent-equals"),
      /** A constraint component that can be used to verify that a given node expression produces true for all value nodes. */
      "ExpressionConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#ExpressionConstraintComponent"),
      "ExpressionConstraintComponent-expression": new n3.NamedNode("http://www.w3.org/ns/shacl#ExpressionConstraintComponent-expression"),
      /** The class of SHACL functions. */
      "Function": new n3.NamedNode("http://www.w3.org/ns/shacl#Function"),
      /** A constraint component that can be used to verify that one of the value nodes is a given RDF node. */
      "HasValueConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#HasValueConstraintComponent"),
      "HasValueConstraintComponent-hasValue": new n3.NamedNode("http://www.w3.org/ns/shacl#HasValueConstraintComponent-hasValue"),
      /** The node kind of all IRIs. */
      "IRI": new n3.NamedNode("http://www.w3.org/ns/shacl#IRI"),
      /** The node kind of all IRIs or literals. */
      "IRIOrLiteral": new n3.NamedNode("http://www.w3.org/ns/shacl#IRIOrLiteral"),
      /** A constraint component that can be used to exclusively enumerate the permitted value nodes. */
      "InConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#InConstraintComponent"),
      "InConstraintComponent-in": new n3.NamedNode("http://www.w3.org/ns/shacl#InConstraintComponent-in"),
      /** The severity for an informational validation result. */
      "Info": new n3.NamedNode("http://www.w3.org/ns/shacl#Info"),
      /** The class of constraints backed by a JavaScript function. */
      "JSConstraint": new n3.NamedNode("http://www.w3.org/ns/shacl#JSConstraint"),
      "JSConstraint-js": new n3.NamedNode("http://www.w3.org/ns/shacl#JSConstraint-js"),
      /** A constraint component with the parameter sh:js linking to a sh:JSConstraint containing a sh:script. */
      "JSConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#JSConstraintComponent"),
      /** Abstract base class of resources that declare an executable JavaScript. */
      "JSExecutable": new n3.NamedNode("http://www.w3.org/ns/shacl#JSExecutable"),
      /** The class of SHACL functions that execute a JavaScript function when called. */
      "JSFunction": new n3.NamedNode("http://www.w3.org/ns/shacl#JSFunction"),
      /** Represents a JavaScript library, typically identified by one or more URLs of files to include. */
      "JSLibrary": new n3.NamedNode("http://www.w3.org/ns/shacl#JSLibrary"),
      /** The class of SHACL rules expressed using JavaScript. */
      "JSRule": new n3.NamedNode("http://www.w3.org/ns/shacl#JSRule"),
      /** The class of targets that are based on JavaScript functions. */
      "JSTarget": new n3.NamedNode("http://www.w3.org/ns/shacl#JSTarget"),
      /** The (meta) class for parameterizable targets that are based on JavaScript functions. */
      "JSTargetType": new n3.NamedNode("http://www.w3.org/ns/shacl#JSTargetType"),
      /** A SHACL validator based on JavaScript. This can be used to declare SHACL constraint components that perform JavaScript-based validation when used. */
      "JSValidator": new n3.NamedNode("http://www.w3.org/ns/shacl#JSValidator"),
      /** A constraint component that can be used to enumerate language tags that all value nodes must have. */
      "LanguageInConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#LanguageInConstraintComponent"),
      "LanguageInConstraintComponent-languageIn": new n3.NamedNode("http://www.w3.org/ns/shacl#LanguageInConstraintComponent-languageIn"),
      /** A constraint component that can be used to verify that each value node is smaller than all the nodes that have the focus node as subject and the value of a given property as predicate. */
      "LessThanConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#LessThanConstraintComponent"),
      "LessThanConstraintComponent-lessThan": new n3.NamedNode("http://www.w3.org/ns/shacl#LessThanConstraintComponent-lessThan"),
      /** A constraint component that can be used to verify that every value node is smaller than all the nodes that have the focus node as subject and the value of a given property as predicate. */
      "LessThanOrEqualsConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#LessThanOrEqualsConstraintComponent"),
      "LessThanOrEqualsConstraintComponent-lessThanOrEquals": new n3.NamedNode("http://www.w3.org/ns/shacl#LessThanOrEqualsConstraintComponent-lessThanOrEquals"),
      /** The node kind of all literals. */
      "Literal": new n3.NamedNode("http://www.w3.org/ns/shacl#Literal"),
      /** A constraint component that can be used to restrict the maximum number of value nodes. */
      "MaxCountConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#MaxCountConstraintComponent"),
      "MaxCountConstraintComponent-maxCount": new n3.NamedNode("http://www.w3.org/ns/shacl#MaxCountConstraintComponent-maxCount"),
      /** A constraint component that can be used to restrict the range of value nodes with a maximum exclusive value. */
      "MaxExclusiveConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#MaxExclusiveConstraintComponent"),
      "MaxExclusiveConstraintComponent-maxExclusive": new n3.NamedNode("http://www.w3.org/ns/shacl#MaxExclusiveConstraintComponent-maxExclusive"),
      /** A constraint component that can be used to restrict the range of value nodes with a maximum inclusive value. */
      "MaxInclusiveConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#MaxInclusiveConstraintComponent"),
      "MaxInclusiveConstraintComponent-maxInclusive": new n3.NamedNode("http://www.w3.org/ns/shacl#MaxInclusiveConstraintComponent-maxInclusive"),
      /** A constraint component that can be used to restrict the maximum string length of value nodes. */
      "MaxLengthConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#MaxLengthConstraintComponent"),
      "MaxLengthConstraintComponent-maxLength": new n3.NamedNode("http://www.w3.org/ns/shacl#MaxLengthConstraintComponent-maxLength"),
      /** A constraint component that can be used to restrict the minimum number of value nodes. */
      "MinCountConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#MinCountConstraintComponent"),
      "MinCountConstraintComponent-minCount": new n3.NamedNode("http://www.w3.org/ns/shacl#MinCountConstraintComponent-minCount"),
      /** A constraint component that can be used to restrict the range of value nodes with a minimum exclusive value. */
      "MinExclusiveConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#MinExclusiveConstraintComponent"),
      "MinExclusiveConstraintComponent-minExclusive": new n3.NamedNode("http://www.w3.org/ns/shacl#MinExclusiveConstraintComponent-minExclusive"),
      /** A constraint component that can be used to restrict the range of value nodes with a minimum inclusive value. */
      "MinInclusiveConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#MinInclusiveConstraintComponent"),
      "MinInclusiveConstraintComponent-minInclusive": new n3.NamedNode("http://www.w3.org/ns/shacl#MinInclusiveConstraintComponent-minInclusive"),
      /** A constraint component that can be used to restrict the minimum string length of value nodes. */
      "MinLengthConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#MinLengthConstraintComponent"),
      "MinLengthConstraintComponent-minLength": new n3.NamedNode("http://www.w3.org/ns/shacl#MinLengthConstraintComponent-minLength"),
      /** A constraint component that can be used to verify that all value nodes conform to the given node shape. */
      "NodeConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#NodeConstraintComponent"),
      "NodeConstraintComponent-node": new n3.NamedNode("http://www.w3.org/ns/shacl#NodeConstraintComponent-node"),
      /** The class of all node kinds, including sh:BlankNode, sh:IRI, sh:Literal or the combinations of these: sh:BlankNodeOrIRI, sh:BlankNodeOrLiteral, sh:IRIOrLiteral. */
      "NodeKind": new n3.NamedNode("http://www.w3.org/ns/shacl#NodeKind"),
      /** A constraint component that can be used to restrict the RDF node kind of each value node. */
      "NodeKindConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#NodeKindConstraintComponent"),
      "NodeKindConstraintComponent-nodeKind": new n3.NamedNode("http://www.w3.org/ns/shacl#NodeKindConstraintComponent-nodeKind"),
      /** A node shape is a shape that specifies constraint that need to be met with respect to focus nodes. */
      "NodeShape": new n3.NamedNode("http://www.w3.org/ns/shacl#NodeShape"),
      /** A constraint component that can be used to verify that value nodes do not conform to a given shape. */
      "NotConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#NotConstraintComponent"),
      "NotConstraintComponent-not": new n3.NamedNode("http://www.w3.org/ns/shacl#NotConstraintComponent-not"),
      /** A constraint component that can be used to restrict the value nodes so that they conform to at least one out of several provided shapes. */
      "OrConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#OrConstraintComponent"),
      "OrConstraintComponent-or": new n3.NamedNode("http://www.w3.org/ns/shacl#OrConstraintComponent-or"),
      /** The class of parameter declarations, consisting of a path predicate and (possibly) information about allowed value type, cardinality and other characteristics. */
      "Parameter": new n3.NamedNode("http://www.w3.org/ns/shacl#Parameter"),
      /** Superclass of components that can take parameters, especially functions and constraint components. */
      "Parameterizable": new n3.NamedNode("http://www.w3.org/ns/shacl#Parameterizable"),
      /** A constraint component that can be used to verify that every value node matches a given regular expression. */
      "PatternConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#PatternConstraintComponent"),
      "PatternConstraintComponent-flags": new n3.NamedNode("http://www.w3.org/ns/shacl#PatternConstraintComponent-flags"),
      "PatternConstraintComponent-pattern": new n3.NamedNode("http://www.w3.org/ns/shacl#PatternConstraintComponent-pattern"),
      /** The class of prefix declarations, consisting of pairs of a prefix with a namespace. */
      "PrefixDeclaration": new n3.NamedNode("http://www.w3.org/ns/shacl#PrefixDeclaration"),
      /** A constraint component that can be used to verify that all value nodes conform to the given property shape. */
      "PropertyConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#PropertyConstraintComponent"),
      "PropertyConstraintComponent-property": new n3.NamedNode("http://www.w3.org/ns/shacl#PropertyConstraintComponent-property"),
      /** Instances of this class represent groups of property shapes that belong together. */
      "PropertyGroup": new n3.NamedNode("http://www.w3.org/ns/shacl#PropertyGroup"),
      /** A property shape is a shape that specifies constraints on the values of a focus node for a given property or path. */
      "PropertyShape": new n3.NamedNode("http://www.w3.org/ns/shacl#PropertyShape"),
      /** A constraint component that can be used to verify that a specified maximum number of value nodes conforms to a given shape. */
      "QualifiedMaxCountConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#QualifiedMaxCountConstraintComponent"),
      "QualifiedMaxCountConstraintComponent-qualifiedMaxCount": new n3.NamedNode("http://www.w3.org/ns/shacl#QualifiedMaxCountConstraintComponent-qualifiedMaxCount"),
      "QualifiedMaxCountConstraintComponent-qualifiedValueShape": new n3.NamedNode("http://www.w3.org/ns/shacl#QualifiedMaxCountConstraintComponent-qualifiedValueShape"),
      "QualifiedMaxCountConstraintComponent-qualifiedValueShapesDisjoint": new n3.NamedNode("http://www.w3.org/ns/shacl#QualifiedMaxCountConstraintComponent-qualifiedValueShapesDisjoint"),
      /** A constraint component that can be used to verify that a specified minimum number of value nodes conforms to a given shape. */
      "QualifiedMinCountConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#QualifiedMinCountConstraintComponent"),
      "QualifiedMinCountConstraintComponent-qualifiedMinCount": new n3.NamedNode("http://www.w3.org/ns/shacl#QualifiedMinCountConstraintComponent-qualifiedMinCount"),
      "QualifiedMinCountConstraintComponent-qualifiedValueShape": new n3.NamedNode("http://www.w3.org/ns/shacl#QualifiedMinCountConstraintComponent-qualifiedValueShape"),
      "QualifiedMinCountConstraintComponent-qualifiedValueShapesDisjoint": new n3.NamedNode("http://www.w3.org/ns/shacl#QualifiedMinCountConstraintComponent-qualifiedValueShapesDisjoint"),
      /** A class of result annotations, which define the rules to derive the values of a given annotation property as extra values for a validation result. */
      "ResultAnnotation": new n3.NamedNode("http://www.w3.org/ns/shacl#ResultAnnotation"),
      /** The class of SHACL rules. Never instantiated directly. */
      "Rule": new n3.NamedNode("http://www.w3.org/ns/shacl#Rule"),
      /** The class of SPARQL executables that are based on an ASK query. */
      "SPARQLAskExecutable": new n3.NamedNode("http://www.w3.org/ns/shacl#SPARQLAskExecutable"),
      /** The class of validators based on SPARQL ASK queries. The queries are evaluated for each value node and are supposed to return true if the given node conforms. */
      "SPARQLAskValidator": new n3.NamedNode("http://www.w3.org/ns/shacl#SPARQLAskValidator"),
      /** The class of constraints based on SPARQL SELECT queries. */
      "SPARQLConstraint": new n3.NamedNode("http://www.w3.org/ns/shacl#SPARQLConstraint"),
      /** A constraint component that can be used to define constraints based on SPARQL queries. */
      "SPARQLConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#SPARQLConstraintComponent"),
      "SPARQLConstraintComponent-sparql": new n3.NamedNode("http://www.w3.org/ns/shacl#SPARQLConstraintComponent-sparql"),
      /** The class of SPARQL executables that are based on a CONSTRUCT query. */
      "SPARQLConstructExecutable": new n3.NamedNode("http://www.w3.org/ns/shacl#SPARQLConstructExecutable"),
      /** The class of resources that encapsulate a SPARQL query. */
      "SPARQLExecutable": new n3.NamedNode("http://www.w3.org/ns/shacl#SPARQLExecutable"),
      /** A function backed by a SPARQL query - either ASK or SELECT. */
      "SPARQLFunction": new n3.NamedNode("http://www.w3.org/ns/shacl#SPARQLFunction"),
      /** The class of SHACL rules based on SPARQL CONSTRUCT queries. */
      "SPARQLRule": new n3.NamedNode("http://www.w3.org/ns/shacl#SPARQLRule"),
      /** The class of SPARQL executables based on a SELECT query. */
      "SPARQLSelectExecutable": new n3.NamedNode("http://www.w3.org/ns/shacl#SPARQLSelectExecutable"),
      /** The class of validators based on SPARQL SELECT queries. The queries are evaluated for each focus node and are supposed to produce bindings for all focus nodes that do not conform. */
      "SPARQLSelectValidator": new n3.NamedNode("http://www.w3.org/ns/shacl#SPARQLSelectValidator"),
      /** The class of targets that are based on SPARQL queries. */
      "SPARQLTarget": new n3.NamedNode("http://www.w3.org/ns/shacl#SPARQLTarget"),
      /** The (meta) class for parameterizable targets that are based on SPARQL queries. */
      "SPARQLTargetType": new n3.NamedNode("http://www.w3.org/ns/shacl#SPARQLTargetType"),
      /** The class of SPARQL executables based on a SPARQL UPDATE. */
      "SPARQLUpdateExecutable": new n3.NamedNode("http://www.w3.org/ns/shacl#SPARQLUpdateExecutable"),
      /** The class of validation result severity levels, including violation and warning levels. */
      "Severity": new n3.NamedNode("http://www.w3.org/ns/shacl#Severity"),
      /** A shape is a collection of constraints that may be targeted for certain nodes. */
      "Shape": new n3.NamedNode("http://www.w3.org/ns/shacl#Shape"),
      /** The base class of targets such as those based on SPARQL queries. */
      "Target": new n3.NamedNode("http://www.w3.org/ns/shacl#Target"),
      /** The (meta) class for parameterizable targets.	Instances of this are instantiated as values of the sh:target property. */
      "TargetType": new n3.NamedNode("http://www.w3.org/ns/shacl#TargetType"),
      "TripleRule": new n3.NamedNode("http://www.w3.org/ns/shacl#TripleRule"),
      /** A constraint component that can be used to specify that no pair of value nodes may use the same language tag. */
      "UniqueLangConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#UniqueLangConstraintComponent"),
      "UniqueLangConstraintComponent-uniqueLang": new n3.NamedNode("http://www.w3.org/ns/shacl#UniqueLangConstraintComponent-uniqueLang"),
      /** The class of SHACL validation reports. */
      "ValidationReport": new n3.NamedNode("http://www.w3.org/ns/shacl#ValidationReport"),
      /** The class of validation results. */
      "ValidationResult": new n3.NamedNode("http://www.w3.org/ns/shacl#ValidationResult"),
      /** The class of validators, which provide instructions on how to process a constraint definition. This class serves as base class for the SPARQL-based validators and other possible implementations. */
      "Validator": new n3.NamedNode("http://www.w3.org/ns/shacl#Validator"),
      /** The severity for a violation validation result. */
      "Violation": new n3.NamedNode("http://www.w3.org/ns/shacl#Violation"),
      /** The severity for a warning validation result. */
      "Warning": new n3.NamedNode("http://www.w3.org/ns/shacl#Warning"),
      /** A constraint component that can be used to restrict the value nodes so that they conform to exactly one out of several provided shapes. */
      "XoneConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#XoneConstraintComponent"),
      "XoneConstraintComponent-xone": new n3.NamedNode("http://www.w3.org/ns/shacl#XoneConstraintComponent-xone"),
      /** The (single) value of this property must be a list of path elements, representing the elements of alternative paths. */
      "alternativePath": new n3.NamedNode("http://www.w3.org/ns/shacl#alternativePath"),
      /** RDF list of shapes to validate the value nodes against. */
      "and": new n3.NamedNode("http://www.w3.org/ns/shacl#and"),
      /** The annotation property that shall be set. */
      "annotationProperty": new n3.NamedNode("http://www.w3.org/ns/shacl#annotationProperty"),
      /** The (default) values of the annotation property. */
      "annotationValue": new n3.NamedNode("http://www.w3.org/ns/shacl#annotationValue"),
      /** The name of the SPARQL variable from the SELECT clause that shall be used for the values. */
      "annotationVarName": new n3.NamedNode("http://www.w3.org/ns/shacl#annotationVarName"),
      /** The SPARQL ASK query to execute. */
      "ask": new n3.NamedNode("http://www.w3.org/ns/shacl#ask"),
      /** The type that all value nodes must have. */
      "class": new n3.NamedNode("http://www.w3.org/ns/shacl#class"),
      /** If set to true then the shape is closed. */
      "closed": new n3.NamedNode("http://www.w3.org/ns/shacl#closed"),
      /** The shapes that the focus nodes need to conform to before a rule is executed on them. */
      "condition": new n3.NamedNode("http://www.w3.org/ns/shacl#condition"),
      /** True if the validation did not produce any validation results, and false otherwise. */
      "conforms": new n3.NamedNode("http://www.w3.org/ns/shacl#conforms"),
      /** The SPARQL CONSTRUCT query to execute. */
      "construct": new n3.NamedNode("http://www.w3.org/ns/shacl#construct"),
      /** Specifies an RDF datatype that all value nodes must have. */
      "datatype": new n3.NamedNode("http://www.w3.org/ns/shacl#datatype"),
      /** If set to true then all nodes conform to this. */
      "deactivated": new n3.NamedNode("http://www.w3.org/ns/shacl#deactivated"),
      /** Links a resource with its namespace prefix declarations. */
      "declare": new n3.NamedNode("http://www.w3.org/ns/shacl#declare"),
      /** A default value for a property, for example for user interface tools to pre-populate input fields. */
      "defaultValue": new n3.NamedNode("http://www.w3.org/ns/shacl#defaultValue"),
      /** Human-readable descriptions for the property in the context of the surrounding shape. */
      "description": new n3.NamedNode("http://www.w3.org/ns/shacl#description"),
      /** Links a result with other results that provide more details, for example to describe violations against nested shapes. */
      "detail": new n3.NamedNode("http://www.w3.org/ns/shacl#detail"),
      /** Specifies a property where the set of values must be disjoint with the value nodes. */
      "disjoint": new n3.NamedNode("http://www.w3.org/ns/shacl#disjoint"),
      /** An entailment regime that indicates what kind of inferencing is required by a shapes graph. */
      "entailment": new n3.NamedNode("http://www.w3.org/ns/shacl#entailment"),
      /** Specifies a property that must have the same values as the value nodes. */
      "equals": new n3.NamedNode("http://www.w3.org/ns/shacl#equals"),
      /** The node expression that must return true for the value nodes. */
      "expression": new n3.NamedNode("http://www.w3.org/ns/shacl#expression"),
      /** The shape that all input nodes of the expression need to conform to. */
      "filterShape": new n3.NamedNode("http://www.w3.org/ns/shacl#filterShape"),
      /** An optional flag to be used with regular expression pattern matching. */
      "flags": new n3.NamedNode("http://www.w3.org/ns/shacl#flags"),
      /** The focus node that was validated when the result was produced. */
      "focusNode": new n3.NamedNode("http://www.w3.org/ns/shacl#focusNode"),
      /** Can be used to link to a property group to indicate that a property shape belongs to a group of related property shapes. */
      "group": new n3.NamedNode("http://www.w3.org/ns/shacl#group"),
      /** Specifies a value that must be among the value nodes. */
      "hasValue": new n3.NamedNode("http://www.w3.org/ns/shacl#hasValue"),
      /** An optional RDF list of properties that are also permitted in addition to those explicitly enumerated via sh:property/sh:path. */
      "ignoredProperties": new n3.NamedNode("http://www.w3.org/ns/shacl#ignoredProperties"),
      /** Specifies a list of allowed values so that each value node must be among the members of the given list. */
      "in": new n3.NamedNode("http://www.w3.org/ns/shacl#in"),
      /** A list of node expressions that shall be intersected. */
      "intersection": new n3.NamedNode("http://www.w3.org/ns/shacl#intersection"),
      /** The (single) value of this property represents an inverse path (object to subject). */
      "inversePath": new n3.NamedNode("http://www.w3.org/ns/shacl#inversePath"),
      /** Constraints expressed in JavaScript. */
      "js": new n3.NamedNode("http://www.w3.org/ns/shacl#js"),
      /** The name of the JavaScript function to execute. */
      "jsFunctionName": new n3.NamedNode("http://www.w3.org/ns/shacl#jsFunctionName"),
      /** Declares which JavaScript libraries are needed to execute this. */
      "jsLibrary": new n3.NamedNode("http://www.w3.org/ns/shacl#jsLibrary"),
      /** Declares the URLs of a JavaScript library. This should be the absolute URL of a JavaScript file. Implementations may redirect those to local files. */
      "jsLibraryURL": new n3.NamedNode("http://www.w3.org/ns/shacl#jsLibraryURL"),
      /** Outlines how human-readable labels of instances of the associated Parameterizable shall be produced. The values can contain {?paramName} as placeholders for the actual values of the given parameter. */
      "labelTemplate": new n3.NamedNode("http://www.w3.org/ns/shacl#labelTemplate"),
      /** Specifies a list of language tags that all value nodes must have. */
      "languageIn": new n3.NamedNode("http://www.w3.org/ns/shacl#languageIn"),
      /** Specifies a property that must have smaller values than the value nodes. */
      "lessThan": new n3.NamedNode("http://www.w3.org/ns/shacl#lessThan"),
      /** Specifies a property that must have smaller or equal values than the value nodes. */
      "lessThanOrEquals": new n3.NamedNode("http://www.w3.org/ns/shacl#lessThanOrEquals"),
      /** Specifies the maximum number of values in the set of value nodes. */
      "maxCount": new n3.NamedNode("http://www.w3.org/ns/shacl#maxCount"),
      /** Specifies the maximum exclusive value of each value node. */
      "maxExclusive": new n3.NamedNode("http://www.w3.org/ns/shacl#maxExclusive"),
      /** Specifies the maximum inclusive value of each value node. */
      "maxInclusive": new n3.NamedNode("http://www.w3.org/ns/shacl#maxInclusive"),
      /** Specifies the maximum string length of each value node. */
      "maxLength": new n3.NamedNode("http://www.w3.org/ns/shacl#maxLength"),
      /** A human-readable message (possibly with placeholders for variables) explaining the cause of the result. */
      "message": new n3.NamedNode("http://www.w3.org/ns/shacl#message"),
      /** Specifies the minimum number of values in the set of value nodes. */
      "minCount": new n3.NamedNode("http://www.w3.org/ns/shacl#minCount"),
      /** Specifies the minimum exclusive value of each value node. */
      "minExclusive": new n3.NamedNode("http://www.w3.org/ns/shacl#minExclusive"),
      /** Specifies the minimum inclusive value of each value node. */
      "minInclusive": new n3.NamedNode("http://www.w3.org/ns/shacl#minInclusive"),
      /** Specifies the minimum string length of each value node. */
      "minLength": new n3.NamedNode("http://www.w3.org/ns/shacl#minLength"),
      /** Human-readable labels for the property in the context of the surrounding shape. */
      "name": new n3.NamedNode("http://www.w3.org/ns/shacl#name"),
      /** The namespace associated with a prefix in a prefix declaration. */
      "namespace": new n3.NamedNode("http://www.w3.org/ns/shacl#namespace"),
      /** Specifies the node shape that all value nodes must conform to. */
      "node": new n3.NamedNode("http://www.w3.org/ns/shacl#node"),
      /** Specifies the node kind (e.g. IRI or literal) each value node. */
      "nodeKind": new n3.NamedNode("http://www.w3.org/ns/shacl#nodeKind"),
      /** The validator(s) used to evaluate a constraint in the context of a node shape. */
      "nodeValidator": new n3.NamedNode("http://www.w3.org/ns/shacl#nodeValidator"),
      /** The node expression producing the input nodes of a filter shape expression. */
      "nodes": new n3.NamedNode("http://www.w3.org/ns/shacl#nodes"),
      /** Specifies a shape that the value nodes must not conform to. */
      "not": new n3.NamedNode("http://www.w3.org/ns/shacl#not"),
      /** An expression producing the nodes that shall be inferred as objects. */
      "object": new n3.NamedNode("http://www.w3.org/ns/shacl#object"),
      /** The (single) value of this property represents a path that is matched one or more times. */
      "oneOrMorePath": new n3.NamedNode("http://www.w3.org/ns/shacl#oneOrMorePath"),
      /** Indicates whether a parameter is optional. */
      "optional": new n3.NamedNode("http://www.w3.org/ns/shacl#optional"),
      /** Specifies a list of shapes so that the value nodes must conform to at least one of the shapes. */
      "or": new n3.NamedNode("http://www.w3.org/ns/shacl#or"),
      /** Specifies the relative order of this compared to its siblings. For example use 0 for the first, 1 for the second. */
      "order": new n3.NamedNode("http://www.w3.org/ns/shacl#order"),
      /** The parameters of a function or constraint component. */
      "parameter": new n3.NamedNode("http://www.w3.org/ns/shacl#parameter"),
      /** Specifies the property path of a property shape. */
      "path": new n3.NamedNode("http://www.w3.org/ns/shacl#path"),
      /** Specifies a regular expression pattern that the string representations of the value nodes must match. */
      "pattern": new n3.NamedNode("http://www.w3.org/ns/shacl#pattern"),
      /** An expression producing the properties that shall be inferred as predicates. */
      "predicate": new n3.NamedNode("http://www.w3.org/ns/shacl#predicate"),
      /** The prefix of a prefix declaration. */
      "prefix": new n3.NamedNode("http://www.w3.org/ns/shacl#prefix"),
      /** The prefixes that shall be applied before parsing the associated SPARQL query. */
      "prefixes": new n3.NamedNode("http://www.w3.org/ns/shacl#prefixes"),
      /** Links a shape to its property shapes. */
      "property": new n3.NamedNode("http://www.w3.org/ns/shacl#property"),
      /** The validator(s) used to evaluate a constraint in the context of a property shape. */
      "propertyValidator": new n3.NamedNode("http://www.w3.org/ns/shacl#propertyValidator"),
      /** The maximum number of value nodes that can conform to the shape. */
      "qualifiedMaxCount": new n3.NamedNode("http://www.w3.org/ns/shacl#qualifiedMaxCount"),
      /** The minimum number of value nodes that must conform to the shape. */
      "qualifiedMinCount": new n3.NamedNode("http://www.w3.org/ns/shacl#qualifiedMinCount"),
      /** The shape that a specified number of values must conform to. */
      "qualifiedValueShape": new n3.NamedNode("http://www.w3.org/ns/shacl#qualifiedValueShape"),
      /** Can be used to mark the qualified value shape to be disjoint with its sibling shapes. */
      "qualifiedValueShapesDisjoint": new n3.NamedNode("http://www.w3.org/ns/shacl#qualifiedValueShapesDisjoint"),
      /** The validation results contained in a validation report. */
      "result": new n3.NamedNode("http://www.w3.org/ns/shacl#result"),
      /** Links a SPARQL validator with zero or more sh:ResultAnnotation instances, defining how to derive additional result properties based on the variables of the SELECT query. */
      "resultAnnotation": new n3.NamedNode("http://www.w3.org/ns/shacl#resultAnnotation"),
      /** Human-readable messages explaining the cause of the result. */
      "resultMessage": new n3.NamedNode("http://www.w3.org/ns/shacl#resultMessage"),
      /** The path of a validation result, based on the path of the validated property shape. */
      "resultPath": new n3.NamedNode("http://www.w3.org/ns/shacl#resultPath"),
      /** The severity of the result, e.g. warning. */
      "resultSeverity": new n3.NamedNode("http://www.w3.org/ns/shacl#resultSeverity"),
      /** The expected type of values returned by the associated function. */
      "returnType": new n3.NamedNode("http://www.w3.org/ns/shacl#returnType"),
      /** The rules linked to a shape. */
      "rule": new n3.NamedNode("http://www.w3.org/ns/shacl#rule"),
      /** The SPARQL SELECT query to execute. */
      "select": new n3.NamedNode("http://www.w3.org/ns/shacl#select"),
      /** Defines the severity that validation results produced by a shape must have. Defaults to sh:Violation. */
      "severity": new n3.NamedNode("http://www.w3.org/ns/shacl#severity"),
      /** Shapes graphs that should be used when validating this data graph. */
      "shapesGraph": new n3.NamedNode("http://www.w3.org/ns/shacl#shapesGraph"),
      /** If true then the validation engine was certain that the shapes graph has passed all SHACL syntax requirements during the validation process. */
      "shapesGraphWellFormed": new n3.NamedNode("http://www.w3.org/ns/shacl#shapesGraphWellFormed"),
      /** The constraint that was validated when the result was produced. */
      "sourceConstraint": new n3.NamedNode("http://www.w3.org/ns/shacl#sourceConstraint"),
      /** The constraint component that is the source of the result. */
      "sourceConstraintComponent": new n3.NamedNode("http://www.w3.org/ns/shacl#sourceConstraintComponent"),
      /** The shape that is was validated when the result was produced. */
      "sourceShape": new n3.NamedNode("http://www.w3.org/ns/shacl#sourceShape"),
      /** Links a shape with SPARQL constraints. */
      "sparql": new n3.NamedNode("http://www.w3.org/ns/shacl#sparql"),
      /** An expression producing the resources that shall be inferred as subjects. */
      "subject": new n3.NamedNode("http://www.w3.org/ns/shacl#subject"),
      /** Suggested shapes graphs for this ontology. The values of this property may be used in the absence of specific sh:shapesGraph statements. */
      "suggestedShapesGraph": new n3.NamedNode("http://www.w3.org/ns/shacl#suggestedShapesGraph"),
      /** Links a shape to a target specified by an extension language, for example instances of sh:SPARQLTarget. */
      "target": new n3.NamedNode("http://www.w3.org/ns/shacl#target"),
      /** Links a shape to a class, indicating that all instances of the class must conform to the shape. */
      "targetClass": new n3.NamedNode("http://www.w3.org/ns/shacl#targetClass"),
      /** Links a shape to individual nodes, indicating that these nodes must conform to the shape. */
      "targetNode": new n3.NamedNode("http://www.w3.org/ns/shacl#targetNode"),
      /** Links a shape to a property, indicating that all all objects of triples that have the given property as their predicate must conform to the shape. */
      "targetObjectsOf": new n3.NamedNode("http://www.w3.org/ns/shacl#targetObjectsOf"),
      /** Links a shape to a property, indicating that all subjects of triples that have the given property as their predicate must conform to the shape. */
      "targetSubjectsOf": new n3.NamedNode("http://www.w3.org/ns/shacl#targetSubjectsOf"),
      /** A node expression that represents the current focus node. */
      "this": new n3.NamedNode("http://www.w3.org/ns/shacl#this"),
      /** A list of node expressions that shall be used together. */
      "union": new n3.NamedNode("http://www.w3.org/ns/shacl#union"),
      /** Specifies whether all node values must have a unique (or no) language tag. */
      "uniqueLang": new n3.NamedNode("http://www.w3.org/ns/shacl#uniqueLang"),
      /** The SPARQL UPDATE to execute. */
      "update": new n3.NamedNode("http://www.w3.org/ns/shacl#update"),
      /** The validator(s) used to evaluate constraints of either node or property shapes. */
      "validator": new n3.NamedNode("http://www.w3.org/ns/shacl#validator"),
      /** An RDF node that has caused the result. */
      "value": new n3.NamedNode("http://www.w3.org/ns/shacl#value"),
      /** Specifies a list of shapes so that the value nodes must conform to exactly one of the shapes. */
      "xone": new n3.NamedNode("http://www.w3.org/ns/shacl#xone"),
      /** The (single) value of this property represents a path that is matched zero or more times. */
      "zeroOrMorePath": new n3.NamedNode("http://www.w3.org/ns/shacl#zeroOrMorePath"),
      /** The (single) value of this property represents a path that is matched zero or one times. */
      "zeroOrOnePath": new n3.NamedNode("http://www.w3.org/ns/shacl#zeroOrOnePath")
    };
  }
});

// node_modules/@faubulous/mentor-rdf/dist/ontologies/skos.js
var require_skos = __commonJS({
  "node_modules/@faubulous/mentor-rdf/dist/ontologies/skos.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skos = exports.SKOS = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var n3 = tslib_1.__importStar((init_src(), __toCommonJS(src_exports)));
    exports.SKOS = {
      "core": "http://www.w3.org/2004/02/skos/core",
      /** A meaningful collection of concepts. */
      "Collection": "http://www.w3.org/2004/02/skos/core#Collection",
      /** An idea or notion; a unit of thought. */
      "Concept": "http://www.w3.org/2004/02/skos/core#Concept",
      /** A set of concepts, optionally including statements about semantic relationships between those concepts. */
      "ConceptScheme": "http://www.w3.org/2004/02/skos/core#ConceptScheme",
      /** An ordered collection of concepts, where both the grouping and the ordering are meaningful. */
      "OrderedCollection": "http://www.w3.org/2004/02/skos/core#OrderedCollection",
      /** An alternative lexical label for a resource. */
      "altLabel": "http://www.w3.org/2004/02/skos/core#altLabel",
      /** skos:broadMatch is used to state a hierarchical mapping link between two conceptual resources in different concept schemes. */
      "broadMatch": "http://www.w3.org/2004/02/skos/core#broadMatch",
      /** Relates a concept to a concept that is more general in meaning. */
      "broader": "http://www.w3.org/2004/02/skos/core#broader",
      /** skos:broaderTransitive is a transitive superproperty of skos:broader. */
      "broaderTransitive": "http://www.w3.org/2004/02/skos/core#broaderTransitive",
      /** A note about a modification to a concept. */
      "changeNote": "http://www.w3.org/2004/02/skos/core#changeNote",
      /** skos:closeMatch is used to link two concepts that are sufficiently similar that they can be used interchangeably in some information retrieval applications. In order to avoid the possibility of "compound errors" when combining mappings across more than two concept schemes, skos:closeMatch is not declared to be a transitive property. */
      "closeMatch": "http://www.w3.org/2004/02/skos/core#closeMatch",
      /** A statement or formal explanation of the meaning of a concept. */
      "definition": "http://www.w3.org/2004/02/skos/core#definition",
      /** A note for an editor, translator or maintainer of the vocabulary. */
      "editorialNote": "http://www.w3.org/2004/02/skos/core#editorialNote",
      /** skos:exactMatch is used to link two concepts, indicating a high degree of confidence that the concepts can be used interchangeably across a wide range of information retrieval applications. skos:exactMatch is a transitive property, and is a sub-property of skos:closeMatch. */
      "exactMatch": "http://www.w3.org/2004/02/skos/core#exactMatch",
      /** An example of the use of a concept. */
      "example": "http://www.w3.org/2004/02/skos/core#example",
      /** Relates, by convention, a concept scheme to a concept which is topmost in the broader/narrower concept hierarchies for that scheme, providing an entry point to these hierarchies. */
      "hasTopConcept": "http://www.w3.org/2004/02/skos/core#hasTopConcept",
      /** A lexical label for a resource that should be hidden when generating visual displays of the resource, but should still be accessible to free text search operations. */
      "hiddenLabel": "http://www.w3.org/2004/02/skos/core#hiddenLabel",
      /** A note about the past state/use/meaning of a concept. */
      "historyNote": "http://www.w3.org/2004/02/skos/core#historyNote",
      /** Relates a resource (for example a concept) to a concept scheme in which it is included. */
      "inScheme": "http://www.w3.org/2004/02/skos/core#inScheme",
      /** Relates two concepts coming, by convention, from different schemes, and that have comparable meanings */
      "mappingRelation": "http://www.w3.org/2004/02/skos/core#mappingRelation",
      /** Relates a collection to one of its members. */
      "member": "http://www.w3.org/2004/02/skos/core#member",
      /** Relates an ordered collection to the RDF list containing its members. */
      "memberList": "http://www.w3.org/2004/02/skos/core#memberList",
      /** skos:narrowMatch is used to state a hierarchical mapping link between two conceptual resources in different concept schemes. */
      "narrowMatch": "http://www.w3.org/2004/02/skos/core#narrowMatch",
      /** Relates a concept to a concept that is more specific in meaning. */
      "narrower": "http://www.w3.org/2004/02/skos/core#narrower",
      /** skos:narrowerTransitive is a transitive superproperty of skos:narrower. */
      "narrowerTransitive": "http://www.w3.org/2004/02/skos/core#narrowerTransitive",
      /** A notation, also known as classification code, is a string of characters such as "T58.5" or "303.4833" used to uniquely identify a concept within the scope of a given concept scheme. */
      "notation": "http://www.w3.org/2004/02/skos/core#notation",
      /** A general note, for any purpose. */
      "note": "http://www.w3.org/2004/02/skos/core#note",
      /** The preferred lexical label for a resource, in a given language. */
      "prefLabel": "http://www.w3.org/2004/02/skos/core#prefLabel",
      /** Relates a concept to a concept with which there is an associative semantic relationship. */
      "related": "http://www.w3.org/2004/02/skos/core#related",
      /** skos:relatedMatch is used to state an associative mapping link between two conceptual resources in different concept schemes. */
      "relatedMatch": "http://www.w3.org/2004/02/skos/core#relatedMatch",
      /** A note that helps to clarify the meaning and/or the use of a concept. */
      "scopeNote": "http://www.w3.org/2004/02/skos/core#scopeNote",
      /** Links a concept to a concept related by meaning. */
      "semanticRelation": "http://www.w3.org/2004/02/skos/core#semanticRelation",
      /** Relates a concept to the concept scheme that it is a top level concept of. */
      "topConceptOf": "http://www.w3.org/2004/02/skos/core#topConceptOf"
    };
    exports.skos = {
      "core": new n3.NamedNode("http://www.w3.org/2004/02/skos/core"),
      /** A meaningful collection of concepts. */
      "Collection": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#Collection"),
      /** An idea or notion; a unit of thought. */
      "Concept": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#Concept"),
      /** A set of concepts, optionally including statements about semantic relationships between those concepts. */
      "ConceptScheme": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#ConceptScheme"),
      /** An ordered collection of concepts, where both the grouping and the ordering are meaningful. */
      "OrderedCollection": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#OrderedCollection"),
      /** An alternative lexical label for a resource. */
      "altLabel": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#altLabel"),
      /** skos:broadMatch is used to state a hierarchical mapping link between two conceptual resources in different concept schemes. */
      "broadMatch": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#broadMatch"),
      /** Relates a concept to a concept that is more general in meaning. */
      "broader": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#broader"),
      /** skos:broaderTransitive is a transitive superproperty of skos:broader. */
      "broaderTransitive": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#broaderTransitive"),
      /** A note about a modification to a concept. */
      "changeNote": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#changeNote"),
      /** skos:closeMatch is used to link two concepts that are sufficiently similar that they can be used interchangeably in some information retrieval applications. In order to avoid the possibility of "compound errors" when combining mappings across more than two concept schemes, skos:closeMatch is not declared to be a transitive property. */
      "closeMatch": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#closeMatch"),
      /** A statement or formal explanation of the meaning of a concept. */
      "definition": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#definition"),
      /** A note for an editor, translator or maintainer of the vocabulary. */
      "editorialNote": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#editorialNote"),
      /** skos:exactMatch is used to link two concepts, indicating a high degree of confidence that the concepts can be used interchangeably across a wide range of information retrieval applications. skos:exactMatch is a transitive property, and is a sub-property of skos:closeMatch. */
      "exactMatch": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#exactMatch"),
      /** An example of the use of a concept. */
      "example": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#example"),
      /** Relates, by convention, a concept scheme to a concept which is topmost in the broader/narrower concept hierarchies for that scheme, providing an entry point to these hierarchies. */
      "hasTopConcept": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#hasTopConcept"),
      /** A lexical label for a resource that should be hidden when generating visual displays of the resource, but should still be accessible to free text search operations. */
      "hiddenLabel": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#hiddenLabel"),
      /** A note about the past state/use/meaning of a concept. */
      "historyNote": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#historyNote"),
      /** Relates a resource (for example a concept) to a concept scheme in which it is included. */
      "inScheme": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#inScheme"),
      /** Relates two concepts coming, by convention, from different schemes, and that have comparable meanings */
      "mappingRelation": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#mappingRelation"),
      /** Relates a collection to one of its members. */
      "member": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#member"),
      /** Relates an ordered collection to the RDF list containing its members. */
      "memberList": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#memberList"),
      /** skos:narrowMatch is used to state a hierarchical mapping link between two conceptual resources in different concept schemes. */
      "narrowMatch": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#narrowMatch"),
      /** Relates a concept to a concept that is more specific in meaning. */
      "narrower": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#narrower"),
      /** skos:narrowerTransitive is a transitive superproperty of skos:narrower. */
      "narrowerTransitive": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#narrowerTransitive"),
      /** A notation, also known as classification code, is a string of characters such as "T58.5" or "303.4833" used to uniquely identify a concept within the scope of a given concept scheme. */
      "notation": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#notation"),
      /** A general note, for any purpose. */
      "note": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#note"),
      /** The preferred lexical label for a resource, in a given language. */
      "prefLabel": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#prefLabel"),
      /** Relates a concept to a concept with which there is an associative semantic relationship. */
      "related": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#related"),
      /** skos:relatedMatch is used to state an associative mapping link between two conceptual resources in different concept schemes. */
      "relatedMatch": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#relatedMatch"),
      /** A note that helps to clarify the meaning and/or the use of a concept. */
      "scopeNote": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#scopeNote"),
      /** Links a concept to a concept related by meaning. */
      "semanticRelation": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#semanticRelation"),
      /** Relates a concept to the concept scheme that it is a top level concept of. */
      "topConceptOf": new n3.NamedNode("http://www.w3.org/2004/02/skos/core#topConceptOf")
    };
  }
});

// node_modules/@faubulous/mentor-rdf/dist/ontologies/xsd.js
var require_xsd = __commonJS({
  "node_modules/@faubulous/mentor-rdf/dist/ontologies/xsd.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.xsd = exports.XSD = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var n3 = tslib_1.__importStar((init_src(), __toCommonJS(src_exports)));
    exports.XSD = {
      /** anyURI represents an Internationalized Resource Identifier Reference (IRI).  An anyURI value can be absolute or relative, and may have an optional fragment identifier (i.e., it may be an IRI Reference).  This type should be used when the value fulfills the role of an IRI, as defined in [RFC 3987] or its successor(s) in the IETF Standards Track. */
      "anyURI": "http://www.w3.org/2001/XMLSchema#anyURI",
      /** base64Binary represents arbitrary Base64-encoded binary data.  For base64Binary data the entire binary stream is encoded using the Base64 Encoding defined in [RFC 3548], which is derived from the encoding described in [RFC 2045]. */
      "base64Binary": "http://www.w3.org/2001/XMLSchema#base64Binary",
      /** boolean represents the values of two-valued logic. */
      "boolean": "http://www.w3.org/2001/XMLSchema#boolean",
      /** byte is derived from short by setting the value of maxInclusive to be 127 and minInclusive to be -128. The base type of byte is short. */
      "byte": "http://www.w3.org/2001/XMLSchema#byte",
      /** date represents top-open intervals of exactly one day in length on the timelines of dateTime, beginning on the beginning moment of each day, up to but not including the beginning moment of the next day).  For non-timezoned values, the top-open intervals disjointly cover the non-timezoned timeline, one per day.  For timezoned values, the intervals begin at every minute and therefore overlap. */
      "date": "http://www.w3.org/2001/XMLSchema#date",
      /** dateTime represents instants of time, optionally marked with a particular time zone offset.  Values representing the same instant but having different time zone offsets are equal but not identical. */
      "dateTime": "http://www.w3.org/2001/XMLSchema#dateTime",
      /** decimal represents a subset of the real numbers, which can be represented by decimal numerals. The value space of decimal is the set of numbers that can be obtained by dividing an integer by a non-negative power of ten, i.e., expressible as i / 10n where i and n are integers and n  0. Precision is not reflected in this value space; the number 2.0 is not distinct from the number 2.00. The order relation on decimal is the order relation on real numbers, restricted to this subset. */
      "decimal": "http://www.w3.org/2001/XMLSchema#decimal",
      /** The double datatype is patterned after the IEEE double-precision 64-bit floating point datatype [IEEE 754-2008].  Each floating point datatype has a value space that is a subset of the rational numbers.  Floating point numbers are often used to approximate arbitrary real numbers. */
      "double": "http://www.w3.org/2001/XMLSchema#double",
      /** duration is a datatype that represents durations of time.  The concept of duration being captured is drawn from those of [ISO 8601], specifically durations without fixed endpoints. */
      "duration": "http://www.w3.org/2001/XMLSchema#duration",
      /** The float datatype is patterned after the IEEE single-precision 32-bit floating point datatype [IEEE 754-2008].  Its value space is a subset of the rational numbers.  Floating point numbers are often used to approximate arbitrary real numbers. */
      "float": "http://www.w3.org/2001/XMLSchema#float",
      /** int is derived from long by setting the value of maxInclusive to be 2147483647 and minInclusive to be -2147483648.  The base type of int is long. */
      "int": "http://www.w3.org/2001/XMLSchema#int",
      /** integer is derived from decimal by fixing the value of fractionDigits to be 0 and disallowing the trailing decimal point.  This results in the standard mathematical concept of the integer numbers.  The value space of integer is the infinite set {...,-2,-1,0,1,2,...}.  The base type of integer is decimal. */
      "integer": "http://www.w3.org/2001/XMLSchema#integer",
      /** long is derived from integer by setting the value of maxInclusive to be 9223372036854775807 and minInclusive to be -9223372036854775808. The base type of long is integer. */
      "long": "http://www.w3.org/2001/XMLSchema#long",
      /** negativeInteger is derived from nonPositiveInteger by setting the value of maxInclusive to be -1.  This results in the standard mathematical concept of the negative integers.  The value space of negativeInteger is the infinite set {...,-2,-1}.  The base type of negativeInteger is nonPositiveInteger. */
      "negativeInteger": "http://www.w3.org/2001/XMLSchema#negativeInteger",
      "nonNegativeInteger": "http://www.w3.org/2001/XMLSchema#nonNegativeInteger",
      /** nonPositiveInteger is derived from integer by setting the value of maxInclusive to be 0.  This results in the standard mathematical concept of the non-positive integers. The value space of nonPositiveInteger is the infinite set {...,-2,-1,0}.  The base type of nonPositiveInteger is integer. */
      "nonPositiveInteger": "http://www.w3.org/2001/XMLSchema#nonPositiveInteger",
      /** nonNegativeInteger is derived from integer by setting the value of minInclusive to be 0.  This results in the standard mathematical concept of the non-negative integers. The value space of nonNegativeInteger is the infinite set {0,1,2,...}.  The base type of nonNegativeInteger is integer. */
      "positiveInteger": "http://www.w3.org/2001/XMLSchema#positiveInteger",
      /** short is derived from int by setting the value of maxInclusive to be 32767 and minInclusive to be -32768.  The base type of short is int. */
      "short": "http://www.w3.org/2001/XMLSchema#short",
      /** The string datatype represents character strings in XML. */
      "string": "http://www.w3.org/2001/XMLSchema#string",
      /** time represents instants of time that recur at the same point in each calendar day, or that occur in some arbitrary calendar day. */
      "time": "http://www.w3.org/2001/XMLSchema#time",
      /** unsignedInt is derived from unsignedLong by setting the value of maxInclusive to be 4294967295.  The base type of unsignedInt is unsignedLong. */
      "unsignedInt": "http://www.w3.org/2001/XMLSchema#unsignedInt",
      /** unsignedShort is derived from unsignedInt by setting the value of maxInclusive to be 65535.  The base type of unsignedShort is unsignedInt. */
      "unsignedShort": "http://www.w3.org/2001/XMLSchema#unsignedShort",
      /** unsignedLong is derived from nonNegativeInteger by setting the value of maxInclusive to be 18446744073709551615.  The base type of unsignedLong is nonNegativeInteger. */
      "unsingedLong": "http://www.w3.org/2001/XMLSchema#unsingedLong",
      /** unsignedByte is derived from unsignedShort by setting the value of maxInclusive to be 255.  The base type of unsignedByte is unsignedShort. */
      "usignedByte": "http://www.w3.org/2001/XMLSchema#usignedByte"
    };
    exports.xsd = {
      /** anyURI represents an Internationalized Resource Identifier Reference (IRI).  An anyURI value can be absolute or relative, and may have an optional fragment identifier (i.e., it may be an IRI Reference).  This type should be used when the value fulfills the role of an IRI, as defined in [RFC 3987] or its successor(s) in the IETF Standards Track. */
      "anyURI": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#anyURI"),
      /** base64Binary represents arbitrary Base64-encoded binary data.  For base64Binary data the entire binary stream is encoded using the Base64 Encoding defined in [RFC 3548], which is derived from the encoding described in [RFC 2045]. */
      "base64Binary": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#base64Binary"),
      /** boolean represents the values of two-valued logic. */
      "boolean": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#boolean"),
      /** byte is derived from short by setting the value of maxInclusive to be 127 and minInclusive to be -128. The base type of byte is short. */
      "byte": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#byte"),
      /** date represents top-open intervals of exactly one day in length on the timelines of dateTime, beginning on the beginning moment of each day, up to but not including the beginning moment of the next day).  For non-timezoned values, the top-open intervals disjointly cover the non-timezoned timeline, one per day.  For timezoned values, the intervals begin at every minute and therefore overlap. */
      "date": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#date"),
      /** dateTime represents instants of time, optionally marked with a particular time zone offset.  Values representing the same instant but having different time zone offsets are equal but not identical. */
      "dateTime": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#dateTime"),
      /** decimal represents a subset of the real numbers, which can be represented by decimal numerals. The value space of decimal is the set of numbers that can be obtained by dividing an integer by a non-negative power of ten, i.e., expressible as i / 10n where i and n are integers and n  0. Precision is not reflected in this value space; the number 2.0 is not distinct from the number 2.00. The order relation on decimal is the order relation on real numbers, restricted to this subset. */
      "decimal": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#decimal"),
      /** The double datatype is patterned after the IEEE double-precision 64-bit floating point datatype [IEEE 754-2008].  Each floating point datatype has a value space that is a subset of the rational numbers.  Floating point numbers are often used to approximate arbitrary real numbers. */
      "double": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#double"),
      /** duration is a datatype that represents durations of time.  The concept of duration being captured is drawn from those of [ISO 8601], specifically durations without fixed endpoints. */
      "duration": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#duration"),
      /** The float datatype is patterned after the IEEE single-precision 32-bit floating point datatype [IEEE 754-2008].  Its value space is a subset of the rational numbers.  Floating point numbers are often used to approximate arbitrary real numbers. */
      "float": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#float"),
      /** int is derived from long by setting the value of maxInclusive to be 2147483647 and minInclusive to be -2147483648.  The base type of int is long. */
      "int": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#int"),
      /** integer is derived from decimal by fixing the value of fractionDigits to be 0 and disallowing the trailing decimal point.  This results in the standard mathematical concept of the integer numbers.  The value space of integer is the infinite set {...,-2,-1,0,1,2,...}.  The base type of integer is decimal. */
      "integer": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#integer"),
      /** long is derived from integer by setting the value of maxInclusive to be 9223372036854775807 and minInclusive to be -9223372036854775808. The base type of long is integer. */
      "long": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#long"),
      /** negativeInteger is derived from nonPositiveInteger by setting the value of maxInclusive to be -1.  This results in the standard mathematical concept of the negative integers.  The value space of negativeInteger is the infinite set {...,-2,-1}.  The base type of negativeInteger is nonPositiveInteger. */
      "negativeInteger": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#negativeInteger"),
      "nonNegativeInteger": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#nonNegativeInteger"),
      /** nonPositiveInteger is derived from integer by setting the value of maxInclusive to be 0.  This results in the standard mathematical concept of the non-positive integers. The value space of nonPositiveInteger is the infinite set {...,-2,-1,0}.  The base type of nonPositiveInteger is integer. */
      "nonPositiveInteger": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#nonPositiveInteger"),
      /** nonNegativeInteger is derived from integer by setting the value of minInclusive to be 0.  This results in the standard mathematical concept of the non-negative integers. The value space of nonNegativeInteger is the infinite set {0,1,2,...}.  The base type of nonNegativeInteger is integer. */
      "positiveInteger": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#positiveInteger"),
      /** short is derived from int by setting the value of maxInclusive to be 32767 and minInclusive to be -32768.  The base type of short is int. */
      "short": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#short"),
      /** The string datatype represents character strings in XML. */
      "string": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#string"),
      /** time represents instants of time that recur at the same point in each calendar day, or that occur in some arbitrary calendar day. */
      "time": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#time"),
      /** unsignedInt is derived from unsignedLong by setting the value of maxInclusive to be 4294967295.  The base type of unsignedInt is unsignedLong. */
      "unsignedInt": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#unsignedInt"),
      /** unsignedShort is derived from unsignedInt by setting the value of maxInclusive to be 65535.  The base type of unsignedShort is unsignedInt. */
      "unsignedShort": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#unsignedShort"),
      /** unsignedLong is derived from nonNegativeInteger by setting the value of maxInclusive to be 18446744073709551615.  The base type of unsignedLong is nonNegativeInteger. */
      "unsingedLong": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#unsingedLong"),
      /** unsignedByte is derived from unsignedShort by setting the value of maxInclusive to be 255.  The base type of unsignedByte is unsignedShort. */
      "usignedByte": new n3.NamedNode("http://www.w3.org/2001/XMLSchema#usignedByte")
    };
  }
});

// node_modules/@faubulous/mentor-rdf/dist/ontologies/index.js
var require_ontologies = __commonJS({
  "node_modules/@faubulous/mentor-rdf/dist/ontologies/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_owl(), exports);
    tslib_1.__exportStar(require_rdf(), exports);
    tslib_1.__exportStar(require_rdfa(), exports);
    tslib_1.__exportStar(require_rdfs(), exports);
    tslib_1.__exportStar(require_shacl(), exports);
    tslib_1.__exportStar(require_skos(), exports);
    tslib_1.__exportStar(require_xsd(), exports);
  }
});

// node_modules/@faubulous/mentor-rdf/dist/rdf/resource-repository.js
var require_resource_repository = __commonJS({
  "node_modules/@faubulous/mentor-rdf/dist/rdf/resource-repository.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ResourceRepository = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var n3 = tslib_1.__importStar((init_src(), __toCommonJS(src_exports)));
    var ResourceRepository2 = class {
      constructor(store) {
        this.store = store;
      }
      /**
       * Indicate if a given URI exists as the subject of a triple in the graph.
       * @returns true if the URI is a subject, false otherwise.
       */
      hasSubject(uri) {
        const s = n3.DataFactory.namedNode(uri);
        for (let q of this.store.match(s)) {
          if (!q.graph.value.endsWith("inference")) {
            return true;
          }
        }
        return false;
      }
    };
    exports.ResourceRepository = ResourceRepository2;
  }
});

// node_modules/@faubulous/mentor-rdf/dist/rdf/class-repository.js
var require_class_repository = __commonJS({
  "node_modules/@faubulous/mentor-rdf/dist/rdf/class-repository.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassRepository = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var n3 = tslib_1.__importStar((init_src(), __toCommonJS(src_exports)));
    var ontologies_1 = require_ontologies();
    var resource_repository_1 = require_resource_repository();
    var ClassRepository2 = class extends resource_repository_1.ResourceRepository {
      constructor(store) {
        super(store);
      }
      /**
       * Get all classes in the repository.
       * @returns A list of all classes in the repository.
       */
      getClasses() {
        const result = /* @__PURE__ */ new Set();
        for (let q of this.store.match(null, ontologies_1.rdf.type, ontologies_1.rdfs.Class)) {
          const s = q.subject;
          if (s.termType != "NamedNode") {
            continue;
          }
          result.add(s.value);
        }
        return Array.from(result);
      }
      /**
       * Get the super classes of a given class.
       * @param subject URI of a class.
       * @returns An array of super classes of the given class, an empty array if the class has no super classes.
       */
      getSuperClasses(subject) {
        const result = [];
        const s = n3.DataFactory.namedNode(subject);
        for (let q of this.store.match(s, ontologies_1.rdfs.subClassOf, null)) {
          const o = q.object;
          if (o.termType != "NamedNode") {
            continue;
          }
          result.push(o.value);
        }
        return result;
      }
      /**
       * Recursively find the first path from a given class to a root class.
       * @param subject URI of a class.
       * @param path The current class path.
       * @param backtrack Set of URIs that have already been visited.
       * @returns The first path that is found from the given class to a root class.
       */
      _getRootClassPath(subject, path3, backtrack) {
        const superClasses = this.getSuperClasses(subject);
        for (let o of superClasses.filter((o2) => !backtrack.has(o2))) {
          return this._getRootClassPath(o, [...path3, o], backtrack);
        }
        return path3;
      }
      /**
       * Get the first discovered path from a given class to a root class.
       * @param subject URI of a class.
       * @returns A string array containing the first path that is found from the given class to a root class.
       */
      getRootClassPath(subject) {
        return this._getRootClassPath(subject, [], /* @__PURE__ */ new Set());
      }
      /**
       * Indicate if there are sub classes of a given class.
       * @param subject URI of a class.
       * @returns true if the class has sub classes, false otherwise.
       */
      hasSubClasses(subject) {
        const o = n3.DataFactory.namedNode(subject);
        for (let _q of this.store.match(null, ontologies_1.rdfs.subClassOf, o)) {
          return true;
        }
        return false;
      }
      /**
       * Get the sub classes of a given class or all root classes.
       * @param subject URI of a class or undefined to get all root classes.
       * @returns An array of sub classes of the given class, an empty array if the class has no sub classes.
       */
      getSubClasses(subject) {
        if (subject) {
          const result = /* @__PURE__ */ new Set();
          const o = n3.DataFactory.namedNode(subject);
          for (let q of this.store.match(null, ontologies_1.rdfs.subClassOf, o)) {
            const s = q.subject;
            if (s.termType != "NamedNode") {
              continue;
            }
            result.add(s.value);
          }
          return Array.from(result);
        } else {
          return this.getRootClasses();
        }
      }
      /**
       * Get all classes from the repository that have no super classes.
       * @returns An array of root classes in the repository.
       */
      getRootClasses() {
        const classes = /* @__PURE__ */ new Set();
        const subclasses = /* @__PURE__ */ new Set();
        for (let q of this.store.match(null, ontologies_1.rdf.type, ontologies_1.rdfs.Class)) {
          const s = q.subject;
          if (s.termType != "NamedNode") {
            continue;
          }
          classes.add(s.value);
        }
        for (let q of this.store.match(null, ontologies_1.rdfs.subClassOf, null)) {
          const s = q.subject;
          const o = q.object;
          if (s.termType != "NamedNode" || o.termType != "NamedNode") {
            continue;
          }
          classes.add(s.value);
          classes.add(o.value);
          subclasses.add(s.value);
        }
        return Array.from(classes).filter((c) => !subclasses.has(c));
      }
      /**
       * Indicate if there is an equivalent class of a given class.
       * @param subject URI of a class.
       * @returns true if the class has an equivalent class, false otherwise.
       */
      hasEquivalentClass(uri) {
        const s = n3.DataFactory.namedNode(uri);
        for (let _ of this.store.match(s, ontologies_1.owl.equivalentClass, null)) {
          return true;
        }
        return false;
      }
    };
    exports.ClassRepository = ClassRepository2;
  }
});

// node_modules/@faubulous/mentor-rdf/dist/rdf/property-repository.js
var require_property_repository = __commonJS({
  "node_modules/@faubulous/mentor-rdf/dist/rdf/property-repository.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PropertyRepository = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var n3 = tslib_1.__importStar((init_src(), __toCommonJS(src_exports)));
    var ontologies_1 = require_ontologies();
    var resource_repository_1 = require_resource_repository();
    var PropertyRepository3 = class extends resource_repository_1.ResourceRepository {
      constructor(store) {
        super(store);
        this.domainPredicate = ontologies_1.rdfs.domain;
        this.rangePredicate = ontologies_1.rdfs.range;
      }
      /**
       * Get all properties in the repository.
       * @returns A list of all properties in the repository.
       */
      getProperties() {
        const result = /* @__PURE__ */ new Set();
        for (let q of this.store.match(null, ontologies_1.rdf.type, ontologies_1.rdf.Property)) {
          const s = q.subject;
          if (s.termType != "NamedNode") {
            continue;
          }
          result.add(s.value);
        }
        return Array.from(result);
      }
      /**
       * Get the super properties of a given property.
       * @param subject URI of a property.
       * @returns An array of super properties of the given property, an empty array if the property has no super properties.
       */
      getSuperProperties(subject) {
        const result = [];
        const s = n3.DataFactory.namedNode(subject);
        for (let q of this.store.match(s, ontologies_1.rdfs.subPropertyOf, null)) {
          const o = q.object;
          if (o.termType != "NamedNode") {
            continue;
          }
          result.push(o.value);
        }
        return result;
      }
      /**
       * Recursively find the first path from a given property to a root property.
       * @param subject URI of a property.
       * @param path The current property path.
       * @param backtrack Set of URIs that have already been visited.
       * @returns The first path that is found from the given property to a root class.
       */
      _getRootPropertyPath(subject, path3, backtrack) {
        const superClasses = this.getSuperProperties(subject);
        for (let o of superClasses.filter((o2) => !backtrack.has(o2))) {
          return this._getRootPropertyPath(o, [...path3, o], backtrack);
        }
        return path3;
      }
      /**
       * Get the first discovered path from a given property to a root property.
       * @param subject URI of a property.
       * @returns A string array containing the first path that is found from the given property to a root property.
       */
      getRootPropertiesPath(subject) {
        return this._getRootPropertyPath(subject, [], /* @__PURE__ */ new Set());
      }
      /**
       * Indicate if there are sub properties of a given property.
       * @param subject URI of a property.
       * @returns true if the property has sub properties, false otherwise.
       */
      hasSubProperties(subject) {
        const o = n3.DataFactory.namedNode(subject);
        for (let _q of this.store.match(null, ontologies_1.rdfs.subPropertyOf, o)) {
          return true;
        }
        return false;
      }
      /**
       * Get the sub properties of a given property or all root properties.
       * @param subject URI of a property or undefined to get all root properties.
       * @returns An array of sub properties of the given property, an empty array if the property has no sub properties.
       */
      getSubProperties(subject) {
        if (subject) {
          const result = /* @__PURE__ */ new Set();
          const o = n3.DataFactory.namedNode(subject);
          for (let q of this.store.match(null, ontologies_1.rdfs.subPropertyOf, o)) {
            const s = q.subject;
            if (s.termType != "NamedNode") {
              continue;
            }
            result.add(s.value);
          }
          return Array.from(result);
        } else {
          return this.getRootProperties();
        }
      }
      /**
       * Get all properties from the repository that have no super properties.
       * @returns An array of root properties in the repository.
       */
      getRootProperties() {
        const properties = /* @__PURE__ */ new Set();
        const subproperties = /* @__PURE__ */ new Set();
        for (let q of this.store.match(null, ontologies_1.rdf.type, ontologies_1.rdf.Property)) {
          const s = q.subject;
          if (s.termType != "NamedNode") {
            continue;
          }
          properties.add(s.value);
        }
        for (let q of this.store.match(null, ontologies_1.rdfs.subPropertyOf, null)) {
          const s = q.subject;
          const o = q.object;
          if (s.termType != "NamedNode" || o.termType != "NamedNode") {
            continue;
          }
          properties.add(s.value);
          properties.add(o.value);
          subproperties.add(s.value);
        }
        return Array.from(properties).filter((c) => !subproperties.has(c));
      }
      /**
       * Indicate if there is an equivalent property of a given property.
       * @param subject URI of a property.
       * @returns true if the property has an equivalent property, false otherwise.
       */
      hasEquivalentProperty(uri) {
        const s = n3.DataFactory.namedNode(uri);
        for (let _ of this.store.match(s, ontologies_1.owl.equivalentProperty, null)) {
          return true;
        }
        return false;
      }
      /**
       * Get the domain of a given property.
       * @param uri URI of a property.
       * @returns The URI of the domain of the given property. If no domain is specified, rdfs:Resource is returned.
       */
      getDomain(uri) {
        const s = n3.DataFactory.namedNode(uri);
        for (let q of this.store.match(s, this.domainPredicate, null)) {
          return q.object.value;
        }
        return ontologies_1.rdfs.Resource.value;
      }
      /**
       * Get the range of a given property.
       * @param uri URI of a property.
       * @returns The URI of the range of the given property. If no range is specified, rdfs:Resource is returned.
       */
      getRange(uri) {
        const s = n3.DataFactory.namedNode(uri);
        for (let q of this.store.match(s, this.rangePredicate, null)) {
          return q.object.value;
        }
        return ontologies_1.rdfs.Resource.value;
      }
    };
    exports.PropertyRepository = PropertyRepository3;
  }
});

// node_modules/@faubulous/mentor-rdf/dist/rdf/individual-repository.js
var require_individual_repository = __commonJS({
  "node_modules/@faubulous/mentor-rdf/dist/rdf/individual-repository.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndividualRepository = void 0;
    var ontologies_1 = require_ontologies();
    var resource_repository_1 = require_resource_repository();
    var IndividualRepository2 = class extends resource_repository_1.ResourceRepository {
      constructor(store) {
        super(store);
      }
      /**
       * Get all individuals in the repository.
       * @returns A list of all individuals in the repository.
       */
      getIndividuals() {
        const result = /* @__PURE__ */ new Set();
        for (let q of this.store.match(null, ontologies_1.rdf.type, ontologies_1.owl.NamedIndividual)) {
          const s = q.subject;
          if (s.termType != "NamedNode") {
            continue;
          }
          result.add(s.value);
        }
        return Array.from(result);
      }
    };
    exports.IndividualRepository = IndividualRepository2;
  }
});

// node_modules/@faubulous/mentor-rdf/dist/rdf/rdfs-reasoner.js
var require_rdfs_reasoner = __commonJS({
  "node_modules/@faubulous/mentor-rdf/dist/rdf/rdfs-reasoner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RdfsReasoner = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var n3 = tslib_1.__importStar((init_src(), __toCommonJS(src_exports)));
    var ontologies_1 = require_ontologies();
    var RdfsReasoner = class {
      expand(store, sourceGraph, targetGraph) {
        let s = this.getGraphNode(sourceGraph);
        let t = this.getGraphNode(targetGraph);
        const lists = store.extractLists();
        for (let q of store.match(null, null, null, s)) {
          this.inferClassAxioms(store, t, lists, q);
          this.inferPropertyAxioms(store, t, lists, q);
          this.inferNamedIndividualAxioms(store, t, lists, q);
        }
        return store;
      }
      getGraphNode(graph) {
        if (typeof graph == "string") {
          return new n3.NamedNode(graph);
        } else {
          return graph;
        }
      }
      inferClassAxioms(store, graph, lists, quad2) {
        let s = quad2.subject;
        let p = quad2.predicate;
        let o = quad2.object.termType != "Literal" ? quad2.object : void 0;
        if (!o) {
          return;
        }
        switch (p.id) {
          case ontologies_1.rdf.type.id: {
            if (o.equals(ontologies_1.owl.Class)) {
              store.addQuad(s, ontologies_1.rdf.type, ontologies_1.rdfs.Class, graph);
            } else if (!o.value.startsWith("http://www.w3.org")) {
              store.addQuad(o, ontologies_1.rdf.type, ontologies_1.rdfs.Class, graph);
            }
            break;
          }
          case ontologies_1.rdfs.subClassOf.id: {
            store.addQuad(s, ontologies_1.rdf.type, ontologies_1.rdfs.Class, graph);
            if (!o.value.startsWith("http://www.w3.org")) {
              store.addQuad(o, ontologies_1.rdf.type, ontologies_1.rdfs.Class, graph);
            } else if (o.equals(ontologies_1.rdfs.Resource)) {
              store.addQuad(ontologies_1.rdfs.Resource, ontologies_1.rdf.type, ontologies_1.rdfs.Class, graph);
            } else if (o.equals(ontologies_1.rdfs.Class)) {
              store.addQuad(ontologies_1.rdfs.Class, ontologies_1.rdf.type, ontologies_1.rdfs.Class, graph);
              store.addQuad(ontologies_1.rdfs.Class, ontologies_1.rdfs.subClassOf, ontologies_1.rdfs.Resource, graph);
            } else if (o.equals(ontologies_1.rdfs.Datatype)) {
              store.addQuad(ontologies_1.rdfs.Datatype, ontologies_1.rdf.type, ontologies_1.rdfs.Class, graph);
              store.addQuad(ontologies_1.rdfs.Datatype, ontologies_1.rdfs.subClassOf, ontologies_1.rdfs.Class, graph);
            } else if (o.equals(ontologies_1.owl.Class)) {
              store.addQuad(ontologies_1.owl.Class, ontologies_1.rdf.type, ontologies_1.rdfs.Class, graph);
              store.addQuad(ontologies_1.owl.Class, ontologies_1.rdfs.subClassOf, ontologies_1.rdfs.Class, graph);
            }
            break;
          }
          case ontologies_1.rdfs.range.id:
          case ontologies_1.rdfs.domain.id: {
            if (!o.value.startsWith("http://www.w3.org")) {
              store.addQuad(o, ontologies_1.rdf.type, ontologies_1.rdfs.Class, graph);
            }
            break;
          }
        }
      }
      inferPropertyAxioms(store, targetGraph, lists, quad2) {
        let s = quad2.subject;
        let p = quad2.predicate;
        let o = quad2.object.termType != "Literal" ? quad2.object : void 0;
        if (!o) {
          return;
        }
        switch (p.id) {
          case ontologies_1.rdfs.range.id:
          case ontologies_1.rdfs.domain.id: {
            store.addQuad(s, ontologies_1.rdf.type, ontologies_1.rdf.Property, targetGraph);
            break;
          }
        }
      }
      inferNamedIndividualAxioms(store, targetGraph, lists, quad2) {
        let s = quad2.subject;
        let p = quad2.predicate;
        let o = quad2.object.termType != "Literal" ? quad2.object : void 0;
        if (!o || o.equals(ontologies_1.rdfs.Class) || o.equals(ontologies_1.owl.Class)) {
          return;
        }
        switch (p.id) {
          case ontologies_1.rdf.type.id: {
            for (let q of store.match(o, ontologies_1.rdf.type, ontologies_1.rdfs.Class)) {
              store.addQuad(s, ontologies_1.rdf.type, ontologies_1.owl.NamedIndividual, targetGraph);
              break;
            }
          }
        }
      }
    };
    exports.RdfsReasoner = RdfsReasoner;
  }
});

// node_modules/@faubulous/mentor-rdf/dist/rdf/owl-reasoner.js
var require_owl_reasoner = __commonJS({
  "node_modules/@faubulous/mentor-rdf/dist/rdf/owl-reasoner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OwlReasoner = void 0;
    var ontologies_1 = require_ontologies();
    var rdfs_reasoner_1 = require_rdfs_reasoner();
    var OwlReasoner2 = class extends rdfs_reasoner_1.RdfsReasoner {
      inferClassAxioms(store, targetGraph, lists, quad2) {
        super.inferClassAxioms(store, targetGraph, lists, quad2);
        let s = quad2.subject;
        let p = quad2.predicate;
        let o = quad2.object.termType != "Literal" ? quad2.object : void 0;
        if (!o) {
          return;
        }
        switch (p.id) {
          case ontologies_1.owl.equivalentClass.id:
          case ontologies_1.owl.complementOf.id:
          case ontologies_1.owl.disjointWith.id: {
            store.addQuad(s, ontologies_1.rdf.type, ontologies_1.rdfs.Class, targetGraph);
            if (o && !o.value.startsWith("http://www.w3.org")) {
              store.addQuad(o, ontologies_1.rdf.type, ontologies_1.rdfs.Class, targetGraph);
            }
            if (o.termType == "NamedNode") {
              store.addQuad(o, ontologies_1.owl.equivalentClass, s, targetGraph);
            }
            break;
          }
          case ontologies_1.owl.intersectionOf.id: {
            let equivalentSubjects = [...store.match(null, ontologies_1.owl.equivalentClass, s)].map((q) => q.subject).filter((q) => q.termType == "NamedNode");
            for (let c of lists[o.value]) {
              if (c.termType != "NamedNode") {
                continue;
              }
              store.addQuad(s, ontologies_1.rdfs.subClassOf, c, targetGraph);
              for (let es of equivalentSubjects) {
                store.addQuad(es, ontologies_1.rdfs.subClassOf, c, targetGraph);
              }
            }
            break;
          }
          case ontologies_1.owl.unionOf.id: {
            let equivalentSubjects = [...store.match(null, ontologies_1.owl.equivalentClass, s)].map((q) => q.subject).filter((q) => q.termType == "NamedNode");
            for (let c of lists[o.value]) {
              if (c.termType != "NamedNode") {
                continue;
              }
              store.addQuad(c, ontologies_1.rdfs.subClassOf, s, targetGraph);
              for (let es of equivalentSubjects) {
                store.addQuad(c, ontologies_1.rdfs.subClassOf, es, targetGraph);
              }
            }
            break;
          }
        }
      }
      inferPropertyAxioms(store, targetGraph, lists, quad2) {
        super.inferPropertyAxioms(store, targetGraph, lists, quad2);
        let s = quad2.subject;
        let p = quad2.predicate;
        let o = quad2.object.termType != "Literal" ? quad2.object : void 0;
        if (!o) {
          return;
        }
        switch (p.id) {
          case ontologies_1.owl.equivalentProperty.id: {
            store.addQuad(s, ontologies_1.rdf.type, ontologies_1.rdf.Property, targetGraph);
            store.addQuad(o, ontologies_1.rdf.type, ontologies_1.rdf.Property, targetGraph);
            if (o.termType == "NamedNode") {
              store.addQuad(o, ontologies_1.owl.equivalentProperty, s, targetGraph);
            }
            break;
          }
          case ontologies_1.rdf.type.id: {
            switch (o.id) {
              case ontologies_1.owl.AnnotationProperty.id:
              case ontologies_1.owl.AsymmetricProperty.id:
              case ontologies_1.owl.DatatypeProperty.id:
              case ontologies_1.owl.DeprecatedProperty.id:
              case ontologies_1.owl.FunctionalProperty.id:
              case ontologies_1.owl.InverseFunctionalProperty.id:
              case ontologies_1.owl.IrreflexiveProperty.id:
              case ontologies_1.owl.ObjectProperty.id:
              case ontologies_1.owl.OntologyProperty.id:
              case ontologies_1.owl.ReflexiveProperty.id:
              case ontologies_1.owl.SymmetricProperty.id:
              case ontologies_1.owl.TransitiveProperty.id: {
                store.addQuad(s, ontologies_1.rdf.type, ontologies_1.rdf.Property, targetGraph);
                break;
              }
            }
            break;
          }
        }
      }
    };
    exports.OwlReasoner = OwlReasoner2;
  }
});

// node_modules/@faubulous/mentor-rdf/dist/rdf/store-factory.js
var require_store_factory = __commonJS({
  "node_modules/@faubulous/mentor-rdf/dist/rdf/store-factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StoreFactory = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var fs = tslib_1.__importStar(require("fs"));
    var n3 = tslib_1.__importStar((init_src(), __toCommonJS(src_exports)));
    var StoreFactory2 = class {
      /**
       * Create an RDF store from a file.
       * @param path Path to a file containing RDF triples in Turtle or N3 format.
       * @param inference Indicates if OWL inference should be performed on the store.
       * @returns A promise that resolves to an RDF store.
       */
      static createFromFile(path3, parseOptions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const graphUri = "file://" + process.cwd() + "/src/rdf/test/gist.ttl";
          const stream = fs.createReadStream(path3);
          return this.createFromStream(stream, graphUri, parseOptions);
        });
      }
      /**
       * Create an RDF store from a file.
       * @param input Input data or stream in Turtle format to be parsed.
       * @param graphUri URI of the graph to in which the triples will be created.
       * @param parseCallback Callback function that will be called for each parsed triple.
       * @returns A promise that resolves to an RDF store.
       */
      static createFromStream(input, graphUri, parseOptions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            const graph = new n3.NamedNode(graphUri);
            const store = new n3.Store();
            new n3.Parser({}).parse(input, (error, quad2, done) => {
              if (quad2) {
                store.add(new n3.Quad(quad2.subject, quad2.predicate, quad2.object, graph));
                if (parseOptions === null || parseOptions === void 0 ? void 0 : parseOptions.onQuad) {
                  parseOptions.onQuad(quad2);
                }
              } else if (error) {
                reject(error);
              } else if (done) {
                if (parseOptions === null || parseOptions === void 0 ? void 0 : parseOptions.reasoner) {
                  const g = graphUri + "#inference";
                  parseOptions.reasoner.expand(store, graphUri, g);
                }
                resolve(store);
              }
            });
          });
        });
      }
    };
    exports.StoreFactory = StoreFactory2;
  }
});

// node_modules/@faubulous/mentor-rdf/dist/rdf/vocabulary-generator.js
var require_vocabulary_generator = __commonJS({
  "node_modules/@faubulous/mentor-rdf/dist/rdf/vocabulary-generator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VocabularyGenerator = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var fs = tslib_1.__importStar(require("fs"));
    var n3 = tslib_1.__importStar((init_src(), __toCommonJS(src_exports)));
    var path_1 = require("path");
    var ontologies_1 = require_ontologies();
    var VocabularyGenerator = class {
      constructor() {
        this._supportedExtensions = /* @__PURE__ */ new Set([
          ".ttl",
          ".trig",
          ".n3",
          ".nt",
          ".nq"
        ]);
        this._descriptionPredicates = /* @__PURE__ */ new Set([
          ontologies_1.RDFS.comment,
          ontologies_1.SKOS.definition
        ]);
      }
      /**
       * Get the subject of a quad as a named node.
       * @param quad A quad.
       * @returns A named node if the given quad describes a subject, otherwise undefined.
       */
      _getNamedSubject(quad2) {
        if (quad2.subject.termType == "NamedNode") {
          return quad2.subject.value;
        } else {
          return void 0;
        }
      }
      /**
       * Get the description of a subject from a quad, if any.
       * @param quad A quad.
       * @returns A literal if the given quad describes a subject, otherwise undefined.
       */
      _getDescription(quad2) {
        if (this._descriptionPredicates.has(quad2.predicate.value)) {
          return quad2.object;
        }
      }
      /**
       * Parse the label of a URI.
       * @param subject A URI.
       * @returns The label of the URI.
       */
      _getLabel(subject) {
        let n = subject.lastIndexOf("#");
        if (n > 0) {
          return subject.slice(n + 1);
        }
        n = subject.lastIndexOf("/");
        if (n > 0) {
          return subject.slice(n + 1);
        } else {
          return void 0;
        }
      }
      /**
       * Write a vocabulary to a TypeScript file given a function for serializing the URI of a subject.
       * @param stream A writable stream to the target file.
       * @param prefix Namespace prefix of the vocabulary.
       * @param subjects URIs of the subjects to serialize.
       * @param value A function that serializes a URI.
       */
      _writeVocabulary(stream, prefix2, subjects, value) {
        stream.write(`export const ${prefix2} = {`);
        for (var s of Object.keys(subjects).filter((s2) => s2).sort()) {
          var definitions = subjects[s];
          var comment = definitions.find((l) => l.language == "en");
          if (!comment) {
            comment = definitions.find((l) => !l.language);
          }
          var label = this._getLabel(s);
          if (!label) {
            continue;
          }
          if (comment) {
            stream.write(`
	/** ${comment.value} */`);
          }
          stream.write(`
	'${label}': ${value(s)},`);
        }
        stream.write(`
}`);
      }
      /**
       * Serialize a vocabulary to a TypeScript file.
       * @param stream A writable stream to the target file.
       * @param prefix Namespace prefix of the vocabulary.
       * @param subjects URIs of the subjects to serialize.
       */
      _serialize(stream, prefix2, subjects) {
        stream.write(`import * as n3 from "n3";

`);
        this._writeVocabulary(stream, prefix2.toUpperCase(), subjects, (s) => `'${s}'`);
        stream.write(`

`);
        this._writeVocabulary(stream, prefix2.toLowerCase(), subjects, (s) => `new n3.NamedNode('${s}')`);
        stream.on("end", () => {
          stream.end();
        });
      }
      /**
       * Create an index.ts file for the given modules.
       * @param path Directory of the index.ts file.
       * @param modules Array of modules to export.
       */
      _serializeIndex(path3, modules) {
        const stream = fs.createWriteStream((0, path_1.join)(path3, "index.ts"));
        for (let m of modules.map((x) => (0, path_1.basename)(x))) {
          stream.write(`export * from './${(0, path_1.parse)(m).name}';
`);
        }
        stream.on("end", () => {
          stream.end();
        });
      }
      /**
       * Parse a single RDF file and generate a TypeScript vocabulary file.
       * @param path Path of the RDF file to parse.
       * @returns Path of the generated TypeScript file.
       */
      parseFile(path3) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            const directory = (0, path_1.dirname)(path3);
            const prefix2 = (0, path_1.parse)(path3).name;
            const result = (0, path_1.join)(directory, prefix2 + ".ts");
            const inputStream = fs.createReadStream(path3);
            const outputStream = fs.createWriteStream(result);
            const subjects = {};
            new n3.Parser().parse(inputStream, (error, quad2, done) => {
              if (quad2) {
                const s = this._getNamedSubject(quad2);
                if (s) {
                  if (!subjects[s]) {
                    subjects[s] = [];
                  }
                  const o = this._getDescription(quad2);
                  if (o) {
                    subjects[s].push(o);
                  }
                }
              } else if (error) {
                reject(error);
              } else if (done) {
                this._serialize(outputStream, prefix2, subjects);
                resolve(result);
              }
            });
          });
        });
      }
      /**
       * Generate TypeScript vocabulary files for all RDF files in the given directory.
       * @param path Path of the directory to parse.
       * @param createIndex Indicate if an index.ts file should be created.
       * @returns An array of paths to the generated files.
       */
      parseDirectory(path3, createIndex = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const result = [];
          for (let file of fs.readdirSync(path3)) {
            const ext = (0, path_1.extname)(file);
            if (this._supportedExtensions.has(ext)) {
              const f = yield this.parseFile((0, path_1.join)(path3, file));
              result.push(f);
            }
          }
          ;
          if (createIndex) {
            this._serializeIndex(path3, result);
          }
          return result;
        });
      }
    };
    exports.VocabularyGenerator = VocabularyGenerator;
  }
});

// node_modules/@faubulous/mentor-rdf/dist/rdf/index.js
var require_rdf2 = __commonJS({
  "node_modules/@faubulous/mentor-rdf/dist/rdf/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_resource_repository(), exports);
    tslib_1.__exportStar(require_class_repository(), exports);
    tslib_1.__exportStar(require_property_repository(), exports);
    tslib_1.__exportStar(require_individual_repository(), exports);
    tslib_1.__exportStar(require_owl_reasoner(), exports);
    tslib_1.__exportStar(require_rdfs_reasoner(), exports);
    tslib_1.__exportStar(require_store_factory(), exports);
    tslib_1.__exportStar(require_vocabulary_generator(), exports);
  }
});

// node_modules/@faubulous/mentor-rdf/dist/index.js
var require_dist = __commonJS({
  "node_modules/@faubulous/mentor-rdf/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_ontologies(), exports);
    tslib_1.__exportStar(require_rdf2(), exports);
  }
});

// node_modules/vscode-languageclient/lib/common/utils/is.js
var require_is = __commonJS({
  "node_modules/vscode-languageclient/lib/common/utils/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.asPromise = exports.thenable = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports.typedArray = typedArray;
    function thenable(value) {
      return value && func(value.then);
    }
    exports.thenable = thenable;
    function asPromise(value) {
      if (value instanceof Promise) {
        return value;
      } else if (thenable(value)) {
        return new Promise((resolve, reject) => {
          value.then((resolved) => resolve(resolved), (error2) => reject(error2));
        });
      } else {
        return Promise.resolve(value);
      }
    }
    exports.asPromise = asPromise;
  }
});

// node_modules/vscode-jsonrpc/lib/common/is.js
var require_is2 = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports.stringArray = stringArray;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
    var is = require_is2();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.PendingResponseRejected = -32097;
      ErrorCodes2.ConnectionInactive = -32096;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = -32e3;
    })(ErrorCodes || (exports.ErrorCodes = ErrorCodes = {}));
    var ResponseError = class extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    };
    exports.ResponseError = ResponseError;
    var ParameterStructures = class {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports.RequestType0 = RequestType0;
    var RequestType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.RequestType = RequestType;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.RequestType1 = RequestType1;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports.RequestType2 = RequestType2;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports.NotificationType9 = NotificationType9;
    var Message;
    (function(Message2) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
      }
      Message2.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
      }
      Message2.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
      }
      Message2.isResponse = isResponse;
    })(Message || (exports.Message = Message = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch || (exports.Touch = Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[_a] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        return this._head?.value;
      }
      get last() {
        return this._tail?.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports.LinkedMap = LinkedMap;
    var LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports.LRUCache = LRUCache;
  }
});

// node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Disposable = void 0;
    var Disposable2;
    (function(Disposable3) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable3.create = create;
    })(Disposable2 || (exports.Disposable = Disposable2 = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/ral.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports.default = RAL;
  }
});

// node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Emitter = exports.Event = void 0;
    var ral_1 = require_ral();
    var Event;
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event || (exports.Event = Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class {
      constructor(_options) {
        this._options = _options;
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports.Emitter = Emitter;
    Emitter._noop = function() {
    };
  }
});

// node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CancellationTokenSource = exports.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken || (exports.CancellationToken = CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports.CancellationTokenSource = CancellationTokenSource;
  }
});

// node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
var require_sharedArrayCancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = void 0;
    var cancellation_1 = require_cancellation();
    var CancellationState;
    (function(CancellationState2) {
      CancellationState2.Continue = 0;
      CancellationState2.Cancelled = 1;
    })(CancellationState || (CancellationState = {}));
    var SharedArraySenderStrategy = class {
      constructor() {
        this.buffers = /* @__PURE__ */ new Map();
      }
      enableCancellation(request) {
        if (request.id === null) {
          return;
        }
        const buffer = new SharedArrayBuffer(4);
        const data = new Int32Array(buffer, 0, 1);
        data[0] = CancellationState.Continue;
        this.buffers.set(request.id, buffer);
        request.$cancellationData = buffer;
      }
      async sendCancellation(_conn, id) {
        const buffer = this.buffers.get(id);
        if (buffer === void 0) {
          return;
        }
        const data = new Int32Array(buffer, 0, 1);
        Atomics.store(data, 0, CancellationState.Cancelled);
      }
      cleanup(id) {
        this.buffers.delete(id);
      }
      dispose() {
        this.buffers.clear();
      }
    };
    exports.SharedArraySenderStrategy = SharedArraySenderStrategy;
    var SharedArrayBufferCancellationToken = class {
      constructor(buffer) {
        this.data = new Int32Array(buffer, 0, 1);
      }
      get isCancellationRequested() {
        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
      }
      get onCancellationRequested() {
        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
      }
    };
    var SharedArrayBufferCancellationTokenSource = class {
      constructor(buffer) {
        this.token = new SharedArrayBufferCancellationToken(buffer);
      }
      cancel() {
      }
      dispose() {
      }
    };
    var SharedArrayReceiverStrategy = class {
      constructor() {
        this.kind = "request";
      }
      createCancellationTokenSource(request) {
        const buffer = request.$cancellationData;
        if (buffer === void 0) {
          return new cancellation_1.CancellationTokenSource();
        }
        return new SharedArrayBufferCancellationTokenSource(buffer);
      }
    };
    exports.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
  }
});

// node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve, reject) => {
          this._waiting.push({ thunk, resolve, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports.Semaphore = Semaphore;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var semaphore_1 = require_semaphore();
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader || (exports.MessageReader = MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options ?? "utf-8";
        } else {
          charset = options.charset ?? "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        try {
          this.buffer.append(data);
          while (true) {
            if (this.nextMessageLength === -1) {
              const headers = this.buffer.tryReadHeaders(true);
              if (!headers) {
                return;
              }
              const contentLength = headers.get("content-length");
              if (!contentLength) {
                this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                return;
              }
              const length = parseInt(contentLength);
              if (isNaN(length)) {
                this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                return;
              }
              this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === void 0) {
              this.setPartialMessageTimer();
              return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.readSemaphore.lock(async () => {
              const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
              const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
              this.callback(message);
            }).catch((error) => {
              this.fireError(error);
            });
          }
        } catch (error) {
          this.fireError(error);
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter || (exports.MessageWriter = MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        if (options === void 0 || typeof options === "string") {
          return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders(lowerCaseKeys = false) {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row:
          while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column:
              while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                  case CR:
                    switch (state) {
                      case 0:
                        state = 1;
                        break;
                      case 2:
                        state = 3;
                        break;
                      default:
                        state = 0;
                    }
                    break;
                  case LF:
                    switch (state) {
                      case 1:
                        state = 2;
                        break;
                      case 3:
                        state = 4;
                        offset++;
                        break row;
                      default:
                        state = 0;
                    }
                    break;
                  default:
                    state = 0;
                }
                offset++;
              }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
          }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error(`Message header must separate key and value using ':'
${header}`);
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken;
    (function(ProgressToken2) {
      function is(value) {
        return typeof value === "string" || typeof value === "number";
      }
      ProgressToken2.is = is;
    })(ProgressToken || (exports.ProgressToken = ProgressToken = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Compact"] = 2] = "Compact";
      Trace2[Trace2["Verbose"] = 3] = "Verbose";
    })(Trace || (exports.Trace = Trace = {}));
    var TraceValues;
    (function(TraceValues2) {
      TraceValues2.Off = "off";
      TraceValues2.Messages = "messages";
      TraceValues2.Compact = "compact";
      TraceValues2.Verbose = "verbose";
    })(TraceValues || (exports.TraceValues = TraceValues = {}));
    (function(Trace2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return Trace2.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "compact":
            return Trace2.Compact;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Compact:
            return "compact";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString;
    })(Trace || (exports.Trace = Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return TraceFormat2.Text;
        }
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification || (exports.SetTraceNotification = SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification || (exports.LogTraceNotification = LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors || (exports.ConnectionErrors = ConnectionErrors = {}));
    var ConnectionError = class extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
      }
    };
    exports.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy || (exports.ConnectionStrategy = ConnectionStrategy = {}));
    var IdCancellationReceiverStrategy;
    (function(IdCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      IdCancellationReceiverStrategy2.is = is;
    })(IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
    var RequestCancellationReceiverStrategy;
    (function(RequestCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && candidate.kind === "request" && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      RequestCancellationReceiverStrategy2.is = is;
    })(RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy || (exports.CancellationSenderStrategy = CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy || (exports.CancellationStrategy = CancellationStrategy = {}));
    var MessageStrategy;
    (function(MessageStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.handleMessage);
      }
      MessageStrategy2.is = is;
    })(MessageStrategy || (exports.MessageStrategy = MessageStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions || (exports.ConnectionOptions = ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger, options) {
      const logger = _logger !== void 0 ? _logger : exports.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ new Map();
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ new Map();
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ new Map();
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ new Map();
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.Message.isResponse(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function handleMessage(message) {
        if (messages_1.Message.isRequest(message)) {
          handleRequest(message);
        } else if (messages_1.Message.isNotification(message)) {
          handleNotification(message);
        } else if (messages_1.Message.isResponse(message)) {
          handleResponse(message);
        } else {
          handleInvalidMessage(message);
        }
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          const messageStrategy = options?.messageStrategy;
          if (MessageStrategy.is(messageStrategy)) {
            messageStrategy.handleMessage(message, handleMessage);
          } else {
            handleMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options?.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                requestTokens.delete(cancelId);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const cancellationToken = requestTokens.get(cancelId);
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = requestMessage.id ?? String(Date.now());
          const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          if (requestMessage.id !== null) {
            requestTokens.set(tokenKey, cancellationSource);
          }
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              requestTokens.delete(tokenKey);
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                requestTokens.delete(tokenKey);
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              requestTokens.delete(tokenKey);
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            requestTokens.delete(tokenKey);
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = responseMessage.id;
          const responsePromise = responsePromises.get(key);
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise !== void 0) {
            responsePromises.delete(key);
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message);
          return;
        } else {
          const element = notificationHandlers.get(message.method);
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                const params = message.params;
                if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type !== void 0) {
                    if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                    }
                    if (type.numberOfParams !== message.params.length) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
          const key = responseMessage.id;
          const responseHandler = responsePromises.get(key);
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace) {
          case Trace.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter.write(notificationMessage).catch((error) => {
            logger.error(`Sending notification failed.`);
            throw error;
          });
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is.string(type)) {
              method = type;
              notificationHandlers.set(type, { type: void 0, handler });
            } else {
              method = type.method;
              notificationHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                notificationHandlers.delete(method);
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          return connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection, id);
              if (p === void 0) {
                logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger.log(`Sending cancellation messages for id ${id} failed`);
                });
              }
            });
          }
          const requestMessage = {
            jsonrpc: version,
            id,
            method,
            params: messageParams
          };
          traceSendingRequest(requestMessage);
          if (typeof cancellationStrategy.sender.enableCancellation === "function") {
            cancellationStrategy.sender.enableCancellation(requestMessage);
          }
          return new Promise(async (resolve, reject) => {
            const resolveWithCleanup = (r) => {
              resolve(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            try {
              await messageWriter.write(requestMessage);
              responsePromises.set(id, responsePromise);
            } catch (error) {
              logger.error(`Sending request failed.`);
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
              throw error;
            }
          });
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers.set(type, { handler, type: void 0 });
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                requestHandlers.delete(method);
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        hasPendingResponse: () => {
          return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (const promise of responsePromises.values()) {
            promise.reject(error);
          }
          responsePromises = /* @__PURE__ */ new Map();
          requestTokens = /* @__PURE__ */ new Map();
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection;
    }
    exports.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/api.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.AbstractMessageBuffer = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;
    exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports, "Message", { enumerable: true, get: function() {
      return messages_1.Message;
    } });
    Object.defineProperty(exports, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var linkedMap_1 = require_linkedMap();
    Object.defineProperty(exports, "LinkedMap", { enumerable: true, get: function() {
      return linkedMap_1.LinkedMap;
    } });
    Object.defineProperty(exports, "LRUCache", { enumerable: true, get: function() {
      return linkedMap_1.LRUCache;
    } });
    Object.defineProperty(exports, "Touch", { enumerable: true, get: function() {
      return linkedMap_1.Touch;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var sharedArrayCancellation_1 = require_sharedArrayCancellation();
    Object.defineProperty(exports, "SharedArraySenderStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArraySenderStrategy;
    } });
    Object.defineProperty(exports, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var messageBuffer_1 = require_messageBuffer();
    Object.defineProperty(exports, "AbstractMessageBuffer", { enumerable: true, get: function() {
      return messageBuffer_1.AbstractMessageBuffer;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports, "ProgressToken", { enumerable: true, get: function() {
      return connection_1.ProgressToken;
    } });
    Object.defineProperty(exports, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports, "TraceValues", { enumerable: true, get: function() {
      return connection_1.TraceValues;
    } });
    Object.defineProperty(exports, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    Object.defineProperty(exports, "MessageStrategy", { enumerable: true, get: function() {
      return connection_1.MessageStrategy;
    } });
    var ral_1 = require_ral();
    exports.RAL = ral_1.default;
  }
});

// node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/ril.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require("util");
    var api_1 = require_api();
    var MessageBuffer = class extends api_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding) {
        return Buffer.from(value, encoding);
      }
      toString(value, encoding) {
        if (value instanceof Buffer) {
          return value.toString(encoding);
        } else {
          return new util_1.TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return api_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve, reject) => {
          const callback = (error) => {
            if (error === void 0 || error === null) {
              resolve();
            } else {
              reject(error);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          const handle = setTimeout(callback, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
          const handle = setImmediate(callback, ...args);
          return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
          const handle = setInterval(callback, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        api_1.RAL.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports.default = RIL;
  }
});

// node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/main.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding2(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.PortMessageWriter = exports.PortMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var path3 = require("path");
    var os = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    var api_1 = require_api();
    __exportStar2(require_api(), exports);
    var IPCMessageReader = class extends api_1.AbstractMessageReader {
      constructor(process2) {
        super();
        this.process = process2;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports.IPCMessageReader = IPCMessageReader;
    var IPCMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(process2) {
        super();
        this.process = process2;
        this.errorCount = 0;
        const eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error) => {
              if (error) {
                this.errorCount++;
                this.handleError(error, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports.IPCMessageWriter = IPCMessageWriter;
    var PortMessageReader = class extends api_1.AbstractMessageReader {
      constructor(port) {
        super();
        this.onData = new api_1.Emitter();
        port.on("close", () => this.fireClose);
        port.on("error", (error) => this.fireError(error));
        port.on("message", (message) => {
          this.onData.fire(message);
        });
      }
      listen(callback) {
        return this.onData.event(callback);
      }
    };
    exports.PortMessageReader = PortMessageReader;
    var PortMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(port) {
        super();
        this.port = port;
        this.errorCount = 0;
        port.on("close", () => this.fireClose());
        port.on("error", (error) => this.fireError(error));
      }
      write(msg) {
        try {
          this.port.postMessage(msg);
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports.PortMessageWriter = PortMessageWriter;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
      }
    };
    exports.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(readable, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readable), encoding);
      }
    };
    exports.StreamMessageReader = StreamMessageReader;
    var StreamMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
      }
    };
    exports.StreamMessageWriter = StreamMessageWriter;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName() {
      const randomSuffix = (0, crypto_1.randomBytes)(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path3.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path3.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length > limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        let server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(pipeName);
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport(port, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        const server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection(input, output, logger, options) {
      if (!logger) {
        logger = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger, options);
    }
    exports.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/node.js
var require_node = __commonJS({
  "node_modules/vscode-jsonrpc/node.js"(exports, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// node_modules/vscode-languageserver-types/lib/umd/main.js
var require_main2 = __commonJS({
  "node_modules/vscode-languageserver-types/lib/umd/main.js"(exports, module2) {
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports);
        if (v !== void 0)
          module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
      }
    })(function(require2, exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TextDocument = exports2.EOL = exports2.WorkspaceFolder = exports2.InlineCompletionContext = exports2.SelectedCompletionInfo = exports2.InlineCompletionTriggerKind = exports2.InlineCompletionList = exports2.InlineCompletionItem = exports2.StringValue = exports2.InlayHint = exports2.InlayHintLabelPart = exports2.InlayHintKind = exports2.InlineValueContext = exports2.InlineValueEvaluatableExpression = exports2.InlineValueVariableLookup = exports2.InlineValueText = exports2.SemanticTokens = exports2.SemanticTokenModifiers = exports2.SemanticTokenTypes = exports2.SelectionRange = exports2.DocumentLink = exports2.FormattingOptions = exports2.CodeLens = exports2.CodeAction = exports2.CodeActionContext = exports2.CodeActionTriggerKind = exports2.CodeActionKind = exports2.DocumentSymbol = exports2.WorkspaceSymbol = exports2.SymbolInformation = exports2.SymbolTag = exports2.SymbolKind = exports2.DocumentHighlight = exports2.DocumentHighlightKind = exports2.SignatureInformation = exports2.ParameterInformation = exports2.Hover = exports2.MarkedString = exports2.CompletionList = exports2.CompletionItem = exports2.CompletionItemLabelDetails = exports2.InsertTextMode = exports2.InsertReplaceEdit = exports2.CompletionItemTag = exports2.InsertTextFormat = exports2.CompletionItemKind = exports2.MarkupContent = exports2.MarkupKind = exports2.TextDocumentItem = exports2.OptionalVersionedTextDocumentIdentifier = exports2.VersionedTextDocumentIdentifier = exports2.TextDocumentIdentifier = exports2.WorkspaceChange = exports2.WorkspaceEdit = exports2.DeleteFile = exports2.RenameFile = exports2.CreateFile = exports2.TextDocumentEdit = exports2.AnnotatedTextEdit = exports2.ChangeAnnotationIdentifier = exports2.ChangeAnnotation = exports2.TextEdit = exports2.Command = exports2.Diagnostic = exports2.CodeDescription = exports2.DiagnosticTag = exports2.DiagnosticSeverity = exports2.DiagnosticRelatedInformation = exports2.FoldingRange = exports2.FoldingRangeKind = exports2.ColorPresentation = exports2.ColorInformation = exports2.Color = exports2.LocationLink = exports2.Location = exports2.Range = exports2.Position = exports2.uinteger = exports2.integer = exports2.URI = exports2.DocumentUri = void 0;
      var DocumentUri;
      (function(DocumentUri2) {
        function is(value) {
          return typeof value === "string";
        }
        DocumentUri2.is = is;
      })(DocumentUri || (exports2.DocumentUri = DocumentUri = {}));
      var URI;
      (function(URI2) {
        function is(value) {
          return typeof value === "string";
        }
        URI2.is = is;
      })(URI || (exports2.URI = URI = {}));
      var integer;
      (function(integer2) {
        integer2.MIN_VALUE = -2147483648;
        integer2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
        }
        integer2.is = is;
      })(integer || (exports2.integer = integer = {}));
      var uinteger;
      (function(uinteger2) {
        uinteger2.MIN_VALUE = 0;
        uinteger2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
        }
        uinteger2.is = is;
      })(uinteger || (exports2.uinteger = uinteger = {}));
      var Position2;
      (function(Position3) {
        function create(line, character) {
          if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
          }
          if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
          }
          return { line, character };
        }
        Position3.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
        }
        Position3.is = is;
      })(Position2 || (exports2.Position = Position2 = {}));
      var Range3;
      (function(Range4) {
        function create(one, two, three, four) {
          if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position2.create(one, two), end: Position2.create(three, four) };
          } else if (Position2.is(one) && Position2.is(two)) {
            return { start: one, end: two };
          } else {
            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
          }
        }
        Range4.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position2.is(candidate.start) && Position2.is(candidate.end);
        }
        Range4.is = is;
      })(Range3 || (exports2.Range = Range3 = {}));
      var Location;
      (function(Location2) {
        function create(uri, range) {
          return { uri, range };
        }
        Location2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range3.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
        }
        Location2.is = is;
      })(Location || (exports2.Location = Location = {}));
      var LocationLink;
      (function(LocationLink2) {
        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
          return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
        }
        LocationLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range3.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range3.is(candidate.targetSelectionRange) && (Range3.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
        }
        LocationLink2.is = is;
      })(LocationLink || (exports2.LocationLink = LocationLink = {}));
      var Color;
      (function(Color2) {
        function create(red, green, blue, alpha) {
          return {
            red,
            green,
            blue,
            alpha
          };
        }
        Color2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
        }
        Color2.is = is;
      })(Color || (exports2.Color = Color = {}));
      var ColorInformation;
      (function(ColorInformation2) {
        function create(range, color) {
          return {
            range,
            color
          };
        }
        ColorInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range3.is(candidate.range) && Color.is(candidate.color);
        }
        ColorInformation2.is = is;
      })(ColorInformation || (exports2.ColorInformation = ColorInformation = {}));
      var ColorPresentation;
      (function(ColorPresentation2) {
        function create(label, textEdit, additionalTextEdits) {
          return {
            label,
            textEdit,
            additionalTextEdits
          };
        }
        ColorPresentation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
        }
        ColorPresentation2.is = is;
      })(ColorPresentation || (exports2.ColorPresentation = ColorPresentation = {}));
      var FoldingRangeKind;
      (function(FoldingRangeKind2) {
        FoldingRangeKind2.Comment = "comment";
        FoldingRangeKind2.Imports = "imports";
        FoldingRangeKind2.Region = "region";
      })(FoldingRangeKind || (exports2.FoldingRangeKind = FoldingRangeKind = {}));
      var FoldingRange;
      (function(FoldingRange2) {
        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
          var result = {
            startLine,
            endLine
          };
          if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
          }
          if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
          }
          if (Is.defined(kind)) {
            result.kind = kind;
          }
          if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
          }
          return result;
        }
        FoldingRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
        }
        FoldingRange2.is = is;
      })(FoldingRange || (exports2.FoldingRange = FoldingRange = {}));
      var DiagnosticRelatedInformation;
      (function(DiagnosticRelatedInformation2) {
        function create(location, message) {
          return {
            location,
            message
          };
        }
        DiagnosticRelatedInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
        }
        DiagnosticRelatedInformation2.is = is;
      })(DiagnosticRelatedInformation || (exports2.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));
      var DiagnosticSeverity;
      (function(DiagnosticSeverity2) {
        DiagnosticSeverity2.Error = 1;
        DiagnosticSeverity2.Warning = 2;
        DiagnosticSeverity2.Information = 3;
        DiagnosticSeverity2.Hint = 4;
      })(DiagnosticSeverity || (exports2.DiagnosticSeverity = DiagnosticSeverity = {}));
      var DiagnosticTag;
      (function(DiagnosticTag2) {
        DiagnosticTag2.Unnecessary = 1;
        DiagnosticTag2.Deprecated = 2;
      })(DiagnosticTag || (exports2.DiagnosticTag = DiagnosticTag = {}));
      var CodeDescription;
      (function(CodeDescription2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.href);
        }
        CodeDescription2.is = is;
      })(CodeDescription || (exports2.CodeDescription = CodeDescription = {}));
      var Diagnostic;
      (function(Diagnostic2) {
        function create(range, message, severity, code, source, relatedInformation) {
          var result = { range, message };
          if (Is.defined(severity)) {
            result.severity = severity;
          }
          if (Is.defined(code)) {
            result.code = code;
          }
          if (Is.defined(source)) {
            result.source = source;
          }
          if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
          }
          return result;
        }
        Diagnostic2.create = create;
        function is(value) {
          var _a;
          var candidate = value;
          return Is.defined(candidate) && Range3.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
        }
        Diagnostic2.is = is;
      })(Diagnostic || (exports2.Diagnostic = Diagnostic = {}));
      var Command;
      (function(Command2) {
        function create(title, command) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var result = { title, command };
          if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
          }
          return result;
        }
        Command2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
        }
        Command2.is = is;
      })(Command || (exports2.Command = Command = {}));
      var TextEdit;
      (function(TextEdit2) {
        function replace(range, newText) {
          return { range, newText };
        }
        TextEdit2.replace = replace;
        function insert(position, newText) {
          return { range: { start: position, end: position }, newText };
        }
        TextEdit2.insert = insert;
        function del(range) {
          return { range, newText: "" };
        }
        TextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range3.is(candidate.range);
        }
        TextEdit2.is = is;
      })(TextEdit || (exports2.TextEdit = TextEdit = {}));
      var ChangeAnnotation;
      (function(ChangeAnnotation2) {
        function create(label, needsConfirmation, description) {
          var result = { label };
          if (needsConfirmation !== void 0) {
            result.needsConfirmation = needsConfirmation;
          }
          if (description !== void 0) {
            result.description = description;
          }
          return result;
        }
        ChangeAnnotation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        ChangeAnnotation2.is = is;
      })(ChangeAnnotation || (exports2.ChangeAnnotation = ChangeAnnotation = {}));
      var ChangeAnnotationIdentifier;
      (function(ChangeAnnotationIdentifier2) {
        function is(value) {
          var candidate = value;
          return Is.string(candidate);
        }
        ChangeAnnotationIdentifier2.is = is;
      })(ChangeAnnotationIdentifier || (exports2.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));
      var AnnotatedTextEdit;
      (function(AnnotatedTextEdit2) {
        function replace(range, newText, annotation) {
          return { range, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.replace = replace;
        function insert(position, newText, annotation) {
          return { range: { start: position, end: position }, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.insert = insert;
        function del(range, annotation) {
          return { range, newText: "", annotationId: annotation };
        }
        AnnotatedTextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        AnnotatedTextEdit2.is = is;
      })(AnnotatedTextEdit || (exports2.AnnotatedTextEdit = AnnotatedTextEdit = {}));
      var TextDocumentEdit;
      (function(TextDocumentEdit2) {
        function create(textDocument, edits) {
          return { textDocument, edits };
        }
        TextDocumentEdit2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
        }
        TextDocumentEdit2.is = is;
      })(TextDocumentEdit || (exports2.TextDocumentEdit = TextDocumentEdit = {}));
      var CreateFile;
      (function(CreateFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "create",
            uri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        CreateFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        CreateFile2.is = is;
      })(CreateFile || (exports2.CreateFile = CreateFile = {}));
      var RenameFile;
      (function(RenameFile2) {
        function create(oldUri, newUri, options, annotation) {
          var result = {
            kind: "rename",
            oldUri,
            newUri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        RenameFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        RenameFile2.is = is;
      })(RenameFile || (exports2.RenameFile = RenameFile = {}));
      var DeleteFile;
      (function(DeleteFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "delete",
            uri
          };
          if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        DeleteFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        DeleteFile2.is = is;
      })(DeleteFile || (exports2.DeleteFile = DeleteFile = {}));
      var WorkspaceEdit;
      (function(WorkspaceEdit2) {
        function is(value) {
          var candidate = value;
          return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
            if (Is.string(change.kind)) {
              return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
            } else {
              return TextDocumentEdit.is(change);
            }
          }));
        }
        WorkspaceEdit2.is = is;
      })(WorkspaceEdit || (exports2.WorkspaceEdit = WorkspaceEdit = {}));
      var TextEditChangeImpl = (
        /** @class */
        function() {
          function TextEditChangeImpl2(edits, changeAnnotations) {
            this.edits = edits;
            this.changeAnnotations = changeAnnotations;
          }
          TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.insert(position, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.insert(position, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.insert(position, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.replace(range, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.replace(range, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.replace(range, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.delete = function(range, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.del(range);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.del(range, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.del(range, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.add = function(edit) {
            this.edits.push(edit);
          };
          TextEditChangeImpl2.prototype.all = function() {
            return this.edits;
          };
          TextEditChangeImpl2.prototype.clear = function() {
            this.edits.splice(0, this.edits.length);
          };
          TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
            if (value === void 0) {
              throw new Error("Text edit change is not configured to manage change annotations.");
            }
          };
          return TextEditChangeImpl2;
        }()
      );
      var ChangeAnnotations = (
        /** @class */
        function() {
          function ChangeAnnotations2(annotations) {
            this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
            this._counter = 0;
            this._size = 0;
          }
          ChangeAnnotations2.prototype.all = function() {
            return this._annotations;
          };
          Object.defineProperty(ChangeAnnotations2.prototype, "size", {
            get: function() {
              return this._size;
            },
            enumerable: false,
            configurable: true
          });
          ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
            var id;
            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
              id = idOrAnnotation;
            } else {
              id = this.nextId();
              annotation = idOrAnnotation;
            }
            if (this._annotations[id] !== void 0) {
              throw new Error("Id ".concat(id, " is already in use."));
            }
            if (annotation === void 0) {
              throw new Error("No annotation provided for id ".concat(id));
            }
            this._annotations[id] = annotation;
            this._size++;
            return id;
          };
          ChangeAnnotations2.prototype.nextId = function() {
            this._counter++;
            return this._counter.toString();
          };
          return ChangeAnnotations2;
        }()
      );
      var WorkspaceChange = (
        /** @class */
        function() {
          function WorkspaceChange2(workspaceEdit) {
            var _this = this;
            this._textEditChanges = /* @__PURE__ */ Object.create(null);
            if (workspaceEdit !== void 0) {
              this._workspaceEdit = workspaceEdit;
              if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function(change) {
                  if (TextDocumentEdit.is(change)) {
                    var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                    _this._textEditChanges[change.textDocument.uri] = textEditChange;
                  }
                });
              } else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function(key) {
                  var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                  _this._textEditChanges[key] = textEditChange;
                });
              }
            } else {
              this._workspaceEdit = {};
            }
          }
          Object.defineProperty(WorkspaceChange2.prototype, "edit", {
            /**
             * Returns the underlying {@link WorkspaceEdit} literal
             * use to be returned from a workspace edit operation like rename.
             */
            get: function() {
              this.initDocumentChanges();
              if (this._changeAnnotations !== void 0) {
                if (this._changeAnnotations.size === 0) {
                  this._workspaceEdit.changeAnnotations = void 0;
                } else {
                  this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
              }
              return this._workspaceEdit;
            },
            enumerable: false,
            configurable: true
          });
          WorkspaceChange2.prototype.getTextEditChange = function(key) {
            if (OptionalVersionedTextDocumentIdentifier.is(key)) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var textDocument = { uri: key.uri, version: key.version };
              var result = this._textEditChanges[textDocument.uri];
              if (!result) {
                var edits = [];
                var textDocumentEdit = {
                  textDocument,
                  edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
              }
              return result;
            } else {
              this.initChanges();
              if (this._workspaceEdit.changes === void 0) {
                throw new Error("Workspace edit is not configured for normal text edit changes.");
              }
              var result = this._textEditChanges[key];
              if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
              }
              return result;
            }
          };
          WorkspaceChange2.prototype.initDocumentChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._changeAnnotations = new ChangeAnnotations();
              this._workspaceEdit.documentChanges = [];
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          };
          WorkspaceChange2.prototype.initChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
            }
          };
          WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = CreateFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = CreateFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = RenameFile.create(oldUri, newUri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = RenameFile.create(oldUri, newUri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = DeleteFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = DeleteFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          return WorkspaceChange2;
        }()
      );
      exports2.WorkspaceChange = WorkspaceChange;
      var TextDocumentIdentifier;
      (function(TextDocumentIdentifier2) {
        function create(uri) {
          return { uri };
        }
        TextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri);
        }
        TextDocumentIdentifier2.is = is;
      })(TextDocumentIdentifier || (exports2.TextDocumentIdentifier = TextDocumentIdentifier = {}));
      var VersionedTextDocumentIdentifier;
      (function(VersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        VersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier2.is = is;
      })(VersionedTextDocumentIdentifier || (exports2.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));
      var OptionalVersionedTextDocumentIdentifier;
      (function(OptionalVersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        OptionalVersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier2.is = is;
      })(OptionalVersionedTextDocumentIdentifier || (exports2.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));
      var TextDocumentItem;
      (function(TextDocumentItem2) {
        function create(uri, languageId, version, text) {
          return { uri, languageId, version, text };
        }
        TextDocumentItem2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
        }
        TextDocumentItem2.is = is;
      })(TextDocumentItem || (exports2.TextDocumentItem = TextDocumentItem = {}));
      var MarkupKind;
      (function(MarkupKind2) {
        MarkupKind2.PlainText = "plaintext";
        MarkupKind2.Markdown = "markdown";
        function is(value) {
          var candidate = value;
          return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
        }
        MarkupKind2.is = is;
      })(MarkupKind || (exports2.MarkupKind = MarkupKind = {}));
      var MarkupContent;
      (function(MarkupContent2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
        }
        MarkupContent2.is = is;
      })(MarkupContent || (exports2.MarkupContent = MarkupContent = {}));
      var CompletionItemKind;
      (function(CompletionItemKind2) {
        CompletionItemKind2.Text = 1;
        CompletionItemKind2.Method = 2;
        CompletionItemKind2.Function = 3;
        CompletionItemKind2.Constructor = 4;
        CompletionItemKind2.Field = 5;
        CompletionItemKind2.Variable = 6;
        CompletionItemKind2.Class = 7;
        CompletionItemKind2.Interface = 8;
        CompletionItemKind2.Module = 9;
        CompletionItemKind2.Property = 10;
        CompletionItemKind2.Unit = 11;
        CompletionItemKind2.Value = 12;
        CompletionItemKind2.Enum = 13;
        CompletionItemKind2.Keyword = 14;
        CompletionItemKind2.Snippet = 15;
        CompletionItemKind2.Color = 16;
        CompletionItemKind2.File = 17;
        CompletionItemKind2.Reference = 18;
        CompletionItemKind2.Folder = 19;
        CompletionItemKind2.EnumMember = 20;
        CompletionItemKind2.Constant = 21;
        CompletionItemKind2.Struct = 22;
        CompletionItemKind2.Event = 23;
        CompletionItemKind2.Operator = 24;
        CompletionItemKind2.TypeParameter = 25;
      })(CompletionItemKind || (exports2.CompletionItemKind = CompletionItemKind = {}));
      var InsertTextFormat;
      (function(InsertTextFormat2) {
        InsertTextFormat2.PlainText = 1;
        InsertTextFormat2.Snippet = 2;
      })(InsertTextFormat || (exports2.InsertTextFormat = InsertTextFormat = {}));
      var CompletionItemTag;
      (function(CompletionItemTag2) {
        CompletionItemTag2.Deprecated = 1;
      })(CompletionItemTag || (exports2.CompletionItemTag = CompletionItemTag = {}));
      var InsertReplaceEdit;
      (function(InsertReplaceEdit2) {
        function create(newText, insert, replace) {
          return { newText, insert, replace };
        }
        InsertReplaceEdit2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.newText) && Range3.is(candidate.insert) && Range3.is(candidate.replace);
        }
        InsertReplaceEdit2.is = is;
      })(InsertReplaceEdit || (exports2.InsertReplaceEdit = InsertReplaceEdit = {}));
      var InsertTextMode;
      (function(InsertTextMode2) {
        InsertTextMode2.asIs = 1;
        InsertTextMode2.adjustIndentation = 2;
      })(InsertTextMode || (exports2.InsertTextMode = InsertTextMode = {}));
      var CompletionItemLabelDetails;
      (function(CompletionItemLabelDetails2) {
        function is(value) {
          var candidate = value;
          return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        CompletionItemLabelDetails2.is = is;
      })(CompletionItemLabelDetails || (exports2.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));
      var CompletionItem;
      (function(CompletionItem2) {
        function create(label) {
          return { label };
        }
        CompletionItem2.create = create;
      })(CompletionItem || (exports2.CompletionItem = CompletionItem = {}));
      var CompletionList;
      (function(CompletionList2) {
        function create(items, isIncomplete) {
          return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList2.create = create;
      })(CompletionList || (exports2.CompletionList = CompletionList = {}));
      var MarkedString;
      (function(MarkedString2) {
        function fromPlainText(plainText) {
          return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        MarkedString2.fromPlainText = fromPlainText;
        function is(value) {
          var candidate = value;
          return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
        }
        MarkedString2.is = is;
      })(MarkedString || (exports2.MarkedString = MarkedString = {}));
      var Hover;
      (function(Hover2) {
        function is(value) {
          var candidate = value;
          return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range3.is(value.range));
        }
        Hover2.is = is;
      })(Hover || (exports2.Hover = Hover = {}));
      var ParameterInformation;
      (function(ParameterInformation2) {
        function create(label, documentation) {
          return documentation ? { label, documentation } : { label };
        }
        ParameterInformation2.create = create;
      })(ParameterInformation || (exports2.ParameterInformation = ParameterInformation = {}));
      var SignatureInformation;
      (function(SignatureInformation2) {
        function create(label, documentation) {
          var parameters = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
          }
          var result = { label };
          if (Is.defined(documentation)) {
            result.documentation = documentation;
          }
          if (Is.defined(parameters)) {
            result.parameters = parameters;
          } else {
            result.parameters = [];
          }
          return result;
        }
        SignatureInformation2.create = create;
      })(SignatureInformation || (exports2.SignatureInformation = SignatureInformation = {}));
      var DocumentHighlightKind;
      (function(DocumentHighlightKind2) {
        DocumentHighlightKind2.Text = 1;
        DocumentHighlightKind2.Read = 2;
        DocumentHighlightKind2.Write = 3;
      })(DocumentHighlightKind || (exports2.DocumentHighlightKind = DocumentHighlightKind = {}));
      var DocumentHighlight;
      (function(DocumentHighlight2) {
        function create(range, kind) {
          var result = { range };
          if (Is.number(kind)) {
            result.kind = kind;
          }
          return result;
        }
        DocumentHighlight2.create = create;
      })(DocumentHighlight || (exports2.DocumentHighlight = DocumentHighlight = {}));
      var SymbolKind;
      (function(SymbolKind2) {
        SymbolKind2.File = 1;
        SymbolKind2.Module = 2;
        SymbolKind2.Namespace = 3;
        SymbolKind2.Package = 4;
        SymbolKind2.Class = 5;
        SymbolKind2.Method = 6;
        SymbolKind2.Property = 7;
        SymbolKind2.Field = 8;
        SymbolKind2.Constructor = 9;
        SymbolKind2.Enum = 10;
        SymbolKind2.Interface = 11;
        SymbolKind2.Function = 12;
        SymbolKind2.Variable = 13;
        SymbolKind2.Constant = 14;
        SymbolKind2.String = 15;
        SymbolKind2.Number = 16;
        SymbolKind2.Boolean = 17;
        SymbolKind2.Array = 18;
        SymbolKind2.Object = 19;
        SymbolKind2.Key = 20;
        SymbolKind2.Null = 21;
        SymbolKind2.EnumMember = 22;
        SymbolKind2.Struct = 23;
        SymbolKind2.Event = 24;
        SymbolKind2.Operator = 25;
        SymbolKind2.TypeParameter = 26;
      })(SymbolKind || (exports2.SymbolKind = SymbolKind = {}));
      var SymbolTag;
      (function(SymbolTag2) {
        SymbolTag2.Deprecated = 1;
      })(SymbolTag || (exports2.SymbolTag = SymbolTag = {}));
      var SymbolInformation;
      (function(SymbolInformation2) {
        function create(name, kind, range, uri, containerName) {
          var result = {
            name,
            kind,
            location: { uri, range }
          };
          if (containerName) {
            result.containerName = containerName;
          }
          return result;
        }
        SymbolInformation2.create = create;
      })(SymbolInformation || (exports2.SymbolInformation = SymbolInformation = {}));
      var WorkspaceSymbol;
      (function(WorkspaceSymbol2) {
        function create(name, kind, uri, range) {
          return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
        }
        WorkspaceSymbol2.create = create;
      })(WorkspaceSymbol || (exports2.WorkspaceSymbol = WorkspaceSymbol = {}));
      var DocumentSymbol;
      (function(DocumentSymbol2) {
        function create(name, detail, kind, range, selectionRange, children) {
          var result = {
            name,
            detail,
            kind,
            range,
            selectionRange
          };
          if (children !== void 0) {
            result.children = children;
          }
          return result;
        }
        DocumentSymbol2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range3.is(candidate.range) && Range3.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
        }
        DocumentSymbol2.is = is;
      })(DocumentSymbol || (exports2.DocumentSymbol = DocumentSymbol = {}));
      var CodeActionKind;
      (function(CodeActionKind2) {
        CodeActionKind2.Empty = "";
        CodeActionKind2.QuickFix = "quickfix";
        CodeActionKind2.Refactor = "refactor";
        CodeActionKind2.RefactorExtract = "refactor.extract";
        CodeActionKind2.RefactorInline = "refactor.inline";
        CodeActionKind2.RefactorRewrite = "refactor.rewrite";
        CodeActionKind2.Source = "source";
        CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
        CodeActionKind2.SourceFixAll = "source.fixAll";
      })(CodeActionKind || (exports2.CodeActionKind = CodeActionKind = {}));
      var CodeActionTriggerKind;
      (function(CodeActionTriggerKind2) {
        CodeActionTriggerKind2.Invoked = 1;
        CodeActionTriggerKind2.Automatic = 2;
      })(CodeActionTriggerKind || (exports2.CodeActionTriggerKind = CodeActionTriggerKind = {}));
      var CodeActionContext;
      (function(CodeActionContext2) {
        function create(diagnostics, only, triggerKind) {
          var result = { diagnostics };
          if (only !== void 0 && only !== null) {
            result.only = only;
          }
          if (triggerKind !== void 0 && triggerKind !== null) {
            result.triggerKind = triggerKind;
          }
          return result;
        }
        CodeActionContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
        }
        CodeActionContext2.is = is;
      })(CodeActionContext || (exports2.CodeActionContext = CodeActionContext = {}));
      var CodeAction;
      (function(CodeAction2) {
        function create(title, kindOrCommandOrEdit, kind) {
          var result = { title };
          var checkKind = true;
          if (typeof kindOrCommandOrEdit === "string") {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
          } else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
          } else {
            result.edit = kindOrCommandOrEdit;
          }
          if (checkKind && kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        CodeAction2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
        }
        CodeAction2.is = is;
      })(CodeAction || (exports2.CodeAction = CodeAction = {}));
      var CodeLens;
      (function(CodeLens2) {
        function create(range, data) {
          var result = { range };
          if (Is.defined(data)) {
            result.data = data;
          }
          return result;
        }
        CodeLens2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range3.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
        }
        CodeLens2.is = is;
      })(CodeLens || (exports2.CodeLens = CodeLens = {}));
      var FormattingOptions;
      (function(FormattingOptions2) {
        function create(tabSize, insertSpaces) {
          return { tabSize, insertSpaces };
        }
        FormattingOptions2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
        }
        FormattingOptions2.is = is;
      })(FormattingOptions || (exports2.FormattingOptions = FormattingOptions = {}));
      var DocumentLink;
      (function(DocumentLink2) {
        function create(range, target, data) {
          return { range, target, data };
        }
        DocumentLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range3.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
        }
        DocumentLink2.is = is;
      })(DocumentLink || (exports2.DocumentLink = DocumentLink = {}));
      var SelectionRange;
      (function(SelectionRange2) {
        function create(range, parent) {
          return { range, parent };
        }
        SelectionRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range3.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
        }
        SelectionRange2.is = is;
      })(SelectionRange || (exports2.SelectionRange = SelectionRange = {}));
      var SemanticTokenTypes;
      (function(SemanticTokenTypes2) {
        SemanticTokenTypes2["namespace"] = "namespace";
        SemanticTokenTypes2["type"] = "type";
        SemanticTokenTypes2["class"] = "class";
        SemanticTokenTypes2["enum"] = "enum";
        SemanticTokenTypes2["interface"] = "interface";
        SemanticTokenTypes2["struct"] = "struct";
        SemanticTokenTypes2["typeParameter"] = "typeParameter";
        SemanticTokenTypes2["parameter"] = "parameter";
        SemanticTokenTypes2["variable"] = "variable";
        SemanticTokenTypes2["property"] = "property";
        SemanticTokenTypes2["enumMember"] = "enumMember";
        SemanticTokenTypes2["event"] = "event";
        SemanticTokenTypes2["function"] = "function";
        SemanticTokenTypes2["method"] = "method";
        SemanticTokenTypes2["macro"] = "macro";
        SemanticTokenTypes2["keyword"] = "keyword";
        SemanticTokenTypes2["modifier"] = "modifier";
        SemanticTokenTypes2["comment"] = "comment";
        SemanticTokenTypes2["string"] = "string";
        SemanticTokenTypes2["number"] = "number";
        SemanticTokenTypes2["regexp"] = "regexp";
        SemanticTokenTypes2["operator"] = "operator";
        SemanticTokenTypes2["decorator"] = "decorator";
      })(SemanticTokenTypes || (exports2.SemanticTokenTypes = SemanticTokenTypes = {}));
      var SemanticTokenModifiers;
      (function(SemanticTokenModifiers2) {
        SemanticTokenModifiers2["declaration"] = "declaration";
        SemanticTokenModifiers2["definition"] = "definition";
        SemanticTokenModifiers2["readonly"] = "readonly";
        SemanticTokenModifiers2["static"] = "static";
        SemanticTokenModifiers2["deprecated"] = "deprecated";
        SemanticTokenModifiers2["abstract"] = "abstract";
        SemanticTokenModifiers2["async"] = "async";
        SemanticTokenModifiers2["modification"] = "modification";
        SemanticTokenModifiers2["documentation"] = "documentation";
        SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
      })(SemanticTokenModifiers || (exports2.SemanticTokenModifiers = SemanticTokenModifiers = {}));
      var SemanticTokens;
      (function(SemanticTokens2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
        }
        SemanticTokens2.is = is;
      })(SemanticTokens || (exports2.SemanticTokens = SemanticTokens = {}));
      var InlineValueText;
      (function(InlineValueText2) {
        function create(range, text) {
          return { range, text };
        }
        InlineValueText2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range3.is(candidate.range) && Is.string(candidate.text);
        }
        InlineValueText2.is = is;
      })(InlineValueText || (exports2.InlineValueText = InlineValueText = {}));
      var InlineValueVariableLookup;
      (function(InlineValueVariableLookup2) {
        function create(range, variableName, caseSensitiveLookup) {
          return { range, variableName, caseSensitiveLookup };
        }
        InlineValueVariableLookup2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range3.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
        }
        InlineValueVariableLookup2.is = is;
      })(InlineValueVariableLookup || (exports2.InlineValueVariableLookup = InlineValueVariableLookup = {}));
      var InlineValueEvaluatableExpression;
      (function(InlineValueEvaluatableExpression2) {
        function create(range, expression) {
          return { range, expression };
        }
        InlineValueEvaluatableExpression2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range3.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
        }
        InlineValueEvaluatableExpression2.is = is;
      })(InlineValueEvaluatableExpression || (exports2.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));
      var InlineValueContext;
      (function(InlineValueContext2) {
        function create(frameId, stoppedLocation) {
          return { frameId, stoppedLocation };
        }
        InlineValueContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range3.is(value.stoppedLocation);
        }
        InlineValueContext2.is = is;
      })(InlineValueContext || (exports2.InlineValueContext = InlineValueContext = {}));
      var InlayHintKind;
      (function(InlayHintKind2) {
        InlayHintKind2.Type = 1;
        InlayHintKind2.Parameter = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        InlayHintKind2.is = is;
      })(InlayHintKind || (exports2.InlayHintKind = InlayHintKind = {}));
      var InlayHintLabelPart;
      (function(InlayHintLabelPart2) {
        function create(value) {
          return { value };
        }
        InlayHintLabelPart2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
        }
        InlayHintLabelPart2.is = is;
      })(InlayHintLabelPart || (exports2.InlayHintLabelPart = InlayHintLabelPart = {}));
      var InlayHint;
      (function(InlayHint2) {
        function create(position, label, kind) {
          var result = { position, label };
          if (kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        InlayHint2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position2.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
        }
        InlayHint2.is = is;
      })(InlayHint || (exports2.InlayHint = InlayHint = {}));
      var StringValue;
      (function(StringValue2) {
        function createSnippet(value) {
          return { kind: "snippet", value };
        }
        StringValue2.createSnippet = createSnippet;
      })(StringValue || (exports2.StringValue = StringValue = {}));
      var InlineCompletionItem;
      (function(InlineCompletionItem2) {
        function create(insertText, filterText, range, command) {
          return { insertText, filterText, range, command };
        }
        InlineCompletionItem2.create = create;
      })(InlineCompletionItem || (exports2.InlineCompletionItem = InlineCompletionItem = {}));
      var InlineCompletionList;
      (function(InlineCompletionList2) {
        function create(items) {
          return { items };
        }
        InlineCompletionList2.create = create;
      })(InlineCompletionList || (exports2.InlineCompletionList = InlineCompletionList = {}));
      var InlineCompletionTriggerKind;
      (function(InlineCompletionTriggerKind2) {
        InlineCompletionTriggerKind2.Invoked = 0;
        InlineCompletionTriggerKind2.Automatic = 1;
      })(InlineCompletionTriggerKind || (exports2.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));
      var SelectedCompletionInfo;
      (function(SelectedCompletionInfo2) {
        function create(range, text) {
          return { range, text };
        }
        SelectedCompletionInfo2.create = create;
      })(SelectedCompletionInfo || (exports2.SelectedCompletionInfo = SelectedCompletionInfo = {}));
      var InlineCompletionContext;
      (function(InlineCompletionContext2) {
        function create(triggerKind, selectedCompletionInfo) {
          return { triggerKind, selectedCompletionInfo };
        }
        InlineCompletionContext2.create = create;
      })(InlineCompletionContext || (exports2.InlineCompletionContext = InlineCompletionContext = {}));
      var WorkspaceFolder2;
      (function(WorkspaceFolder3) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
        }
        WorkspaceFolder3.is = is;
      })(WorkspaceFolder2 || (exports2.WorkspaceFolder = WorkspaceFolder2 = {}));
      exports2.EOL = ["\n", "\r\n", "\r"];
      var TextDocument;
      (function(TextDocument2) {
        function create(uri, languageId, version, content) {
          return new FullTextDocument(uri, languageId, version, content);
        }
        TextDocument2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
        }
        TextDocument2.is = is;
        function applyEdits(document, edits) {
          var text = document.getText();
          var sortedEdits = mergeSort(edits, function(a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          var lastModifiedOffset = text.length;
          for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
              text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            } else {
              throw new Error("Overlapping edit");
            }
            lastModifiedOffset = startOffset;
          }
          return text;
        }
        TextDocument2.applyEdits = applyEdits;
        function mergeSort(data, compare) {
          if (data.length <= 1) {
            return data;
          }
          var p = data.length / 2 | 0;
          var left = data.slice(0, p);
          var right = data.slice(p);
          mergeSort(left, compare);
          mergeSort(right, compare);
          var leftIdx = 0;
          var rightIdx = 0;
          var i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
      })(TextDocument || (exports2.TextDocument = TextDocument = {}));
      var FullTextDocument = (
        /** @class */
        function() {
          function FullTextDocument2(uri, languageId, version, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version;
            this._content = content;
            this._lineOffsets = void 0;
          }
          Object.defineProperty(FullTextDocument2.prototype, "uri", {
            get: function() {
              return this._uri;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument2.prototype, "languageId", {
            get: function() {
              return this._languageId;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument2.prototype, "version", {
            get: function() {
              return this._version;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument2.prototype.getText = function(range) {
            if (range) {
              var start = this.offsetAt(range.start);
              var end = this.offsetAt(range.end);
              return this._content.substring(start, end);
            }
            return this._content;
          };
          FullTextDocument2.prototype.update = function(event, version) {
            this._content = event.text;
            this._version = version;
            this._lineOffsets = void 0;
          };
          FullTextDocument2.prototype.getLineOffsets = function() {
            if (this._lineOffsets === void 0) {
              var lineOffsets = [];
              var text = this._content;
              var isLineStart = true;
              for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                  lineOffsets.push(i);
                  isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = ch === "\r" || ch === "\n";
                if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                  i++;
                }
              }
              if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
              }
              this._lineOffsets = lineOffsets;
            }
            return this._lineOffsets;
          };
          FullTextDocument2.prototype.positionAt = function(offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
              return Position2.create(0, offset);
            }
            while (low < high) {
              var mid = Math.floor((low + high) / 2);
              if (lineOffsets[mid] > offset) {
                high = mid;
              } else {
                low = mid + 1;
              }
            }
            var line = low - 1;
            return Position2.create(line, offset - lineOffsets[line]);
          };
          FullTextDocument2.prototype.offsetAt = function(position) {
            var lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
              return this._content.length;
            } else if (position.line < 0) {
              return 0;
            }
            var lineOffset = lineOffsets[position.line];
            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
          };
          Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
            get: function() {
              return this.getLineOffsets().length;
            },
            enumerable: false,
            configurable: true
          });
          return FullTextDocument2;
        }()
      );
      var Is;
      (function(Is2) {
        var toString = Object.prototype.toString;
        function defined(value) {
          return typeof value !== "undefined";
        }
        Is2.defined = defined;
        function undefined2(value) {
          return typeof value === "undefined";
        }
        Is2.undefined = undefined2;
        function boolean(value) {
          return value === true || value === false;
        }
        Is2.boolean = boolean;
        function string(value) {
          return toString.call(value) === "[object String]";
        }
        Is2.string = string;
        function number(value) {
          return toString.call(value) === "[object Number]";
        }
        Is2.number = number;
        function numberRange(value, min, max) {
          return toString.call(value) === "[object Number]" && min <= value && value <= max;
        }
        Is2.numberRange = numberRange;
        function integer2(value) {
          return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
        }
        Is2.integer = integer2;
        function uinteger2(value) {
          return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
        }
        Is2.uinteger = uinteger2;
        function func(value) {
          return toString.call(value) === "[object Function]";
        }
        Is2.func = func;
        function objectLiteral(value) {
          return value !== null && typeof value === "object";
        }
        Is2.objectLiteral = objectLiteral;
        function typedArray(value, check) {
          return Array.isArray(value) && value.every(check);
        }
        Is2.typedArray = typedArray;
      })(Is || (Is = {}));
    });
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = exports.MessageDirection = void 0;
    var vscode_jsonrpc_1 = require_main();
    var MessageDirection;
    (function(MessageDirection2) {
      MessageDirection2["clientToServer"] = "clientToServer";
      MessageDirection2["serverToClient"] = "serverToClient";
      MessageDirection2["both"] = "both";
    })(MessageDirection || (exports.MessageDirection = MessageDirection = {}));
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports.RegistrationType = RegistrationType;
    var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports.ProtocolRequestType0 = ProtocolRequestType0;
    var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports.ProtocolRequestType = ProtocolRequestType;
    var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports.ProtocolNotificationType0 = ProtocolNotificationType0;
    var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports.ProtocolNotificationType = ProtocolNotificationType;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports.typedArray = typedArray;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    exports.objectLiteral = objectLiteral;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest;
    (function(ImplementationRequest2) {
      ImplementationRequest2.method = "textDocument/implementation";
      ImplementationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    })(ImplementationRequest || (exports.ImplementationRequest = ImplementationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest;
    (function(TypeDefinitionRequest2) {
      TypeDefinitionRequest2.method = "textDocument/typeDefinition";
      TypeDefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    })(TypeDefinitionRequest || (exports.TypeDefinitionRequest = TypeDefinitionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
var require_protocol_workspaceFolder = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest;
    (function(WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.method = "workspace/workspaceFolders";
      WorkspaceFoldersRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest2.method);
    })(WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function(DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.method = "workspace/didChangeWorkspaceFolders";
      DidChangeWorkspaceFoldersNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification2.method);
    })(DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest;
    (function(ConfigurationRequest2) {
      ConfigurationRequest2.method = "workspace/configuration";
      ConfigurationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ConfigurationRequest2.type = new messages_1.ProtocolRequestType(ConfigurationRequest2.method);
    })(ConfigurationRequest || (exports.ConfigurationRequest = ConfigurationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest;
    (function(DocumentColorRequest2) {
      DocumentColorRequest2.method = "textDocument/documentColor";
      DocumentColorRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    })(DocumentColorRequest || (exports.DocumentColorRequest = DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function(ColorPresentationRequest2) {
      ColorPresentationRequest2.method = "textDocument/colorPresentation";
      ColorPresentationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ColorPresentationRequest2.type = new messages_1.ProtocolRequestType(ColorPresentationRequest2.method);
    })(ColorPresentationRequest || (exports.ColorPresentationRequest = ColorPresentationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FoldingRangeRefreshRequest = exports.FoldingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeRequest;
    (function(FoldingRangeRequest2) {
      FoldingRangeRequest2.method = "textDocument/foldingRange";
      FoldingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    })(FoldingRangeRequest || (exports.FoldingRangeRequest = FoldingRangeRequest = {}));
    var FoldingRangeRefreshRequest;
    (function(FoldingRangeRefreshRequest2) {
      FoldingRangeRefreshRequest2.method = `workspace/foldingRange/refresh`;
      FoldingRangeRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      FoldingRangeRefreshRequest2.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest2.method);
    })(FoldingRangeRefreshRequest || (exports.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest;
    (function(DeclarationRequest2) {
      DeclarationRequest2.method = "textDocument/declaration";
      DeclarationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    })(DeclarationRequest || (exports.DeclarationRequest = DeclarationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest;
    (function(SelectionRangeRequest2) {
      SelectionRangeRequest2.method = "textDocument/selectionRange";
      SelectionRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    })(SelectionRangeRequest || (exports.SelectionRangeRequest = SelectionRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress;
    (function(WorkDoneProgress2) {
      WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress2.type;
      }
      WorkDoneProgress2.is = is;
    })(WorkDoneProgress || (exports.WorkDoneProgress = WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest;
    (function(WorkDoneProgressCreateRequest2) {
      WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
      WorkDoneProgressCreateRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
    })(WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
      WorkDoneProgressCancelNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
    })(WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = void 0;
    var messages_1 = require_messages2();
    var TokenFormat;
    (function(TokenFormat2) {
      TokenFormat2.Relative = "relative";
    })(TokenFormat || (exports.TokenFormat = TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function(SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
      SemanticTokensRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRequest || (exports.SemanticTokensRequest = SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest;
    (function(SemanticTokensDeltaRequest2) {
      SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
      SemanticTokensDeltaRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
      SemanticTokensRangeRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest;
    (function(SemanticTokensRefreshRequest2) {
      SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
    })(SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest;
    (function(ShowDocumentRequest2) {
      ShowDocumentRequest2.method = "window/showDocument";
      ShowDocumentRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
    })(ShowDocumentRequest || (exports.ShowDocumentRequest = ShowDocumentRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest;
    (function(LinkedEditingRangeRequest2) {
      LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
    })(LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind;
    (function(FileOperationPatternKind2) {
      FileOperationPatternKind2.file = "file";
      FileOperationPatternKind2.folder = "folder";
    })(FileOperationPatternKind || (exports.FileOperationPatternKind = FileOperationPatternKind = {}));
    var WillCreateFilesRequest;
    (function(WillCreateFilesRequest2) {
      WillCreateFilesRequest2.method = "workspace/willCreateFiles";
      WillCreateFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
    })(WillCreateFilesRequest || (exports.WillCreateFilesRequest = WillCreateFilesRequest = {}));
    var DidCreateFilesNotification;
    (function(DidCreateFilesNotification2) {
      DidCreateFilesNotification2.method = "workspace/didCreateFiles";
      DidCreateFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
    })(DidCreateFilesNotification || (exports.DidCreateFilesNotification = DidCreateFilesNotification = {}));
    var WillRenameFilesRequest;
    (function(WillRenameFilesRequest2) {
      WillRenameFilesRequest2.method = "workspace/willRenameFiles";
      WillRenameFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
    })(WillRenameFilesRequest || (exports.WillRenameFilesRequest = WillRenameFilesRequest = {}));
    var DidRenameFilesNotification;
    (function(DidRenameFilesNotification2) {
      DidRenameFilesNotification2.method = "workspace/didRenameFiles";
      DidRenameFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
    })(DidRenameFilesNotification || (exports.DidRenameFilesNotification = DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification;
    (function(DidDeleteFilesNotification2) {
      DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
    })(DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest;
    (function(WillDeleteFilesRequest2) {
      WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
    })(WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2.document = "document";
      UniquenessLevel2.project = "project";
      UniquenessLevel2.group = "group";
      UniquenessLevel2.scheme = "scheme";
      UniquenessLevel2.global = "global";
    })(UniquenessLevel || (exports.UniquenessLevel = UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2.$import = "import";
      MonikerKind2.$export = "export";
      MonikerKind2.local = "local";
    })(MonikerKind || (exports.MonikerKind = MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest || (exports.MonikerRequest = MonikerRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
var require_protocol_typeHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeHierarchySubtypesRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var TypeHierarchyPrepareRequest;
    (function(TypeHierarchyPrepareRequest2) {
      TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
      TypeHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
    })(TypeHierarchyPrepareRequest || (exports.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
    var TypeHierarchySupertypesRequest;
    (function(TypeHierarchySupertypesRequest2) {
      TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
      TypeHierarchySupertypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
    })(TypeHierarchySupertypesRequest || (exports.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
    var TypeHierarchySubtypesRequest;
    (function(TypeHierarchySubtypesRequest2) {
      TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
      TypeHierarchySubtypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
    })(TypeHierarchySubtypesRequest || (exports.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
var require_protocol_inlineValue = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlineValueRefreshRequest = exports.InlineValueRequest = void 0;
    var messages_1 = require_messages2();
    var InlineValueRequest;
    (function(InlineValueRequest2) {
      InlineValueRequest2.method = "textDocument/inlineValue";
      InlineValueRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
    })(InlineValueRequest || (exports.InlineValueRequest = InlineValueRequest = {}));
    var InlineValueRefreshRequest;
    (function(InlineValueRefreshRequest2) {
      InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
      InlineValueRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
    })(InlineValueRefreshRequest || (exports.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
var require_protocol_inlayHint = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = void 0;
    var messages_1 = require_messages2();
    var InlayHintRequest;
    (function(InlayHintRequest2) {
      InlayHintRequest2.method = "textDocument/inlayHint";
      InlayHintRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
    })(InlayHintRequest || (exports.InlayHintRequest = InlayHintRequest = {}));
    var InlayHintResolveRequest;
    (function(InlayHintResolveRequest2) {
      InlayHintResolveRequest2.method = "inlayHint/resolve";
      InlayHintResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
    })(InlayHintResolveRequest || (exports.InlayHintResolveRequest = InlayHintResolveRequest = {}));
    var InlayHintRefreshRequest;
    (function(InlayHintRefreshRequest2) {
      InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
      InlayHintRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
    })(InlayHintRefreshRequest || (exports.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
var require_protocol_diagnostic = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = void 0;
    var vscode_jsonrpc_1 = require_main();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var DiagnosticServerCancellationData;
    (function(DiagnosticServerCancellationData2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.retriggerRequest);
      }
      DiagnosticServerCancellationData2.is = is;
    })(DiagnosticServerCancellationData || (exports.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
    var DocumentDiagnosticReportKind;
    (function(DocumentDiagnosticReportKind2) {
      DocumentDiagnosticReportKind2.Full = "full";
      DocumentDiagnosticReportKind2.Unchanged = "unchanged";
    })(DocumentDiagnosticReportKind || (exports.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
    var DocumentDiagnosticRequest;
    (function(DocumentDiagnosticRequest2) {
      DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
      DocumentDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
      DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(DocumentDiagnosticRequest || (exports.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
    var WorkspaceDiagnosticRequest;
    (function(WorkspaceDiagnosticRequest2) {
      WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
      WorkspaceDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
      WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(WorkspaceDiagnosticRequest || (exports.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
    var DiagnosticRefreshRequest;
    (function(DiagnosticRefreshRequest2) {
      DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
      DiagnosticRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
    })(DiagnosticRefreshRequest || (exports.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
var require_protocol_notebook = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = void 0;
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var NotebookCellKind;
    (function(NotebookCellKind2) {
      NotebookCellKind2.Markup = 1;
      NotebookCellKind2.Code = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      NotebookCellKind2.is = is;
    })(NotebookCellKind || (exports.NotebookCellKind = NotebookCellKind = {}));
    var ExecutionSummary;
    (function(ExecutionSummary2) {
      function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
          result.success = success;
        }
        return result;
      }
      ExecutionSummary2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is.boolean(candidate.success));
      }
      ExecutionSummary2.is = is;
      function equals(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
      }
      ExecutionSummary2.equals = equals;
    })(ExecutionSummary || (exports.ExecutionSummary = ExecutionSummary = {}));
    var NotebookCell;
    (function(NotebookCell2) {
      function create(kind, document) {
        return { kind, document };
      }
      NotebookCell2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is.objectLiteral(candidate.metadata));
      }
      NotebookCell2.is = is;
      function diff(one, two) {
        const result = /* @__PURE__ */ new Set();
        if (one.document !== two.document) {
          result.add("document");
        }
        if (one.kind !== two.kind) {
          result.add("kind");
        }
        if (one.executionSummary !== two.executionSummary) {
          result.add("executionSummary");
        }
        if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
          result.add("metadata");
        }
        if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
          result.add("executionSummary");
        }
        return result;
      }
      NotebookCell2.diff = diff;
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
        }
        return true;
      }
    })(NotebookCell || (exports.NotebookCell = NotebookCell = {}));
    var NotebookDocument;
    (function(NotebookDocument2) {
      function create(uri, notebookType, version, cells) {
        return { uri, notebookType, version, cells };
      }
      NotebookDocument2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
      }
      NotebookDocument2.is = is;
    })(NotebookDocument || (exports.NotebookDocument = NotebookDocument = {}));
    var NotebookDocumentSyncRegistrationType;
    (function(NotebookDocumentSyncRegistrationType2) {
      NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
      NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
      NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
    })(NotebookDocumentSyncRegistrationType || (exports.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
    var DidOpenNotebookDocumentNotification;
    (function(DidOpenNotebookDocumentNotification2) {
      DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
      DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
      DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidOpenNotebookDocumentNotification || (exports.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
    var NotebookCellArrayChange;
    (function(NotebookCellArrayChange2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is.typedArray(candidate.cells, NotebookCell.is));
      }
      NotebookCellArrayChange2.is = is;
      function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== void 0) {
          result.cells = cells;
        }
        return result;
      }
      NotebookCellArrayChange2.create = create;
    })(NotebookCellArrayChange || (exports.NotebookCellArrayChange = NotebookCellArrayChange = {}));
    var DidChangeNotebookDocumentNotification;
    (function(DidChangeNotebookDocumentNotification2) {
      DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
      DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
      DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidChangeNotebookDocumentNotification || (exports.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
    var DidSaveNotebookDocumentNotification;
    (function(DidSaveNotebookDocumentNotification2) {
      DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
      DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
      DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidSaveNotebookDocumentNotification || (exports.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
    var DidCloseNotebookDocumentNotification;
    (function(DidCloseNotebookDocumentNotification2) {
      DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
      DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
      DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidCloseNotebookDocumentNotification || (exports.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js
var require_protocol_inlineCompletion = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlineCompletionRequest = void 0;
    var messages_1 = require_messages2();
    var InlineCompletionRequest;
    (function(InlineCompletionRequest2) {
      InlineCompletionRequest2.method = "textDocument/inlineCompletion";
      InlineCompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineCompletionRequest2.type = new messages_1.ProtocolRequestType(InlineCompletionRequest2.method);
    })(InlineCompletionRequest || (exports.InlineCompletionRequest = InlineCompletionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.RelativePattern = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeErrorCodes = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.PositionEncodingKind = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.NotebookCellTextDocumentFilter = exports.NotebookDocumentFilter = exports.TextDocumentFilter = void 0;
    exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRefreshRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangesFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolResolveRequest = void 0;
    exports.InlineCompletionRequest = exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = exports.InlineValueRefreshRequest = exports.InlineValueRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchySubtypesRequest = exports.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
    Object.defineProperty(exports, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    Object.defineProperty(exports, "FoldingRangeRefreshRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRefreshRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
    Object.defineProperty(exports, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
    } });
    Object.defineProperty(exports, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
    } });
    Object.defineProperty(exports, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
    } });
    var protocol_inlineValue_1 = require_protocol_inlineValue();
    Object.defineProperty(exports, "InlineValueRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRequest;
    } });
    Object.defineProperty(exports, "InlineValueRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRefreshRequest;
    } });
    var protocol_inlayHint_1 = require_protocol_inlayHint();
    Object.defineProperty(exports, "InlayHintRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRequest;
    } });
    Object.defineProperty(exports, "InlayHintResolveRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintResolveRequest;
    } });
    Object.defineProperty(exports, "InlayHintRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRefreshRequest;
    } });
    var protocol_diagnostic_1 = require_protocol_diagnostic();
    Object.defineProperty(exports, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticServerCancellationData;
    } });
    Object.defineProperty(exports, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticReportKind;
    } });
    Object.defineProperty(exports, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticRequest;
    } });
    Object.defineProperty(exports, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
    } });
    Object.defineProperty(exports, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticRefreshRequest;
    } });
    var protocol_notebook_1 = require_protocol_notebook();
    Object.defineProperty(exports, "NotebookCellKind", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellKind;
    } });
    Object.defineProperty(exports, "ExecutionSummary", { enumerable: true, get: function() {
      return protocol_notebook_1.ExecutionSummary;
    } });
    Object.defineProperty(exports, "NotebookCell", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCell;
    } });
    Object.defineProperty(exports, "NotebookDocument", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocument;
    } });
    Object.defineProperty(exports, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
    } });
    Object.defineProperty(exports, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidOpenNotebookDocumentNotification;
    } });
    Object.defineProperty(exports, "NotebookCellArrayChange", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellArrayChange;
    } });
    Object.defineProperty(exports, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidChangeNotebookDocumentNotification;
    } });
    Object.defineProperty(exports, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidSaveNotebookDocumentNotification;
    } });
    Object.defineProperty(exports, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidCloseNotebookDocumentNotification;
    } });
    var protocol_inlineCompletion_1 = require_protocol_inlineCompletion();
    Object.defineProperty(exports, "InlineCompletionRequest", { enumerable: true, get: function() {
      return protocol_inlineCompletion_1.InlineCompletionRequest;
    } });
    var TextDocumentFilter;
    (function(TextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.string(candidate) || (Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      TextDocumentFilter2.is = is;
    })(TextDocumentFilter || (exports.TextDocumentFilter = TextDocumentFilter = {}));
    var NotebookDocumentFilter;
    (function(NotebookDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      NotebookDocumentFilter2.is = is;
    })(NotebookDocumentFilter || (exports.NotebookDocumentFilter = NotebookDocumentFilter = {}));
    var NotebookCellTextDocumentFilter;
    (function(NotebookCellTextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is.string(candidate.language));
      }
      NotebookCellTextDocumentFilter2.is = is;
    })(NotebookCellTextDocumentFilter || (exports.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
    var DocumentSelector;
    (function(DocumentSelector2) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector2.is = is;
    })(DocumentSelector || (exports.DocumentSelector = DocumentSelector = {}));
    var RegistrationRequest;
    (function(RegistrationRequest2) {
      RegistrationRequest2.method = "client/registerCapability";
      RegistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      RegistrationRequest2.type = new messages_1.ProtocolRequestType(RegistrationRequest2.method);
    })(RegistrationRequest || (exports.RegistrationRequest = RegistrationRequest = {}));
    var UnregistrationRequest;
    (function(UnregistrationRequest2) {
      UnregistrationRequest2.method = "client/unregisterCapability";
      UnregistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      UnregistrationRequest2.type = new messages_1.ProtocolRequestType(UnregistrationRequest2.method);
    })(UnregistrationRequest || (exports.UnregistrationRequest = UnregistrationRequest = {}));
    var ResourceOperationKind;
    (function(ResourceOperationKind2) {
      ResourceOperationKind2.Create = "create";
      ResourceOperationKind2.Rename = "rename";
      ResourceOperationKind2.Delete = "delete";
    })(ResourceOperationKind || (exports.ResourceOperationKind = ResourceOperationKind = {}));
    var FailureHandlingKind;
    (function(FailureHandlingKind2) {
      FailureHandlingKind2.Abort = "abort";
      FailureHandlingKind2.Transactional = "transactional";
      FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind2.Undo = "undo";
    })(FailureHandlingKind || (exports.FailureHandlingKind = FailureHandlingKind = {}));
    var PositionEncodingKind;
    (function(PositionEncodingKind2) {
      PositionEncodingKind2.UTF8 = "utf-8";
      PositionEncodingKind2.UTF16 = "utf-16";
      PositionEncodingKind2.UTF32 = "utf-32";
    })(PositionEncodingKind || (exports.PositionEncodingKind = PositionEncodingKind = {}));
    var StaticRegistrationOptions;
    (function(StaticRegistrationOptions2) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions2.hasId = hasId;
    })(StaticRegistrationOptions || (exports.StaticRegistrationOptions = StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions;
    (function(TextDocumentRegistrationOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions2.is = is;
    })(TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions;
    (function(WorkDoneProgressOptions2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions2.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
    var InitializeRequest;
    (function(InitializeRequest2) {
      InitializeRequest2.method = "initialize";
      InitializeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializeRequest2.type = new messages_1.ProtocolRequestType(InitializeRequest2.method);
    })(InitializeRequest || (exports.InitializeRequest = InitializeRequest = {}));
    var InitializeErrorCodes;
    (function(InitializeErrorCodes2) {
      InitializeErrorCodes2.unknownProtocolVersion = 1;
    })(InitializeErrorCodes || (exports.InitializeErrorCodes = InitializeErrorCodes = {}));
    var InitializedNotification;
    (function(InitializedNotification2) {
      InitializedNotification2.method = "initialized";
      InitializedNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializedNotification2.type = new messages_1.ProtocolNotificationType(InitializedNotification2.method);
    })(InitializedNotification || (exports.InitializedNotification = InitializedNotification = {}));
    var ShutdownRequest;
    (function(ShutdownRequest2) {
      ShutdownRequest2.method = "shutdown";
      ShutdownRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ShutdownRequest2.type = new messages_1.ProtocolRequestType0(ShutdownRequest2.method);
    })(ShutdownRequest || (exports.ShutdownRequest = ShutdownRequest = {}));
    var ExitNotification;
    (function(ExitNotification2) {
      ExitNotification2.method = "exit";
      ExitNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExitNotification2.type = new messages_1.ProtocolNotificationType0(ExitNotification2.method);
    })(ExitNotification || (exports.ExitNotification = ExitNotification = {}));
    var DidChangeConfigurationNotification;
    (function(DidChangeConfigurationNotification2) {
      DidChangeConfigurationNotification2.method = "workspace/didChangeConfiguration";
      DidChangeConfigurationNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification2.method);
    })(DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2.Error = 1;
      MessageType2.Warning = 2;
      MessageType2.Info = 3;
      MessageType2.Log = 4;
      MessageType2.Debug = 5;
    })(MessageType || (exports.MessageType = MessageType = {}));
    var ShowMessageNotification;
    (function(ShowMessageNotification2) {
      ShowMessageNotification2.method = "window/showMessage";
      ShowMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageNotification2.type = new messages_1.ProtocolNotificationType(ShowMessageNotification2.method);
    })(ShowMessageNotification || (exports.ShowMessageNotification = ShowMessageNotification = {}));
    var ShowMessageRequest;
    (function(ShowMessageRequest2) {
      ShowMessageRequest2.method = "window/showMessageRequest";
      ShowMessageRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageRequest2.type = new messages_1.ProtocolRequestType(ShowMessageRequest2.method);
    })(ShowMessageRequest || (exports.ShowMessageRequest = ShowMessageRequest = {}));
    var LogMessageNotification;
    (function(LogMessageNotification2) {
      LogMessageNotification2.method = "window/logMessage";
      LogMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      LogMessageNotification2.type = new messages_1.ProtocolNotificationType(LogMessageNotification2.method);
    })(LogMessageNotification || (exports.LogMessageNotification = LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.method = "telemetry/event";
      TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
    })(TelemetryEventNotification || (exports.TelemetryEventNotification = TelemetryEventNotification = {}));
    var TextDocumentSyncKind;
    (function(TextDocumentSyncKind2) {
      TextDocumentSyncKind2.None = 0;
      TextDocumentSyncKind2.Full = 1;
      TextDocumentSyncKind2.Incremental = 2;
    })(TextDocumentSyncKind || (exports.TextDocumentSyncKind = TextDocumentSyncKind = {}));
    var DidOpenTextDocumentNotification;
    (function(DidOpenTextDocumentNotification2) {
      DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
    })(DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent;
    (function(TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification;
    (function(DidChangeTextDocumentNotification2) {
      DidChangeTextDocumentNotification2.method = "textDocument/didChange";
      DidChangeTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
    })(DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification;
    (function(DidCloseTextDocumentNotification2) {
      DidCloseTextDocumentNotification2.method = "textDocument/didClose";
      DidCloseTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
    })(DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification;
    (function(DidSaveTextDocumentNotification2) {
      DidSaveTextDocumentNotification2.method = "textDocument/didSave";
      DidSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
    })(DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason;
    (function(TextDocumentSaveReason2) {
      TextDocumentSaveReason2.Manual = 1;
      TextDocumentSaveReason2.AfterDelay = 2;
      TextDocumentSaveReason2.FocusOut = 3;
    })(TextDocumentSaveReason || (exports.TextDocumentSaveReason = TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification;
    (function(WillSaveTextDocumentNotification2) {
      WillSaveTextDocumentNotification2.method = "textDocument/willSave";
      WillSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
    })(WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest;
    (function(WillSaveTextDocumentWaitUntilRequest2) {
      WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
    })(WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification;
    (function(DidChangeWatchedFilesNotification2) {
      DidChangeWatchedFilesNotification2.method = "workspace/didChangeWatchedFiles";
      DidChangeWatchedFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification2.method);
    })(DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
    var FileChangeType;
    (function(FileChangeType2) {
      FileChangeType2.Created = 1;
      FileChangeType2.Changed = 2;
      FileChangeType2.Deleted = 3;
    })(FileChangeType || (exports.FileChangeType = FileChangeType = {}));
    var RelativePattern;
    (function(RelativePattern2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
      }
      RelativePattern2.is = is;
    })(RelativePattern || (exports.RelativePattern = RelativePattern = {}));
    var WatchKind;
    (function(WatchKind2) {
      WatchKind2.Create = 1;
      WatchKind2.Change = 2;
      WatchKind2.Delete = 4;
    })(WatchKind || (exports.WatchKind = WatchKind = {}));
    var PublishDiagnosticsNotification;
    (function(PublishDiagnosticsNotification2) {
      PublishDiagnosticsNotification2.method = "textDocument/publishDiagnostics";
      PublishDiagnosticsNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification2.method);
    })(PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind;
    (function(CompletionTriggerKind2) {
      CompletionTriggerKind2.Invoked = 1;
      CompletionTriggerKind2.TriggerCharacter = 2;
      CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind || (exports.CompletionTriggerKind = CompletionTriggerKind = {}));
    var CompletionRequest;
    (function(CompletionRequest2) {
      CompletionRequest2.method = "textDocument/completion";
      CompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    })(CompletionRequest || (exports.CompletionRequest = CompletionRequest = {}));
    var CompletionResolveRequest;
    (function(CompletionResolveRequest2) {
      CompletionResolveRequest2.method = "completionItem/resolve";
      CompletionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
    })(CompletionResolveRequest || (exports.CompletionResolveRequest = CompletionResolveRequest = {}));
    var HoverRequest;
    (function(HoverRequest2) {
      HoverRequest2.method = "textDocument/hover";
      HoverRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
    })(HoverRequest || (exports.HoverRequest = HoverRequest = {}));
    var SignatureHelpTriggerKind;
    (function(SignatureHelpTriggerKind2) {
      SignatureHelpTriggerKind2.Invoked = 1;
      SignatureHelpTriggerKind2.TriggerCharacter = 2;
      SignatureHelpTriggerKind2.ContentChange = 3;
    })(SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest;
    (function(SignatureHelpRequest2) {
      SignatureHelpRequest2.method = "textDocument/signatureHelp";
      SignatureHelpRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
    })(SignatureHelpRequest || (exports.SignatureHelpRequest = SignatureHelpRequest = {}));
    var DefinitionRequest;
    (function(DefinitionRequest2) {
      DefinitionRequest2.method = "textDocument/definition";
      DefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    })(DefinitionRequest || (exports.DefinitionRequest = DefinitionRequest = {}));
    var ReferencesRequest;
    (function(ReferencesRequest2) {
      ReferencesRequest2.method = "textDocument/references";
      ReferencesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    })(ReferencesRequest || (exports.ReferencesRequest = ReferencesRequest = {}));
    var DocumentHighlightRequest;
    (function(DocumentHighlightRequest2) {
      DocumentHighlightRequest2.method = "textDocument/documentHighlight";
      DocumentHighlightRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    })(DocumentHighlightRequest || (exports.DocumentHighlightRequest = DocumentHighlightRequest = {}));
    var DocumentSymbolRequest;
    (function(DocumentSymbolRequest2) {
      DocumentSymbolRequest2.method = "textDocument/documentSymbol";
      DocumentSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    })(DocumentSymbolRequest || (exports.DocumentSymbolRequest = DocumentSymbolRequest = {}));
    var CodeActionRequest;
    (function(CodeActionRequest2) {
      CodeActionRequest2.method = "textDocument/codeAction";
      CodeActionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
    })(CodeActionRequest || (exports.CodeActionRequest = CodeActionRequest = {}));
    var CodeActionResolveRequest;
    (function(CodeActionResolveRequest2) {
      CodeActionResolveRequest2.method = "codeAction/resolve";
      CodeActionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
    })(CodeActionResolveRequest || (exports.CodeActionResolveRequest = CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest;
    (function(WorkspaceSymbolRequest2) {
      WorkspaceSymbolRequest2.method = "workspace/symbol";
      WorkspaceSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    })(WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
    var WorkspaceSymbolResolveRequest;
    (function(WorkspaceSymbolResolveRequest2) {
      WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
      WorkspaceSymbolResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
    })(WorkspaceSymbolResolveRequest || (exports.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
    var CodeLensRequest;
    (function(CodeLensRequest2) {
      CodeLensRequest2.method = "textDocument/codeLens";
      CodeLensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
    })(CodeLensRequest || (exports.CodeLensRequest = CodeLensRequest = {}));
    var CodeLensResolveRequest;
    (function(CodeLensResolveRequest2) {
      CodeLensResolveRequest2.method = "codeLens/resolve";
      CodeLensResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
    })(CodeLensResolveRequest || (exports.CodeLensResolveRequest = CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest;
    (function(CodeLensRefreshRequest2) {
      CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
    })(CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
    var DocumentLinkRequest;
    (function(DocumentLinkRequest2) {
      DocumentLinkRequest2.method = "textDocument/documentLink";
      DocumentLinkRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    })(DocumentLinkRequest || (exports.DocumentLinkRequest = DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest;
    (function(DocumentLinkResolveRequest2) {
      DocumentLinkResolveRequest2.method = "documentLink/resolve";
      DocumentLinkResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
    })(DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest;
    (function(DocumentFormattingRequest2) {
      DocumentFormattingRequest2.method = "textDocument/formatting";
      DocumentFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
    })(DocumentFormattingRequest || (exports.DocumentFormattingRequest = DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest;
    (function(DocumentRangeFormattingRequest2) {
      DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
    })(DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
    var DocumentRangesFormattingRequest;
    (function(DocumentRangesFormattingRequest2) {
      DocumentRangesFormattingRequest2.method = "textDocument/rangesFormatting";
      DocumentRangesFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangesFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest2.method);
    })(DocumentRangesFormattingRequest || (exports.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest;
    (function(DocumentOnTypeFormattingRequest2) {
      DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
    })(DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior;
    (function(PrepareSupportDefaultBehavior2) {
      PrepareSupportDefaultBehavior2.Identifier = 1;
    })(PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
    var RenameRequest;
    (function(RenameRequest2) {
      RenameRequest2.method = "textDocument/rename";
      RenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
    })(RenameRequest || (exports.RenameRequest = RenameRequest = {}));
    var PrepareRenameRequest;
    (function(PrepareRenameRequest2) {
      PrepareRenameRequest2.method = "textDocument/prepareRename";
      PrepareRenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
    })(PrepareRenameRequest || (exports.PrepareRenameRequest = PrepareRenameRequest = {}));
    var ExecuteCommandRequest;
    (function(ExecuteCommandRequest2) {
      ExecuteCommandRequest2.method = "workspace/executeCommand";
      ExecuteCommandRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest2.method);
    })(ExecuteCommandRequest || (exports.ExecuteCommandRequest = ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest;
    (function(ApplyWorkspaceEditRequest2) {
      ApplyWorkspaceEditRequest2.method = "workspace/applyEdit";
      ApplyWorkspaceEditRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection(input, output, logger, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
    }
    exports.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding2(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
    __exportStar2(require_main(), exports);
    __exportStar2(require_main2(), exports);
    __exportStar2(require_messages2(), exports);
    __exportStar2(require_protocol(), exports);
    var connection_1 = require_connection2();
    Object.defineProperty(exports, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes;
    (function(LSPErrorCodes2) {
      LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes2.RequestFailed = -32803;
      LSPErrorCodes2.ServerCancelled = -32802;
      LSPErrorCodes2.ContentModified = -32801;
      LSPErrorCodes2.RequestCancelled = -32800;
      LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes || (exports.LSPErrorCodes = LSPErrorCodes = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/node/main.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding2(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProtocolConnection = void 0;
    var node_1 = require_node();
    __exportStar2(require_node(), exports);
    __exportStar2(require_api2(), exports);
    function createProtocolConnection(input, output, logger, options) {
      return (0, node_1.createMessageConnection)(input, output, logger, options);
    }
    exports.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageclient/lib/common/utils/async.js
var require_async = __commonJS({
  "node_modules/vscode-languageclient/lib/common/utils/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.forEach = exports.mapAsync = exports.map = exports.clearTestMode = exports.setTestMode = exports.Semaphore = exports.Delayer = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Delayer = class {
      constructor(defaultDelay) {
        this.defaultDelay = defaultDelay;
        this.timeout = void 0;
        this.completionPromise = void 0;
        this.onSuccess = void 0;
        this.task = void 0;
      }
      trigger(task, delay = this.defaultDelay) {
        this.task = task;
        if (delay >= 0) {
          this.cancelTimeout();
        }
        if (!this.completionPromise) {
          this.completionPromise = new Promise((resolve) => {
            this.onSuccess = resolve;
          }).then(() => {
            this.completionPromise = void 0;
            this.onSuccess = void 0;
            var result = this.task();
            this.task = void 0;
            return result;
          });
        }
        if (delay >= 0 || this.timeout === void 0) {
          this.timeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
            this.timeout = void 0;
            this.onSuccess(void 0);
          }, delay >= 0 ? delay : this.defaultDelay);
        }
        return this.completionPromise;
      }
      forceDelivery() {
        if (!this.completionPromise) {
          return void 0;
        }
        this.cancelTimeout();
        let result = this.task();
        this.completionPromise = void 0;
        this.onSuccess = void 0;
        this.task = void 0;
        return result;
      }
      isTriggered() {
        return this.timeout !== void 0;
      }
      cancel() {
        this.cancelTimeout();
        this.completionPromise = void 0;
      }
      cancelTimeout() {
        if (this.timeout !== void 0) {
          this.timeout.dispose();
          this.timeout = void 0;
        }
      }
    };
    exports.Delayer = Delayer;
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve, reject) => {
          this._waiting.push({ thunk, resolve, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports.Semaphore = Semaphore;
    var $test = false;
    function setTestMode() {
      $test = true;
    }
    exports.setTestMode = setTestMode;
    function clearTestMode() {
      $test = false;
    }
    exports.clearTestMode = clearTestMode;
    var defaultYieldTimeout = 15;
    var Timer = class {
      constructor(yieldAfter = defaultYieldTimeout) {
        this.yieldAfter = $test === true ? Math.max(yieldAfter, 2) : Math.max(yieldAfter, defaultYieldTimeout);
        this.startTime = Date.now();
        this.counter = 0;
        this.total = 0;
        this.counterInterval = 1;
      }
      start() {
        this.counter = 0;
        this.total = 0;
        this.counterInterval = 1;
        this.startTime = Date.now();
      }
      shouldYield() {
        if (++this.counter >= this.counterInterval) {
          const timeTaken = Date.now() - this.startTime;
          const timeLeft = Math.max(0, this.yieldAfter - timeTaken);
          this.total += this.counter;
          this.counter = 0;
          if (timeTaken >= this.yieldAfter || timeLeft <= 1) {
            this.counterInterval = 1;
            this.total = 0;
            return true;
          } else {
            switch (timeTaken) {
              case 0:
              case 1:
                this.counterInterval = this.total * 2;
                break;
            }
          }
        }
        return false;
      }
    };
    async function map(items, func, token, options) {
      if (items.length === 0) {
        return [];
      }
      const result = new Array(items.length);
      const timer = new Timer(options?.yieldAfter);
      function convertBatch(start) {
        timer.start();
        for (let i = start; i < items.length; i++) {
          result[i] = func(items[i]);
          if (timer.shouldYield()) {
            options?.yieldCallback && options.yieldCallback();
            return i + 1;
          }
        }
        return -1;
      }
      let index = convertBatch(0);
      while (index !== -1) {
        if (token !== void 0 && token.isCancellationRequested) {
          break;
        }
        index = await new Promise((resolve) => {
          (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
            resolve(convertBatch(index));
          });
        });
      }
      return result;
    }
    exports.map = map;
    async function mapAsync(items, func, token, options) {
      if (items.length === 0) {
        return [];
      }
      const result = new Array(items.length);
      const timer = new Timer(options?.yieldAfter);
      async function convertBatch(start) {
        timer.start();
        for (let i = start; i < items.length; i++) {
          result[i] = await func(items[i], token);
          if (timer.shouldYield()) {
            options?.yieldCallback && options.yieldCallback();
            return i + 1;
          }
        }
        return -1;
      }
      let index = await convertBatch(0);
      while (index !== -1) {
        if (token !== void 0 && token.isCancellationRequested) {
          break;
        }
        index = await new Promise((resolve) => {
          (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
            resolve(convertBatch(index));
          });
        });
      }
      return result;
    }
    exports.mapAsync = mapAsync;
    async function forEach(items, func, token, options) {
      if (items.length === 0) {
        return;
      }
      const timer = new Timer(options?.yieldAfter);
      function runBatch(start) {
        timer.start();
        for (let i = start; i < items.length; i++) {
          func(items[i]);
          if (timer.shouldYield()) {
            options?.yieldCallback && options.yieldCallback();
            return i + 1;
          }
        }
        return -1;
      }
      let index = runBatch(0);
      while (index !== -1) {
        if (token !== void 0 && token.isCancellationRequested) {
          break;
        }
        index = await new Promise((resolve) => {
          (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
            resolve(runBatch(index));
          });
        });
      }
    }
    exports.forEach = forEach;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolCompletionItem.js
var require_protocolCompletionItem = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolCompletionItem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code = require("vscode");
    var ProtocolCompletionItem = class extends code.CompletionItem {
      constructor(label) {
        super(label);
      }
    };
    exports.default = ProtocolCompletionItem;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolCodeLens.js
var require_protocolCodeLens = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolCodeLens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code = require("vscode");
    var ProtocolCodeLens = class extends code.CodeLens {
      constructor(range) {
        super(range);
      }
    };
    exports.default = ProtocolCodeLens;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolDocumentLink.js
var require_protocolDocumentLink = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolDocumentLink.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code = require("vscode");
    var ProtocolDocumentLink = class extends code.DocumentLink {
      constructor(range, target) {
        super(range, target);
      }
    };
    exports.default = ProtocolDocumentLink;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolCodeAction.js
var require_protocolCodeAction = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolCodeAction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vscode10 = require("vscode");
    var ProtocolCodeAction = class extends vscode10.CodeAction {
      constructor(title, data) {
        super(title);
        this.data = data;
      }
    };
    exports.default = ProtocolCodeAction;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolDiagnostic.js
var require_protocolDiagnostic = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolDiagnostic.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtocolDiagnostic = exports.DiagnosticCode = void 0;
    var vscode10 = require("vscode");
    var Is = require_is();
    var DiagnosticCode;
    (function(DiagnosticCode2) {
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && (Is.number(candidate.value) || Is.string(candidate.value)) && Is.string(candidate.target);
      }
      DiagnosticCode2.is = is;
    })(DiagnosticCode || (exports.DiagnosticCode = DiagnosticCode = {}));
    var ProtocolDiagnostic = class extends vscode10.Diagnostic {
      constructor(range, message, severity, data) {
        super(range, message, severity);
        this.data = data;
        this.hasDiagnosticCode = false;
      }
    };
    exports.ProtocolDiagnostic = ProtocolDiagnostic;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolCallHierarchyItem.js
var require_protocolCallHierarchyItem = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolCallHierarchyItem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code = require("vscode");
    var ProtocolCallHierarchyItem = class extends code.CallHierarchyItem {
      constructor(kind, name, detail, uri, range, selectionRange, data) {
        super(kind, name, detail, uri, range, selectionRange);
        if (data !== void 0) {
          this.data = data;
        }
      }
    };
    exports.default = ProtocolCallHierarchyItem;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolTypeHierarchyItem.js
var require_protocolTypeHierarchyItem = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolTypeHierarchyItem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code = require("vscode");
    var ProtocolTypeHierarchyItem = class extends code.TypeHierarchyItem {
      constructor(kind, name, detail, uri, range, selectionRange, data) {
        super(kind, name, detail, uri, range, selectionRange);
        if (data !== void 0) {
          this.data = data;
        }
      }
    };
    exports.default = ProtocolTypeHierarchyItem;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolWorkspaceSymbol.js
var require_protocolWorkspaceSymbol = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolWorkspaceSymbol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code = require("vscode");
    var WorkspaceSymbol = class extends code.SymbolInformation {
      constructor(name, kind, containerName, locationOrUri, data) {
        const hasRange = !(locationOrUri instanceof code.Uri);
        super(name, kind, containerName, hasRange ? locationOrUri : new code.Location(locationOrUri, new code.Range(0, 0, 0, 0)));
        this.hasRange = hasRange;
        if (data !== void 0) {
          this.data = data;
        }
      }
    };
    exports.default = WorkspaceSymbol;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolInlayHint.js
var require_protocolInlayHint = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolInlayHint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code = require("vscode");
    var ProtocolInlayHint = class extends code.InlayHint {
      constructor(position, label, kind) {
        super(position, label, kind);
      }
    };
    exports.default = ProtocolInlayHint;
  }
});

// node_modules/vscode-languageclient/lib/common/codeConverter.js
var require_codeConverter = __commonJS({
  "node_modules/vscode-languageclient/lib/common/codeConverter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConverter = void 0;
    var code = require("vscode");
    var proto = require_main3();
    var Is = require_is();
    var async = require_async();
    var protocolCompletionItem_1 = require_protocolCompletionItem();
    var protocolCodeLens_1 = require_protocolCodeLens();
    var protocolDocumentLink_1 = require_protocolDocumentLink();
    var protocolCodeAction_1 = require_protocolCodeAction();
    var protocolDiagnostic_1 = require_protocolDiagnostic();
    var protocolCallHierarchyItem_1 = require_protocolCallHierarchyItem();
    var protocolTypeHierarchyItem_1 = require_protocolTypeHierarchyItem();
    var protocolWorkspaceSymbol_1 = require_protocolWorkspaceSymbol();
    var protocolInlayHint_1 = require_protocolInlayHint();
    var InsertReplaceRange;
    (function(InsertReplaceRange2) {
      function is(value) {
        const candidate = value;
        return candidate && !!candidate.inserting && !!candidate.replacing;
      }
      InsertReplaceRange2.is = is;
    })(InsertReplaceRange || (InsertReplaceRange = {}));
    function createConverter(uriConverter) {
      const nullConverter = (value) => value.toString();
      const _uriConverter = uriConverter || nullConverter;
      function asUri(value) {
        return _uriConverter(value);
      }
      function asTextDocumentIdentifier(textDocument) {
        return {
          uri: _uriConverter(textDocument.uri)
        };
      }
      function asTextDocumentItem(textDocument) {
        return {
          uri: _uriConverter(textDocument.uri),
          languageId: textDocument.languageId,
          version: textDocument.version,
          text: textDocument.getText()
        };
      }
      function asVersionedTextDocumentIdentifier(textDocument) {
        return {
          uri: _uriConverter(textDocument.uri),
          version: textDocument.version
        };
      }
      function asOpenTextDocumentParams(textDocument) {
        return {
          textDocument: asTextDocumentItem(textDocument)
        };
      }
      function isTextDocumentChangeEvent(value) {
        const candidate = value;
        return !!candidate.document && !!candidate.contentChanges;
      }
      function isTextDocument(value) {
        const candidate = value;
        return !!candidate.uri && !!candidate.version;
      }
      function asChangeTextDocumentParams(arg0, arg1, arg2) {
        if (isTextDocument(arg0)) {
          const result = {
            textDocument: {
              uri: _uriConverter(arg0.uri),
              version: arg0.version
            },
            contentChanges: [{ text: arg0.getText() }]
          };
          return result;
        } else if (isTextDocumentChangeEvent(arg0)) {
          const uri = arg1;
          const version = arg2;
          const result = {
            textDocument: {
              uri: _uriConverter(uri),
              version
            },
            contentChanges: arg0.contentChanges.map((change) => {
              const range = change.range;
              return {
                range: {
                  start: { line: range.start.line, character: range.start.character },
                  end: { line: range.end.line, character: range.end.character }
                },
                rangeLength: change.rangeLength,
                text: change.text
              };
            })
          };
          return result;
        } else {
          throw Error("Unsupported text document change parameter");
        }
      }
      function asCloseTextDocumentParams(textDocument) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument)
        };
      }
      function asSaveTextDocumentParams(textDocument, includeContent = false) {
        let result = {
          textDocument: asTextDocumentIdentifier(textDocument)
        };
        if (includeContent) {
          result.text = textDocument.getText();
        }
        return result;
      }
      function asTextDocumentSaveReason(reason) {
        switch (reason) {
          case code.TextDocumentSaveReason.Manual:
            return proto.TextDocumentSaveReason.Manual;
          case code.TextDocumentSaveReason.AfterDelay:
            return proto.TextDocumentSaveReason.AfterDelay;
          case code.TextDocumentSaveReason.FocusOut:
            return proto.TextDocumentSaveReason.FocusOut;
        }
        return proto.TextDocumentSaveReason.Manual;
      }
      function asWillSaveTextDocumentParams(event) {
        return {
          textDocument: asTextDocumentIdentifier(event.document),
          reason: asTextDocumentSaveReason(event.reason)
        };
      }
      function asDidCreateFilesParams(event) {
        return {
          files: event.files.map((fileUri) => ({
            uri: _uriConverter(fileUri)
          }))
        };
      }
      function asDidRenameFilesParams(event) {
        return {
          files: event.files.map((file) => ({
            oldUri: _uriConverter(file.oldUri),
            newUri: _uriConverter(file.newUri)
          }))
        };
      }
      function asDidDeleteFilesParams(event) {
        return {
          files: event.files.map((fileUri) => ({
            uri: _uriConverter(fileUri)
          }))
        };
      }
      function asWillCreateFilesParams(event) {
        return {
          files: event.files.map((fileUri) => ({
            uri: _uriConverter(fileUri)
          }))
        };
      }
      function asWillRenameFilesParams(event) {
        return {
          files: event.files.map((file) => ({
            oldUri: _uriConverter(file.oldUri),
            newUri: _uriConverter(file.newUri)
          }))
        };
      }
      function asWillDeleteFilesParams(event) {
        return {
          files: event.files.map((fileUri) => ({
            uri: _uriConverter(fileUri)
          }))
        };
      }
      function asTextDocumentPositionParams(textDocument, position) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument),
          position: asWorkerPosition(position)
        };
      }
      function asCompletionTriggerKind(triggerKind) {
        switch (triggerKind) {
          case code.CompletionTriggerKind.TriggerCharacter:
            return proto.CompletionTriggerKind.TriggerCharacter;
          case code.CompletionTriggerKind.TriggerForIncompleteCompletions:
            return proto.CompletionTriggerKind.TriggerForIncompleteCompletions;
          default:
            return proto.CompletionTriggerKind.Invoked;
        }
      }
      function asCompletionParams(textDocument, position, context) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument),
          position: asWorkerPosition(position),
          context: {
            triggerKind: asCompletionTriggerKind(context.triggerKind),
            triggerCharacter: context.triggerCharacter
          }
        };
      }
      function asSignatureHelpTriggerKind(triggerKind) {
        switch (triggerKind) {
          case code.SignatureHelpTriggerKind.Invoke:
            return proto.SignatureHelpTriggerKind.Invoked;
          case code.SignatureHelpTriggerKind.TriggerCharacter:
            return proto.SignatureHelpTriggerKind.TriggerCharacter;
          case code.SignatureHelpTriggerKind.ContentChange:
            return proto.SignatureHelpTriggerKind.ContentChange;
        }
      }
      function asParameterInformation(value) {
        return {
          label: value.label
        };
      }
      function asParameterInformations(values) {
        return values.map(asParameterInformation);
      }
      function asSignatureInformation(value) {
        return {
          label: value.label,
          parameters: asParameterInformations(value.parameters)
        };
      }
      function asSignatureInformations(values) {
        return values.map(asSignatureInformation);
      }
      function asSignatureHelp(value) {
        if (value === void 0) {
          return value;
        }
        return {
          signatures: asSignatureInformations(value.signatures),
          activeSignature: value.activeSignature,
          activeParameter: value.activeParameter
        };
      }
      function asSignatureHelpParams(textDocument, position, context) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument),
          position: asWorkerPosition(position),
          context: {
            isRetrigger: context.isRetrigger,
            triggerCharacter: context.triggerCharacter,
            triggerKind: asSignatureHelpTriggerKind(context.triggerKind),
            activeSignatureHelp: asSignatureHelp(context.activeSignatureHelp)
          }
        };
      }
      function asWorkerPosition(position) {
        return { line: position.line, character: position.character };
      }
      function asPosition(value) {
        if (value === void 0 || value === null) {
          return value;
        }
        return { line: value.line > proto.uinteger.MAX_VALUE ? proto.uinteger.MAX_VALUE : value.line, character: value.character > proto.uinteger.MAX_VALUE ? proto.uinteger.MAX_VALUE : value.character };
      }
      function asPositions(values, token) {
        return async.map(values, asPosition, token);
      }
      function asPositionsSync(values) {
        return values.map(asPosition);
      }
      function asRange(value) {
        if (value === void 0 || value === null) {
          return value;
        }
        return { start: asPosition(value.start), end: asPosition(value.end) };
      }
      function asRanges(values) {
        return values.map(asRange);
      }
      function asLocation(value) {
        if (value === void 0 || value === null) {
          return value;
        }
        return proto.Location.create(asUri(value.uri), asRange(value.range));
      }
      function asDiagnosticSeverity(value) {
        switch (value) {
          case code.DiagnosticSeverity.Error:
            return proto.DiagnosticSeverity.Error;
          case code.DiagnosticSeverity.Warning:
            return proto.DiagnosticSeverity.Warning;
          case code.DiagnosticSeverity.Information:
            return proto.DiagnosticSeverity.Information;
          case code.DiagnosticSeverity.Hint:
            return proto.DiagnosticSeverity.Hint;
        }
      }
      function asDiagnosticTags(tags) {
        if (!tags) {
          return void 0;
        }
        let result = [];
        for (let tag of tags) {
          let converted = asDiagnosticTag(tag);
          if (converted !== void 0) {
            result.push(converted);
          }
        }
        return result.length > 0 ? result : void 0;
      }
      function asDiagnosticTag(tag) {
        switch (tag) {
          case code.DiagnosticTag.Unnecessary:
            return proto.DiagnosticTag.Unnecessary;
          case code.DiagnosticTag.Deprecated:
            return proto.DiagnosticTag.Deprecated;
          default:
            return void 0;
        }
      }
      function asRelatedInformation(item) {
        return {
          message: item.message,
          location: asLocation(item.location)
        };
      }
      function asRelatedInformations(items) {
        return items.map(asRelatedInformation);
      }
      function asDiagnosticCode(value) {
        if (value === void 0 || value === null) {
          return void 0;
        }
        if (Is.number(value) || Is.string(value)) {
          return value;
        }
        return { value: value.value, target: asUri(value.target) };
      }
      function asDiagnostic(item) {
        const result = proto.Diagnostic.create(asRange(item.range), item.message);
        const protocolDiagnostic = item instanceof protocolDiagnostic_1.ProtocolDiagnostic ? item : void 0;
        if (protocolDiagnostic !== void 0 && protocolDiagnostic.data !== void 0) {
          result.data = protocolDiagnostic.data;
        }
        const code2 = asDiagnosticCode(item.code);
        if (protocolDiagnostic_1.DiagnosticCode.is(code2)) {
          if (protocolDiagnostic !== void 0 && protocolDiagnostic.hasDiagnosticCode) {
            result.code = code2;
          } else {
            result.code = code2.value;
            result.codeDescription = { href: code2.target };
          }
        } else {
          result.code = code2;
        }
        if (Is.number(item.severity)) {
          result.severity = asDiagnosticSeverity(item.severity);
        }
        if (Array.isArray(item.tags)) {
          result.tags = asDiagnosticTags(item.tags);
        }
        if (item.relatedInformation) {
          result.relatedInformation = asRelatedInformations(item.relatedInformation);
        }
        if (item.source) {
          result.source = item.source;
        }
        return result;
      }
      function asDiagnostics(items, token) {
        if (items === void 0 || items === null) {
          return items;
        }
        return async.map(items, asDiagnostic, token);
      }
      function asDiagnosticsSync(items) {
        if (items === void 0 || items === null) {
          return items;
        }
        return items.map(asDiagnostic);
      }
      function asDocumentation(format, documentation) {
        switch (format) {
          case "$string":
            return documentation;
          case proto.MarkupKind.PlainText:
            return { kind: format, value: documentation };
          case proto.MarkupKind.Markdown:
            return { kind: format, value: documentation.value };
          default:
            return `Unsupported Markup content received. Kind is: ${format}`;
        }
      }
      function asCompletionItemTag(tag) {
        switch (tag) {
          case code.CompletionItemTag.Deprecated:
            return proto.CompletionItemTag.Deprecated;
        }
        return void 0;
      }
      function asCompletionItemTags(tags) {
        if (tags === void 0) {
          return tags;
        }
        const result = [];
        for (let tag of tags) {
          const converted = asCompletionItemTag(tag);
          if (converted !== void 0) {
            result.push(converted);
          }
        }
        return result;
      }
      function asCompletionItemKind(value, original) {
        if (original !== void 0) {
          return original;
        }
        return value + 1;
      }
      function asCompletionItem(item, labelDetailsSupport = false) {
        let label;
        let labelDetails;
        if (Is.string(item.label)) {
          label = item.label;
        } else {
          label = item.label.label;
          if (labelDetailsSupport && (item.label.detail !== void 0 || item.label.description !== void 0)) {
            labelDetails = { detail: item.label.detail, description: item.label.description };
          }
        }
        let result = { label };
        if (labelDetails !== void 0) {
          result.labelDetails = labelDetails;
        }
        let protocolItem = item instanceof protocolCompletionItem_1.default ? item : void 0;
        if (item.detail) {
          result.detail = item.detail;
        }
        if (item.documentation) {
          if (!protocolItem || protocolItem.documentationFormat === "$string") {
            result.documentation = item.documentation;
          } else {
            result.documentation = asDocumentation(protocolItem.documentationFormat, item.documentation);
          }
        }
        if (item.filterText) {
          result.filterText = item.filterText;
        }
        fillPrimaryInsertText(result, item);
        if (Is.number(item.kind)) {
          result.kind = asCompletionItemKind(item.kind, protocolItem && protocolItem.originalItemKind);
        }
        if (item.sortText) {
          result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
          result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
        }
        if (item.commitCharacters) {
          result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
          result.command = asCommand(item.command);
        }
        if (item.preselect === true || item.preselect === false) {
          result.preselect = item.preselect;
        }
        const tags = asCompletionItemTags(item.tags);
        if (protocolItem) {
          if (protocolItem.data !== void 0) {
            result.data = protocolItem.data;
          }
          if (protocolItem.deprecated === true || protocolItem.deprecated === false) {
            if (protocolItem.deprecated === true && tags !== void 0 && tags.length > 0) {
              const index = tags.indexOf(code.CompletionItemTag.Deprecated);
              if (index !== -1) {
                tags.splice(index, 1);
              }
            }
            result.deprecated = protocolItem.deprecated;
          }
          if (protocolItem.insertTextMode !== void 0) {
            result.insertTextMode = protocolItem.insertTextMode;
          }
        }
        if (tags !== void 0 && tags.length > 0) {
          result.tags = tags;
        }
        if (result.insertTextMode === void 0 && item.keepWhitespace === true) {
          result.insertTextMode = proto.InsertTextMode.adjustIndentation;
        }
        return result;
      }
      function fillPrimaryInsertText(target, source) {
        let format = proto.InsertTextFormat.PlainText;
        let text = void 0;
        let range = void 0;
        if (source.textEdit) {
          text = source.textEdit.newText;
          range = source.textEdit.range;
        } else if (source.insertText instanceof code.SnippetString) {
          format = proto.InsertTextFormat.Snippet;
          text = source.insertText.value;
        } else {
          text = source.insertText;
        }
        if (source.range) {
          range = source.range;
        }
        target.insertTextFormat = format;
        if (source.fromEdit && text !== void 0 && range !== void 0) {
          target.textEdit = asCompletionTextEdit(text, range);
        } else {
          target.insertText = text;
        }
      }
      function asCompletionTextEdit(newText, range) {
        if (InsertReplaceRange.is(range)) {
          return proto.InsertReplaceEdit.create(newText, asRange(range.inserting), asRange(range.replacing));
        } else {
          return { newText, range: asRange(range) };
        }
      }
      function asTextEdit(edit) {
        return { range: asRange(edit.range), newText: edit.newText };
      }
      function asTextEdits(edits) {
        if (edits === void 0 || edits === null) {
          return edits;
        }
        return edits.map(asTextEdit);
      }
      function asSymbolKind(item) {
        if (item <= code.SymbolKind.TypeParameter) {
          return item + 1;
        }
        return proto.SymbolKind.Property;
      }
      function asSymbolTag(item) {
        return item;
      }
      function asSymbolTags(items) {
        return items.map(asSymbolTag);
      }
      function asReferenceParams(textDocument, position, options) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument),
          position: asWorkerPosition(position),
          context: { includeDeclaration: options.includeDeclaration }
        };
      }
      async function asCodeAction(item, token) {
        let result = proto.CodeAction.create(item.title);
        if (item instanceof protocolCodeAction_1.default && item.data !== void 0) {
          result.data = item.data;
        }
        if (item.kind !== void 0) {
          result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== void 0) {
          result.diagnostics = await asDiagnostics(item.diagnostics, token);
        }
        if (item.edit !== void 0) {
          throw new Error(`VS Code code actions can only be converted to a protocol code action without an edit.`);
        }
        if (item.command !== void 0) {
          result.command = asCommand(item.command);
        }
        if (item.isPreferred !== void 0) {
          result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== void 0) {
          result.disabled = { reason: item.disabled.reason };
        }
        return result;
      }
      function asCodeActionSync(item) {
        let result = proto.CodeAction.create(item.title);
        if (item instanceof protocolCodeAction_1.default && item.data !== void 0) {
          result.data = item.data;
        }
        if (item.kind !== void 0) {
          result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== void 0) {
          result.diagnostics = asDiagnosticsSync(item.diagnostics);
        }
        if (item.edit !== void 0) {
          throw new Error(`VS Code code actions can only be converted to a protocol code action without an edit.`);
        }
        if (item.command !== void 0) {
          result.command = asCommand(item.command);
        }
        if (item.isPreferred !== void 0) {
          result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== void 0) {
          result.disabled = { reason: item.disabled.reason };
        }
        return result;
      }
      async function asCodeActionContext(context, token) {
        if (context === void 0 || context === null) {
          return context;
        }
        let only;
        if (context.only && Is.string(context.only.value)) {
          only = [context.only.value];
        }
        return proto.CodeActionContext.create(await asDiagnostics(context.diagnostics, token), only, asCodeActionTriggerKind(context.triggerKind));
      }
      function asCodeActionContextSync(context) {
        if (context === void 0 || context === null) {
          return context;
        }
        let only;
        if (context.only && Is.string(context.only.value)) {
          only = [context.only.value];
        }
        return proto.CodeActionContext.create(asDiagnosticsSync(context.diagnostics), only, asCodeActionTriggerKind(context.triggerKind));
      }
      function asCodeActionTriggerKind(kind) {
        switch (kind) {
          case code.CodeActionTriggerKind.Invoke:
            return proto.CodeActionTriggerKind.Invoked;
          case code.CodeActionTriggerKind.Automatic:
            return proto.CodeActionTriggerKind.Automatic;
          default:
            return void 0;
        }
      }
      function asCodeActionKind(item) {
        if (item === void 0 || item === null) {
          return void 0;
        }
        return item.value;
      }
      function asInlineValueContext(context) {
        if (context === void 0 || context === null) {
          return context;
        }
        return proto.InlineValueContext.create(context.frameId, asRange(context.stoppedLocation));
      }
      function asInlineCompletionParams(document, position, context) {
        return {
          context: proto.InlineCompletionContext.create(context.triggerKind, context.selectedCompletionInfo),
          textDocument: asTextDocumentIdentifier(document),
          position: asPosition(position)
        };
      }
      function asCommand(item) {
        let result = proto.Command.create(item.title, item.command);
        if (item.arguments) {
          result.arguments = item.arguments;
        }
        return result;
      }
      function asCodeLens(item) {
        let result = proto.CodeLens.create(asRange(item.range));
        if (item.command) {
          result.command = asCommand(item.command);
        }
        if (item instanceof protocolCodeLens_1.default) {
          if (item.data) {
            result.data = item.data;
          }
        }
        return result;
      }
      function asFormattingOptions(options, fileOptions) {
        const result = { tabSize: options.tabSize, insertSpaces: options.insertSpaces };
        if (fileOptions.trimTrailingWhitespace) {
          result.trimTrailingWhitespace = true;
        }
        if (fileOptions.trimFinalNewlines) {
          result.trimFinalNewlines = true;
        }
        if (fileOptions.insertFinalNewline) {
          result.insertFinalNewline = true;
        }
        return result;
      }
      function asDocumentSymbolParams(textDocument) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument)
        };
      }
      function asCodeLensParams(textDocument) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument)
        };
      }
      function asDocumentLink(item) {
        let result = proto.DocumentLink.create(asRange(item.range));
        if (item.target) {
          result.target = asUri(item.target);
        }
        if (item.tooltip !== void 0) {
          result.tooltip = item.tooltip;
        }
        let protocolItem = item instanceof protocolDocumentLink_1.default ? item : void 0;
        if (protocolItem && protocolItem.data) {
          result.data = protocolItem.data;
        }
        return result;
      }
      function asDocumentLinkParams(textDocument) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument)
        };
      }
      function asCallHierarchyItem(value) {
        const result = {
          name: value.name,
          kind: asSymbolKind(value.kind),
          uri: asUri(value.uri),
          range: asRange(value.range),
          selectionRange: asRange(value.selectionRange)
        };
        if (value.detail !== void 0 && value.detail.length > 0) {
          result.detail = value.detail;
        }
        if (value.tags !== void 0) {
          result.tags = asSymbolTags(value.tags);
        }
        if (value instanceof protocolCallHierarchyItem_1.default && value.data !== void 0) {
          result.data = value.data;
        }
        return result;
      }
      function asTypeHierarchyItem(value) {
        const result = {
          name: value.name,
          kind: asSymbolKind(value.kind),
          uri: asUri(value.uri),
          range: asRange(value.range),
          selectionRange: asRange(value.selectionRange)
        };
        if (value.detail !== void 0 && value.detail.length > 0) {
          result.detail = value.detail;
        }
        if (value.tags !== void 0) {
          result.tags = asSymbolTags(value.tags);
        }
        if (value instanceof protocolTypeHierarchyItem_1.default && value.data !== void 0) {
          result.data = value.data;
        }
        return result;
      }
      function asWorkspaceSymbol(item) {
        const result = item instanceof protocolWorkspaceSymbol_1.default ? { name: item.name, kind: asSymbolKind(item.kind), location: item.hasRange ? asLocation(item.location) : { uri: _uriConverter(item.location.uri) }, data: item.data } : { name: item.name, kind: asSymbolKind(item.kind), location: asLocation(item.location) };
        if (item.tags !== void 0) {
          result.tags = asSymbolTags(item.tags);
        }
        if (item.containerName !== "") {
          result.containerName = item.containerName;
        }
        return result;
      }
      function asInlayHint(item) {
        const label = typeof item.label === "string" ? item.label : item.label.map(asInlayHintLabelPart);
        const result = proto.InlayHint.create(asPosition(item.position), label);
        if (item.kind !== void 0) {
          result.kind = item.kind;
        }
        if (item.textEdits !== void 0) {
          result.textEdits = asTextEdits(item.textEdits);
        }
        if (item.tooltip !== void 0) {
          result.tooltip = asTooltip(item.tooltip);
        }
        if (item.paddingLeft !== void 0) {
          result.paddingLeft = item.paddingLeft;
        }
        if (item.paddingRight !== void 0) {
          result.paddingRight = item.paddingRight;
        }
        if (item instanceof protocolInlayHint_1.default && item.data !== void 0) {
          result.data = item.data;
        }
        return result;
      }
      function asInlayHintLabelPart(item) {
        const result = proto.InlayHintLabelPart.create(item.value);
        if (item.location !== void 0) {
          result.location = asLocation(item.location);
        }
        if (item.command !== void 0) {
          result.command = asCommand(item.command);
        }
        if (item.tooltip !== void 0) {
          result.tooltip = asTooltip(item.tooltip);
        }
        return result;
      }
      function asTooltip(value) {
        if (typeof value === "string") {
          return value;
        }
        const result = {
          kind: proto.MarkupKind.Markdown,
          value: value.value
        };
        return result;
      }
      return {
        asUri,
        asTextDocumentIdentifier,
        asTextDocumentItem,
        asVersionedTextDocumentIdentifier,
        asOpenTextDocumentParams,
        asChangeTextDocumentParams,
        asCloseTextDocumentParams,
        asSaveTextDocumentParams,
        asWillSaveTextDocumentParams,
        asDidCreateFilesParams,
        asDidRenameFilesParams,
        asDidDeleteFilesParams,
        asWillCreateFilesParams,
        asWillRenameFilesParams,
        asWillDeleteFilesParams,
        asTextDocumentPositionParams,
        asCompletionParams,
        asSignatureHelpParams,
        asWorkerPosition,
        asRange,
        asRanges,
        asPosition,
        asPositions,
        asPositionsSync,
        asLocation,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asDiagnostic,
        asDiagnostics,
        asDiagnosticsSync,
        asCompletionItem,
        asTextEdit,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asReferenceParams,
        asCodeAction,
        asCodeActionSync,
        asCodeActionContext,
        asCodeActionContextSync,
        asInlineValueContext,
        asCommand,
        asCodeLens,
        asFormattingOptions,
        asDocumentSymbolParams,
        asCodeLensParams,
        asDocumentLink,
        asDocumentLinkParams,
        asCallHierarchyItem,
        asTypeHierarchyItem,
        asInlayHint,
        asWorkspaceSymbol,
        asInlineCompletionParams
      };
    }
    exports.createConverter = createConverter;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolConverter.js
var require_protocolConverter = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolConverter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConverter = void 0;
    var code = require("vscode");
    var ls = require_main3();
    var Is = require_is();
    var async = require_async();
    var protocolCompletionItem_1 = require_protocolCompletionItem();
    var protocolCodeLens_1 = require_protocolCodeLens();
    var protocolDocumentLink_1 = require_protocolDocumentLink();
    var protocolCodeAction_1 = require_protocolCodeAction();
    var protocolDiagnostic_1 = require_protocolDiagnostic();
    var protocolCallHierarchyItem_1 = require_protocolCallHierarchyItem();
    var protocolTypeHierarchyItem_1 = require_protocolTypeHierarchyItem();
    var protocolWorkspaceSymbol_1 = require_protocolWorkspaceSymbol();
    var protocolInlayHint_1 = require_protocolInlayHint();
    var vscode_languageserver_protocol_1 = require_main3();
    var CodeBlock;
    (function(CodeBlock2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.string(candidate.language) && Is.string(candidate.value);
      }
      CodeBlock2.is = is;
    })(CodeBlock || (CodeBlock = {}));
    function createConverter(uriConverter, trustMarkdown, supportHtml) {
      const nullConverter = (value) => code.Uri.parse(value);
      const _uriConverter = uriConverter || nullConverter;
      function asUri(value) {
        return _uriConverter(value);
      }
      function asDocumentSelector(selector) {
        const result = [];
        for (const filter of selector) {
          if (typeof filter === "string") {
            result.push(filter);
          } else if (vscode_languageserver_protocol_1.NotebookCellTextDocumentFilter.is(filter)) {
            if (typeof filter.notebook === "string") {
              result.push({ notebookType: filter.notebook, language: filter.language });
            } else {
              const notebookType = filter.notebook.notebookType ?? "*";
              result.push({ notebookType, scheme: filter.notebook.scheme, pattern: filter.notebook.pattern, language: filter.language });
            }
          } else if (vscode_languageserver_protocol_1.TextDocumentFilter.is(filter)) {
            result.push({ language: filter.language, scheme: filter.scheme, pattern: filter.pattern });
          }
        }
        return result;
      }
      async function asDiagnostics(diagnostics, token) {
        return async.map(diagnostics, asDiagnostic, token);
      }
      function asDiagnosticsSync(diagnostics) {
        const result = new Array(diagnostics.length);
        for (let i = 0; i < diagnostics.length; i++) {
          result[i] = asDiagnostic(diagnostics[i]);
        }
        return result;
      }
      function asDiagnostic(diagnostic) {
        let result = new protocolDiagnostic_1.ProtocolDiagnostic(asRange(diagnostic.range), diagnostic.message, asDiagnosticSeverity(diagnostic.severity), diagnostic.data);
        if (diagnostic.code !== void 0) {
          if (typeof diagnostic.code === "string" || typeof diagnostic.code === "number") {
            if (ls.CodeDescription.is(diagnostic.codeDescription)) {
              result.code = {
                value: diagnostic.code,
                target: asUri(diagnostic.codeDescription.href)
              };
            } else {
              result.code = diagnostic.code;
            }
          } else if (protocolDiagnostic_1.DiagnosticCode.is(diagnostic.code)) {
            result.hasDiagnosticCode = true;
            const diagnosticCode = diagnostic.code;
            result.code = {
              value: diagnosticCode.value,
              target: asUri(diagnosticCode.target)
            };
          }
        }
        if (diagnostic.source) {
          result.source = diagnostic.source;
        }
        if (diagnostic.relatedInformation) {
          result.relatedInformation = asRelatedInformation(diagnostic.relatedInformation);
        }
        if (Array.isArray(diagnostic.tags)) {
          result.tags = asDiagnosticTags(diagnostic.tags);
        }
        return result;
      }
      function asRelatedInformation(relatedInformation) {
        const result = new Array(relatedInformation.length);
        for (let i = 0; i < relatedInformation.length; i++) {
          const info = relatedInformation[i];
          result[i] = new code.DiagnosticRelatedInformation(asLocation(info.location), info.message);
        }
        return result;
      }
      function asDiagnosticTags(tags) {
        if (!tags) {
          return void 0;
        }
        let result = [];
        for (let tag of tags) {
          let converted = asDiagnosticTag(tag);
          if (converted !== void 0) {
            result.push(converted);
          }
        }
        return result.length > 0 ? result : void 0;
      }
      function asDiagnosticTag(tag) {
        switch (tag) {
          case ls.DiagnosticTag.Unnecessary:
            return code.DiagnosticTag.Unnecessary;
          case ls.DiagnosticTag.Deprecated:
            return code.DiagnosticTag.Deprecated;
          default:
            return void 0;
        }
      }
      function asPosition(value) {
        return value ? new code.Position(value.line, value.character) : void 0;
      }
      function asRange(value) {
        return value ? new code.Range(value.start.line, value.start.character, value.end.line, value.end.character) : void 0;
      }
      async function asRanges(items, token) {
        return async.map(items, (range) => {
          return new code.Range(range.start.line, range.start.character, range.end.line, range.end.character);
        }, token);
      }
      function asDiagnosticSeverity(value) {
        if (value === void 0 || value === null) {
          return code.DiagnosticSeverity.Error;
        }
        switch (value) {
          case ls.DiagnosticSeverity.Error:
            return code.DiagnosticSeverity.Error;
          case ls.DiagnosticSeverity.Warning:
            return code.DiagnosticSeverity.Warning;
          case ls.DiagnosticSeverity.Information:
            return code.DiagnosticSeverity.Information;
          case ls.DiagnosticSeverity.Hint:
            return code.DiagnosticSeverity.Hint;
        }
        return code.DiagnosticSeverity.Error;
      }
      function asHoverContent(value) {
        if (Is.string(value)) {
          return asMarkdownString(value);
        } else if (CodeBlock.is(value)) {
          let result = asMarkdownString();
          return result.appendCodeblock(value.value, value.language);
        } else if (Array.isArray(value)) {
          let result = [];
          for (let element of value) {
            let item = asMarkdownString();
            if (CodeBlock.is(element)) {
              item.appendCodeblock(element.value, element.language);
            } else {
              item.appendMarkdown(element);
            }
            result.push(item);
          }
          return result;
        } else {
          return asMarkdownString(value);
        }
      }
      function asDocumentation(value) {
        if (Is.string(value)) {
          return value;
        } else {
          switch (value.kind) {
            case ls.MarkupKind.Markdown:
              return asMarkdownString(value.value);
            case ls.MarkupKind.PlainText:
              return value.value;
            default:
              return `Unsupported Markup content received. Kind is: ${value.kind}`;
          }
        }
      }
      function asMarkdownString(value) {
        let result;
        if (value === void 0 || typeof value === "string") {
          result = new code.MarkdownString(value);
        } else {
          switch (value.kind) {
            case ls.MarkupKind.Markdown:
              result = new code.MarkdownString(value.value);
              break;
            case ls.MarkupKind.PlainText:
              result = new code.MarkdownString();
              result.appendText(value.value);
              break;
            default:
              result = new code.MarkdownString();
              result.appendText(`Unsupported Markup content received. Kind is: ${value.kind}`);
              break;
          }
        }
        result.isTrusted = trustMarkdown;
        result.supportHtml = supportHtml;
        return result;
      }
      function asHover(hover) {
        if (!hover) {
          return void 0;
        }
        return new code.Hover(asHoverContent(hover.contents), asRange(hover.range));
      }
      async function asCompletionResult(value, allCommitCharacters, token) {
        if (!value) {
          return void 0;
        }
        if (Array.isArray(value)) {
          return async.map(value, (item) => asCompletionItem(item, allCommitCharacters), token);
        }
        const list = value;
        const { defaultRange, commitCharacters } = getCompletionItemDefaults(list, allCommitCharacters);
        const converted = await async.map(list.items, (item) => {
          return asCompletionItem(item, commitCharacters, defaultRange, list.itemDefaults?.insertTextMode, list.itemDefaults?.insertTextFormat, list.itemDefaults?.data);
        }, token);
        return new code.CompletionList(converted, list.isIncomplete);
      }
      function getCompletionItemDefaults(list, allCommitCharacters) {
        const rangeDefaults = list.itemDefaults?.editRange;
        const commitCharacters = list.itemDefaults?.commitCharacters ?? allCommitCharacters;
        return ls.Range.is(rangeDefaults) ? { defaultRange: asRange(rangeDefaults), commitCharacters } : rangeDefaults !== void 0 ? { defaultRange: { inserting: asRange(rangeDefaults.insert), replacing: asRange(rangeDefaults.replace) }, commitCharacters } : { defaultRange: void 0, commitCharacters };
      }
      function asCompletionItemKind(value) {
        if (ls.CompletionItemKind.Text <= value && value <= ls.CompletionItemKind.TypeParameter) {
          return [value - 1, void 0];
        }
        return [code.CompletionItemKind.Text, value];
      }
      function asCompletionItemTag(tag) {
        switch (tag) {
          case ls.CompletionItemTag.Deprecated:
            return code.CompletionItemTag.Deprecated;
        }
        return void 0;
      }
      function asCompletionItemTags(tags) {
        if (tags === void 0 || tags === null) {
          return [];
        }
        const result = [];
        for (const tag of tags) {
          const converted = asCompletionItemTag(tag);
          if (converted !== void 0) {
            result.push(converted);
          }
        }
        return result;
      }
      function asCompletionItem(item, defaultCommitCharacters, defaultRange, defaultInsertTextMode, defaultInsertTextFormat, defaultData) {
        const tags = asCompletionItemTags(item.tags);
        const label = asCompletionItemLabel(item);
        const result = new protocolCompletionItem_1.default(label);
        if (item.detail) {
          result.detail = item.detail;
        }
        if (item.documentation) {
          result.documentation = asDocumentation(item.documentation);
          result.documentationFormat = Is.string(item.documentation) ? "$string" : item.documentation.kind;
        }
        if (item.filterText) {
          result.filterText = item.filterText;
        }
        const insertText = asCompletionInsertText(item, defaultRange, defaultInsertTextFormat);
        if (insertText) {
          result.insertText = insertText.text;
          result.range = insertText.range;
          result.fromEdit = insertText.fromEdit;
        }
        if (Is.number(item.kind)) {
          let [itemKind, original] = asCompletionItemKind(item.kind);
          result.kind = itemKind;
          if (original) {
            result.originalItemKind = original;
          }
        }
        if (item.sortText) {
          result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
          result.additionalTextEdits = asTextEditsSync(item.additionalTextEdits);
        }
        const commitCharacters = item.commitCharacters !== void 0 ? Is.stringArray(item.commitCharacters) ? item.commitCharacters : void 0 : defaultCommitCharacters;
        if (commitCharacters) {
          result.commitCharacters = commitCharacters.slice();
        }
        if (item.command) {
          result.command = asCommand(item.command);
        }
        if (item.deprecated === true || item.deprecated === false) {
          result.deprecated = item.deprecated;
          if (item.deprecated === true) {
            tags.push(code.CompletionItemTag.Deprecated);
          }
        }
        if (item.preselect === true || item.preselect === false) {
          result.preselect = item.preselect;
        }
        const data = item.data ?? defaultData;
        if (data !== void 0) {
          result.data = data;
        }
        if (tags.length > 0) {
          result.tags = tags;
        }
        const insertTextMode = item.insertTextMode ?? defaultInsertTextMode;
        if (insertTextMode !== void 0) {
          result.insertTextMode = insertTextMode;
          if (insertTextMode === ls.InsertTextMode.asIs) {
            result.keepWhitespace = true;
          }
        }
        return result;
      }
      function asCompletionItemLabel(item) {
        if (ls.CompletionItemLabelDetails.is(item.labelDetails)) {
          return {
            label: item.label,
            detail: item.labelDetails.detail,
            description: item.labelDetails.description
          };
        } else {
          return item.label;
        }
      }
      function asCompletionInsertText(item, defaultRange, defaultInsertTextFormat) {
        const insertTextFormat = item.insertTextFormat ?? defaultInsertTextFormat;
        if (item.textEdit !== void 0 || defaultRange !== void 0) {
          const [range, newText] = item.textEdit !== void 0 ? getCompletionRangeAndText(item.textEdit) : [defaultRange, item.textEditText ?? item.label];
          if (insertTextFormat === ls.InsertTextFormat.Snippet) {
            return { text: new code.SnippetString(newText), range, fromEdit: true };
          } else {
            return { text: newText, range, fromEdit: true };
          }
        } else if (item.insertText) {
          if (insertTextFormat === ls.InsertTextFormat.Snippet) {
            return { text: new code.SnippetString(item.insertText), fromEdit: false };
          } else {
            return { text: item.insertText, fromEdit: false };
          }
        } else {
          return void 0;
        }
      }
      function getCompletionRangeAndText(value) {
        if (ls.InsertReplaceEdit.is(value)) {
          return [{ inserting: asRange(value.insert), replacing: asRange(value.replace) }, value.newText];
        } else {
          return [asRange(value.range), value.newText];
        }
      }
      function asTextEdit(edit) {
        if (!edit) {
          return void 0;
        }
        return new code.TextEdit(asRange(edit.range), edit.newText);
      }
      async function asTextEdits(items, token) {
        if (!items) {
          return void 0;
        }
        return async.map(items, asTextEdit, token);
      }
      function asTextEditsSync(items) {
        if (!items) {
          return void 0;
        }
        const result = new Array(items.length);
        for (let i = 0; i < items.length; i++) {
          result[i] = asTextEdit(items[i]);
        }
        return result;
      }
      async function asSignatureHelp(item, token) {
        if (!item) {
          return void 0;
        }
        let result = new code.SignatureHelp();
        if (Is.number(item.activeSignature)) {
          result.activeSignature = item.activeSignature;
        } else {
          result.activeSignature = 0;
        }
        if (Is.number(item.activeParameter)) {
          result.activeParameter = item.activeParameter;
        } else {
          result.activeParameter = 0;
        }
        if (item.signatures) {
          result.signatures = await asSignatureInformations(item.signatures, token);
        }
        return result;
      }
      async function asSignatureInformations(items, token) {
        return async.mapAsync(items, asSignatureInformation, token);
      }
      async function asSignatureInformation(item, token) {
        let result = new code.SignatureInformation(item.label);
        if (item.documentation !== void 0) {
          result.documentation = asDocumentation(item.documentation);
        }
        if (item.parameters !== void 0) {
          result.parameters = await asParameterInformations(item.parameters, token);
        }
        if (item.activeParameter !== void 0) {
          result.activeParameter = item.activeParameter;
        }
        {
          return result;
        }
      }
      function asParameterInformations(items, token) {
        return async.map(items, asParameterInformation, token);
      }
      function asParameterInformation(item) {
        let result = new code.ParameterInformation(item.label);
        if (item.documentation) {
          result.documentation = asDocumentation(item.documentation);
        }
        return result;
      }
      function asLocation(item) {
        return item ? new code.Location(_uriConverter(item.uri), asRange(item.range)) : void 0;
      }
      async function asDeclarationResult(item, token) {
        if (!item) {
          return void 0;
        }
        return asLocationResult(item, token);
      }
      async function asDefinitionResult(item, token) {
        if (!item) {
          return void 0;
        }
        return asLocationResult(item, token);
      }
      function asLocationLink(item) {
        if (!item) {
          return void 0;
        }
        let result = {
          targetUri: _uriConverter(item.targetUri),
          targetRange: asRange(item.targetRange),
          originSelectionRange: asRange(item.originSelectionRange),
          targetSelectionRange: asRange(item.targetSelectionRange)
        };
        if (!result.targetSelectionRange) {
          throw new Error(`targetSelectionRange must not be undefined or null`);
        }
        return result;
      }
      async function asLocationResult(item, token) {
        if (!item) {
          return void 0;
        }
        if (Is.array(item)) {
          if (item.length === 0) {
            return [];
          } else if (ls.LocationLink.is(item[0])) {
            const links = item;
            return async.map(links, asLocationLink, token);
          } else {
            const locations = item;
            return async.map(locations, asLocation, token);
          }
        } else if (ls.LocationLink.is(item)) {
          return [asLocationLink(item)];
        } else {
          return asLocation(item);
        }
      }
      async function asReferences(values, token) {
        if (!values) {
          return void 0;
        }
        return async.map(values, asLocation, token);
      }
      async function asDocumentHighlights(values, token) {
        if (!values) {
          return void 0;
        }
        return async.map(values, asDocumentHighlight, token);
      }
      function asDocumentHighlight(item) {
        let result = new code.DocumentHighlight(asRange(item.range));
        if (Is.number(item.kind)) {
          result.kind = asDocumentHighlightKind(item.kind);
        }
        return result;
      }
      function asDocumentHighlightKind(item) {
        switch (item) {
          case ls.DocumentHighlightKind.Text:
            return code.DocumentHighlightKind.Text;
          case ls.DocumentHighlightKind.Read:
            return code.DocumentHighlightKind.Read;
          case ls.DocumentHighlightKind.Write:
            return code.DocumentHighlightKind.Write;
        }
        return code.DocumentHighlightKind.Text;
      }
      async function asSymbolInformations(values, token) {
        if (!values) {
          return void 0;
        }
        return async.map(values, asSymbolInformation, token);
      }
      function asSymbolKind(item) {
        if (item <= ls.SymbolKind.TypeParameter) {
          return item - 1;
        }
        return code.SymbolKind.Property;
      }
      function asSymbolTag(value) {
        switch (value) {
          case ls.SymbolTag.Deprecated:
            return code.SymbolTag.Deprecated;
          default:
            return void 0;
        }
      }
      function asSymbolTags(items) {
        if (items === void 0 || items === null) {
          return void 0;
        }
        const result = [];
        for (const item of items) {
          const converted = asSymbolTag(item);
          if (converted !== void 0) {
            result.push(converted);
          }
        }
        return result.length === 0 ? void 0 : result;
      }
      function asSymbolInformation(item) {
        const data = item.data;
        const location = item.location;
        const result = location.range === void 0 || data !== void 0 ? new protocolWorkspaceSymbol_1.default(item.name, asSymbolKind(item.kind), item.containerName ?? "", location.range === void 0 ? _uriConverter(location.uri) : new code.Location(_uriConverter(item.location.uri), asRange(location.range)), data) : new code.SymbolInformation(item.name, asSymbolKind(item.kind), item.containerName ?? "", new code.Location(_uriConverter(item.location.uri), asRange(location.range)));
        fillTags(result, item);
        return result;
      }
      async function asDocumentSymbols(values, token) {
        if (values === void 0 || values === null) {
          return void 0;
        }
        return async.map(values, asDocumentSymbol, token);
      }
      function asDocumentSymbol(value) {
        let result = new code.DocumentSymbol(value.name, value.detail || "", asSymbolKind(value.kind), asRange(value.range), asRange(value.selectionRange));
        fillTags(result, value);
        if (value.children !== void 0 && value.children.length > 0) {
          let children = [];
          for (let child of value.children) {
            children.push(asDocumentSymbol(child));
          }
          result.children = children;
        }
        return result;
      }
      function fillTags(result, value) {
        result.tags = asSymbolTags(value.tags);
        if (value.deprecated) {
          if (!result.tags) {
            result.tags = [code.SymbolTag.Deprecated];
          } else {
            if (!result.tags.includes(code.SymbolTag.Deprecated)) {
              result.tags = result.tags.concat(code.SymbolTag.Deprecated);
            }
          }
        }
      }
      function asCommand(item) {
        let result = { title: item.title, command: item.command };
        if (item.arguments) {
          result.arguments = item.arguments;
        }
        return result;
      }
      async function asCommands(items, token) {
        if (!items) {
          return void 0;
        }
        return async.map(items, asCommand, token);
      }
      const kindMapping = /* @__PURE__ */ new Map();
      kindMapping.set(ls.CodeActionKind.Empty, code.CodeActionKind.Empty);
      kindMapping.set(ls.CodeActionKind.QuickFix, code.CodeActionKind.QuickFix);
      kindMapping.set(ls.CodeActionKind.Refactor, code.CodeActionKind.Refactor);
      kindMapping.set(ls.CodeActionKind.RefactorExtract, code.CodeActionKind.RefactorExtract);
      kindMapping.set(ls.CodeActionKind.RefactorInline, code.CodeActionKind.RefactorInline);
      kindMapping.set(ls.CodeActionKind.RefactorRewrite, code.CodeActionKind.RefactorRewrite);
      kindMapping.set(ls.CodeActionKind.Source, code.CodeActionKind.Source);
      kindMapping.set(ls.CodeActionKind.SourceOrganizeImports, code.CodeActionKind.SourceOrganizeImports);
      function asCodeActionKind(item) {
        if (item === void 0 || item === null) {
          return void 0;
        }
        let result = kindMapping.get(item);
        if (result) {
          return result;
        }
        let parts = item.split(".");
        result = code.CodeActionKind.Empty;
        for (let part of parts) {
          result = result.append(part);
        }
        return result;
      }
      function asCodeActionKinds(items) {
        if (items === void 0 || items === null) {
          return void 0;
        }
        return items.map((kind) => asCodeActionKind(kind));
      }
      async function asCodeAction(item, token) {
        if (item === void 0 || item === null) {
          return void 0;
        }
        let result = new protocolCodeAction_1.default(item.title, item.data);
        if (item.kind !== void 0) {
          result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== void 0) {
          result.diagnostics = asDiagnosticsSync(item.diagnostics);
        }
        if (item.edit !== void 0) {
          result.edit = await asWorkspaceEdit(item.edit, token);
        }
        if (item.command !== void 0) {
          result.command = asCommand(item.command);
        }
        if (item.isPreferred !== void 0) {
          result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== void 0) {
          result.disabled = { reason: item.disabled.reason };
        }
        return result;
      }
      function asCodeActionResult(items, token) {
        return async.mapAsync(items, async (item) => {
          if (ls.Command.is(item)) {
            return asCommand(item);
          } else {
            return asCodeAction(item, token);
          }
        }, token);
      }
      function asCodeLens(item) {
        if (!item) {
          return void 0;
        }
        let result = new protocolCodeLens_1.default(asRange(item.range));
        if (item.command) {
          result.command = asCommand(item.command);
        }
        if (item.data !== void 0 && item.data !== null) {
          result.data = item.data;
        }
        return result;
      }
      async function asCodeLenses(items, token) {
        if (!items) {
          return void 0;
        }
        return async.map(items, asCodeLens, token);
      }
      async function asWorkspaceEdit(item, token) {
        if (!item) {
          return void 0;
        }
        const sharedMetadata = /* @__PURE__ */ new Map();
        if (item.changeAnnotations !== void 0) {
          const changeAnnotations = item.changeAnnotations;
          await async.forEach(Object.keys(changeAnnotations), (key) => {
            const metaData = asWorkspaceEditEntryMetadata(changeAnnotations[key]);
            sharedMetadata.set(key, metaData);
          }, token);
        }
        const asMetadata = (annotation) => {
          if (annotation === void 0) {
            return void 0;
          } else {
            return sharedMetadata.get(annotation);
          }
        };
        const result = new code.WorkspaceEdit();
        if (item.documentChanges) {
          const documentChanges = item.documentChanges;
          await async.forEach(documentChanges, (change) => {
            if (ls.CreateFile.is(change)) {
              result.createFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
            } else if (ls.RenameFile.is(change)) {
              result.renameFile(_uriConverter(change.oldUri), _uriConverter(change.newUri), change.options, asMetadata(change.annotationId));
            } else if (ls.DeleteFile.is(change)) {
              result.deleteFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
            } else if (ls.TextDocumentEdit.is(change)) {
              const uri = _uriConverter(change.textDocument.uri);
              for (const edit of change.edits) {
                if (ls.AnnotatedTextEdit.is(edit)) {
                  result.replace(uri, asRange(edit.range), edit.newText, asMetadata(edit.annotationId));
                } else {
                  result.replace(uri, asRange(edit.range), edit.newText);
                }
              }
            } else {
              throw new Error(`Unknown workspace edit change received:
${JSON.stringify(change, void 0, 4)}`);
            }
          }, token);
        } else if (item.changes) {
          const changes = item.changes;
          await async.forEach(Object.keys(changes), (key) => {
            result.set(_uriConverter(key), asTextEditsSync(changes[key]));
          }, token);
        }
        return result;
      }
      function asWorkspaceEditEntryMetadata(annotation) {
        if (annotation === void 0) {
          return void 0;
        }
        return { label: annotation.label, needsConfirmation: !!annotation.needsConfirmation, description: annotation.description };
      }
      function asDocumentLink(item) {
        let range = asRange(item.range);
        let target = item.target ? asUri(item.target) : void 0;
        let link = new protocolDocumentLink_1.default(range, target);
        if (item.tooltip !== void 0) {
          link.tooltip = item.tooltip;
        }
        if (item.data !== void 0 && item.data !== null) {
          link.data = item.data;
        }
        return link;
      }
      async function asDocumentLinks(items, token) {
        if (!items) {
          return void 0;
        }
        return async.map(items, asDocumentLink, token);
      }
      function asColor(color) {
        return new code.Color(color.red, color.green, color.blue, color.alpha);
      }
      function asColorInformation(ci) {
        return new code.ColorInformation(asRange(ci.range), asColor(ci.color));
      }
      async function asColorInformations(colorInformation, token) {
        if (!colorInformation) {
          return void 0;
        }
        return async.map(colorInformation, asColorInformation, token);
      }
      function asColorPresentation(cp) {
        let presentation = new code.ColorPresentation(cp.label);
        presentation.additionalTextEdits = asTextEditsSync(cp.additionalTextEdits);
        if (cp.textEdit) {
          presentation.textEdit = asTextEdit(cp.textEdit);
        }
        return presentation;
      }
      async function asColorPresentations(colorPresentations, token) {
        if (!colorPresentations) {
          return void 0;
        }
        return async.map(colorPresentations, asColorPresentation, token);
      }
      function asFoldingRangeKind(kind) {
        if (kind) {
          switch (kind) {
            case ls.FoldingRangeKind.Comment:
              return code.FoldingRangeKind.Comment;
            case ls.FoldingRangeKind.Imports:
              return code.FoldingRangeKind.Imports;
            case ls.FoldingRangeKind.Region:
              return code.FoldingRangeKind.Region;
          }
        }
        return void 0;
      }
      function asFoldingRange(r) {
        return new code.FoldingRange(r.startLine, r.endLine, asFoldingRangeKind(r.kind));
      }
      async function asFoldingRanges(foldingRanges, token) {
        if (!foldingRanges) {
          return void 0;
        }
        return async.map(foldingRanges, asFoldingRange, token);
      }
      function asSelectionRange(selectionRange) {
        return new code.SelectionRange(asRange(selectionRange.range), selectionRange.parent ? asSelectionRange(selectionRange.parent) : void 0);
      }
      async function asSelectionRanges(selectionRanges, token) {
        if (!Array.isArray(selectionRanges)) {
          return [];
        }
        return async.map(selectionRanges, asSelectionRange, token);
      }
      function asInlineValue(inlineValue) {
        if (ls.InlineValueText.is(inlineValue)) {
          return new code.InlineValueText(asRange(inlineValue.range), inlineValue.text);
        } else if (ls.InlineValueVariableLookup.is(inlineValue)) {
          return new code.InlineValueVariableLookup(asRange(inlineValue.range), inlineValue.variableName, inlineValue.caseSensitiveLookup);
        } else {
          return new code.InlineValueEvaluatableExpression(asRange(inlineValue.range), inlineValue.expression);
        }
      }
      async function asInlineValues(inlineValues, token) {
        if (!Array.isArray(inlineValues)) {
          return [];
        }
        return async.map(inlineValues, asInlineValue, token);
      }
      async function asInlayHint(value, token) {
        const label = typeof value.label === "string" ? value.label : await async.map(value.label, asInlayHintLabelPart, token);
        const result = new protocolInlayHint_1.default(asPosition(value.position), label);
        if (value.kind !== void 0) {
          result.kind = value.kind;
        }
        if (value.textEdits !== void 0) {
          result.textEdits = await asTextEdits(value.textEdits, token);
        }
        if (value.tooltip !== void 0) {
          result.tooltip = asTooltip(value.tooltip);
        }
        if (value.paddingLeft !== void 0) {
          result.paddingLeft = value.paddingLeft;
        }
        if (value.paddingRight !== void 0) {
          result.paddingRight = value.paddingRight;
        }
        if (value.data !== void 0) {
          result.data = value.data;
        }
        return result;
      }
      function asInlayHintLabelPart(part) {
        const result = new code.InlayHintLabelPart(part.value);
        if (part.location !== void 0) {
          result.location = asLocation(part.location);
        }
        if (part.tooltip !== void 0) {
          result.tooltip = asTooltip(part.tooltip);
        }
        if (part.command !== void 0) {
          result.command = asCommand(part.command);
        }
        return result;
      }
      function asTooltip(value) {
        if (typeof value === "string") {
          return value;
        }
        return asMarkdownString(value);
      }
      async function asInlayHints(values, token) {
        if (!Array.isArray(values)) {
          return void 0;
        }
        return async.mapAsync(values, asInlayHint, token);
      }
      function asCallHierarchyItem(item) {
        if (item === null) {
          return void 0;
        }
        const result = new protocolCallHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || "", asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
        if (item.tags !== void 0) {
          result.tags = asSymbolTags(item.tags);
        }
        return result;
      }
      async function asCallHierarchyItems(items, token) {
        if (items === null) {
          return void 0;
        }
        return async.map(items, asCallHierarchyItem, token);
      }
      async function asCallHierarchyIncomingCall(item, token) {
        return new code.CallHierarchyIncomingCall(asCallHierarchyItem(item.from), await asRanges(item.fromRanges, token));
      }
      async function asCallHierarchyIncomingCalls(items, token) {
        if (items === null) {
          return void 0;
        }
        return async.mapAsync(items, asCallHierarchyIncomingCall, token);
      }
      async function asCallHierarchyOutgoingCall(item, token) {
        return new code.CallHierarchyOutgoingCall(asCallHierarchyItem(item.to), await asRanges(item.fromRanges, token));
      }
      async function asCallHierarchyOutgoingCalls(items, token) {
        if (items === null) {
          return void 0;
        }
        return async.mapAsync(items, asCallHierarchyOutgoingCall, token);
      }
      async function asSemanticTokens(value, _token) {
        if (value === void 0 || value === null) {
          return void 0;
        }
        return new code.SemanticTokens(new Uint32Array(value.data), value.resultId);
      }
      function asSemanticTokensEdit(value) {
        return new code.SemanticTokensEdit(value.start, value.deleteCount, value.data !== void 0 ? new Uint32Array(value.data) : void 0);
      }
      async function asSemanticTokensEdits(value, _token) {
        if (value === void 0 || value === null) {
          return void 0;
        }
        return new code.SemanticTokensEdits(value.edits.map(asSemanticTokensEdit), value.resultId);
      }
      function asSemanticTokensLegend(value) {
        return value;
      }
      async function asLinkedEditingRanges(value, token) {
        if (value === null || value === void 0) {
          return void 0;
        }
        return new code.LinkedEditingRanges(await asRanges(value.ranges, token), asRegularExpression(value.wordPattern));
      }
      function asRegularExpression(value) {
        if (value === null || value === void 0) {
          return void 0;
        }
        return new RegExp(value);
      }
      function asTypeHierarchyItem(item) {
        if (item === null) {
          return void 0;
        }
        let result = new protocolTypeHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || "", asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
        if (item.tags !== void 0) {
          result.tags = asSymbolTags(item.tags);
        }
        return result;
      }
      async function asTypeHierarchyItems(items, token) {
        if (items === null) {
          return void 0;
        }
        return async.map(items, asTypeHierarchyItem, token);
      }
      function asGlobPattern(pattern) {
        if (Is.string(pattern)) {
          return pattern;
        }
        if (ls.RelativePattern.is(pattern)) {
          if (ls.URI.is(pattern.baseUri)) {
            return new code.RelativePattern(asUri(pattern.baseUri), pattern.pattern);
          } else if (ls.WorkspaceFolder.is(pattern.baseUri)) {
            const workspaceFolder = code.workspace.getWorkspaceFolder(asUri(pattern.baseUri.uri));
            return workspaceFolder !== void 0 ? new code.RelativePattern(workspaceFolder, pattern.pattern) : void 0;
          }
        }
        return void 0;
      }
      async function asInlineCompletionResult(value, token) {
        if (!value) {
          return void 0;
        }
        if (Array.isArray(value)) {
          return async.map(value, (item) => asInlineCompletionItem(item), token);
        }
        const list = value;
        const converted = await async.map(list.items, (item) => {
          return asInlineCompletionItem(item);
        }, token);
        return new code.InlineCompletionList(converted);
      }
      function asInlineCompletionItem(item) {
        let insertText;
        if (typeof item.insertText === "string") {
          insertText = item.insertText;
        } else {
          insertText = new code.SnippetString(item.insertText.value);
        }
        let command = void 0;
        if (item.command) {
          command = asCommand(item.command);
        }
        const inlineCompletionItem = new code.InlineCompletionItem(insertText, asRange(item.range), command);
        if (item.filterText) {
          inlineCompletionItem.filterText = item.filterText;
        }
        return inlineCompletionItem;
      }
      return {
        asUri,
        asDocumentSelector,
        asDiagnostics,
        asDiagnostic,
        asRange,
        asRanges,
        asPosition,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asHover,
        asCompletionResult,
        asCompletionItem,
        asTextEdit,
        asTextEdits,
        asSignatureHelp,
        asSignatureInformations,
        asSignatureInformation,
        asParameterInformations,
        asParameterInformation,
        asDeclarationResult,
        asDefinitionResult,
        asLocation,
        asReferences,
        asDocumentHighlights,
        asDocumentHighlight,
        asDocumentHighlightKind,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asSymbolInformations,
        asSymbolInformation,
        asDocumentSymbols,
        asDocumentSymbol,
        asCommand,
        asCommands,
        asCodeAction,
        asCodeActionKind,
        asCodeActionKinds,
        asCodeActionResult,
        asCodeLens,
        asCodeLenses,
        asWorkspaceEdit,
        asDocumentLink,
        asDocumentLinks,
        asFoldingRangeKind,
        asFoldingRange,
        asFoldingRanges,
        asColor,
        asColorInformation,
        asColorInformations,
        asColorPresentation,
        asColorPresentations,
        asSelectionRange,
        asSelectionRanges,
        asInlineValue,
        asInlineValues,
        asInlayHint,
        asInlayHints,
        asSemanticTokensLegend,
        asSemanticTokens,
        asSemanticTokensEdit,
        asSemanticTokensEdits,
        asCallHierarchyItem,
        asCallHierarchyItems,
        asCallHierarchyIncomingCall,
        asCallHierarchyIncomingCalls,
        asCallHierarchyOutgoingCall,
        asCallHierarchyOutgoingCalls,
        asLinkedEditingRanges,
        asTypeHierarchyItem,
        asTypeHierarchyItems,
        asGlobPattern,
        asInlineCompletionResult,
        asInlineCompletionItem
      };
    }
    exports.createConverter = createConverter;
  }
});

// node_modules/vscode-languageclient/lib/common/utils/uuid.js
var require_uuid = __commonJS({
  "node_modules/vscode-languageclient/lib/common/utils/uuid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateUuid = exports.parse = exports.isUUID = exports.v4 = exports.empty = void 0;
    var ValueUUID = class {
      constructor(_value) {
        this._value = _value;
      }
      asHex() {
        return this._value;
      }
      equals(other) {
        return this.asHex() === other.asHex();
      }
    };
    var V4UUID = class extends ValueUUID {
      static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
      }
      static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
      }
      constructor() {
        super([
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          "4",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._oneOf(V4UUID._timeHighBits),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex()
        ].join(""));
      }
    };
    V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    V4UUID._timeHighBits = ["8", "9", "a", "b"];
    exports.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
    function v4() {
      return new V4UUID();
    }
    exports.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
      return _UUIDPattern.test(value);
    }
    exports.isUUID = isUUID;
    function parse(value) {
      if (!isUUID(value)) {
        throw new Error("invalid uuid");
      }
      return new ValueUUID(value);
    }
    exports.parse = parse;
    function generateUuid() {
      return v4().asHex();
    }
    exports.generateUuid = generateUuid;
  }
});

// node_modules/vscode-languageclient/lib/common/progressPart.js
var require_progressPart = __commonJS({
  "node_modules/vscode-languageclient/lib/common/progressPart.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProgressPart = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var ProgressPart = class {
      constructor(_client, _token, done) {
        this._client = _client;
        this._token = _token;
        this._reported = 0;
        this._infinite = false;
        this._lspProgressDisposable = this._client.onProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, (value) => {
          switch (value.kind) {
            case "begin":
              this.begin(value);
              break;
            case "report":
              this.report(value);
              break;
            case "end":
              this.done();
              done && done(this);
              break;
          }
        });
      }
      begin(params) {
        this._infinite = params.percentage === void 0;
        if (this._lspProgressDisposable === void 0) {
          return;
        }
        void vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Window, cancellable: params.cancellable, title: params.title }, async (progress, cancellationToken) => {
          if (this._lspProgressDisposable === void 0) {
            return;
          }
          this._progress = progress;
          this._cancellationToken = cancellationToken;
          this._tokenDisposable = this._cancellationToken.onCancellationRequested(() => {
            this._client.sendNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, { token: this._token });
          });
          this.report(params);
          return new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
          });
        });
      }
      report(params) {
        if (this._infinite && Is.string(params.message)) {
          this._progress !== void 0 && this._progress.report({ message: params.message });
        } else if (Is.number(params.percentage)) {
          const percentage = Math.max(0, Math.min(params.percentage, 100));
          const delta = Math.max(0, percentage - this._reported);
          this._reported += delta;
          this._progress !== void 0 && this._progress.report({ message: params.message, increment: delta });
        }
      }
      cancel() {
        this.cleanup();
        if (this._reject !== void 0) {
          this._reject();
          this._resolve = void 0;
          this._reject = void 0;
        }
      }
      done() {
        this.cleanup();
        if (this._resolve !== void 0) {
          this._resolve();
          this._resolve = void 0;
          this._reject = void 0;
        }
      }
      cleanup() {
        if (this._lspProgressDisposable !== void 0) {
          this._lspProgressDisposable.dispose();
          this._lspProgressDisposable = void 0;
        }
        if (this._tokenDisposable !== void 0) {
          this._tokenDisposable.dispose();
          this._tokenDisposable = void 0;
        }
        this._progress = void 0;
        this._cancellationToken = void 0;
      }
    };
    exports.ProgressPart = ProgressPart;
  }
});

// node_modules/vscode-languageclient/lib/common/features.js
var require_features = __commonJS({
  "node_modules/vscode-languageclient/lib/common/features.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkspaceFeature = exports.TextDocumentLanguageFeature = exports.TextDocumentEventFeature = exports.DynamicDocumentFeature = exports.DynamicFeature = exports.StaticFeature = exports.ensure = exports.LSPCancellationError = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var UUID = require_uuid();
    var LSPCancellationError = class extends vscode_1.CancellationError {
      constructor(data) {
        super();
        this.data = data;
      }
    };
    exports.LSPCancellationError = LSPCancellationError;
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    exports.ensure = ensure;
    var StaticFeature;
    (function(StaticFeature2) {
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && Is.func(candidate.fillClientCapabilities) && Is.func(candidate.initialize) && Is.func(candidate.getState) && Is.func(candidate.clear) && (candidate.fillInitializeParams === void 0 || Is.func(candidate.fillInitializeParams));
      }
      StaticFeature2.is = is;
    })(StaticFeature || (exports.StaticFeature = StaticFeature = {}));
    var DynamicFeature;
    (function(DynamicFeature2) {
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && Is.func(candidate.fillClientCapabilities) && Is.func(candidate.initialize) && Is.func(candidate.getState) && Is.func(candidate.clear) && (candidate.fillInitializeParams === void 0 || Is.func(candidate.fillInitializeParams)) && Is.func(candidate.register) && Is.func(candidate.unregister) && candidate.registrationType !== void 0;
      }
      DynamicFeature2.is = is;
    })(DynamicFeature || (exports.DynamicFeature = DynamicFeature = {}));
    var DynamicDocumentFeature = class {
      constructor(client) {
        this._client = client;
      }
      /**
       * Returns the state the feature is in.
       */
      getState() {
        const selectors = this.getDocumentSelectors();
        let count = 0;
        for (const selector of selectors) {
          count++;
          for (const document of vscode_1.workspace.textDocuments) {
            if (vscode_1.languages.match(selector, document) > 0) {
              return { kind: "document", id: this.registrationType.method, registrations: true, matches: true };
            }
          }
        }
        const registrations = count > 0;
        return { kind: "document", id: this.registrationType.method, registrations, matches: false };
      }
    };
    exports.DynamicDocumentFeature = DynamicDocumentFeature;
    var TextDocumentEventFeature = class extends DynamicDocumentFeature {
      static textDocumentFilter(selectors, textDocument) {
        for (const selector of selectors) {
          if (vscode_1.languages.match(selector, textDocument) > 0) {
            return true;
          }
        }
        return false;
      }
      constructor(client, event, type, middleware, createParams, textDocument, selectorFilter) {
        super(client);
        this._event = event;
        this._type = type;
        this._middleware = middleware;
        this._createParams = createParams;
        this._textDocument = textDocument;
        this._selectorFilter = selectorFilter;
        this._selectors = /* @__PURE__ */ new Map();
        this._onNotificationSent = new vscode_1.EventEmitter();
      }
      getStateInfo() {
        return [this._selectors.values(), false];
      }
      getDocumentSelectors() {
        return this._selectors.values();
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = this._event((data2) => {
            this.callback(data2).catch((error) => {
              this._client.error(`Sending document notification ${this._type.method} failed.`, error);
            });
          });
        }
        this._selectors.set(data.id, this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector));
      }
      async callback(data) {
        const doSend = async (data2) => {
          const params = this._createParams(data2);
          await this._client.sendNotification(this._type, params);
          this.notificationSent(this.getTextDocument(data2), this._type, params);
        };
        if (this.matches(data)) {
          const middleware = this._middleware();
          return middleware ? middleware(data, (data2) => doSend(data2)) : doSend(data);
        }
      }
      matches(data) {
        if (this._client.hasDedicatedTextSynchronizationFeature(this._textDocument(data))) {
          return false;
        }
        return !this._selectorFilter || this._selectorFilter(this._selectors.values(), data);
      }
      get onNotificationSent() {
        return this._onNotificationSent.event;
      }
      notificationSent(textDocument, type, params) {
        this._onNotificationSent.fire({ textDocument, type, params });
      }
      unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      clear() {
        this._selectors.clear();
        this._onNotificationSent.dispose();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      getProvider(document) {
        for (const selector of this._selectors.values()) {
          if (vscode_1.languages.match(selector, document) > 0) {
            return {
              send: (data) => {
                return this.callback(data);
              }
            };
          }
        }
        return void 0;
      }
    };
    exports.TextDocumentEventFeature = TextDocumentEventFeature;
    var TextDocumentLanguageFeature = class extends DynamicDocumentFeature {
      constructor(client, registrationType) {
        super(client);
        this._registrationType = registrationType;
        this._registrations = /* @__PURE__ */ new Map();
      }
      *getDocumentSelectors() {
        for (const registration of this._registrations.values()) {
          const selector = registration.data.registerOptions.documentSelector;
          if (selector === null) {
            continue;
          }
          yield this._client.protocol2CodeConverter.asDocumentSelector(selector);
        }
      }
      get registrationType() {
        return this._registrationType;
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        let registration = this.registerLanguageProvider(data.registerOptions, data.id);
        this._registrations.set(data.id, { disposable: registration[0], data, provider: registration[1] });
      }
      unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== void 0) {
          registration.disposable.dispose();
        }
      }
      clear() {
        this._registrations.forEach((value) => {
          value.disposable.dispose();
        });
        this._registrations.clear();
      }
      getRegistration(documentSelector, capability) {
        if (!capability) {
          return [void 0, void 0];
        } else if (vscode_languageserver_protocol_1.TextDocumentRegistrationOptions.is(capability)) {
          const id = vscode_languageserver_protocol_1.StaticRegistrationOptions.hasId(capability) ? capability.id : UUID.generateUuid();
          const selector = capability.documentSelector ?? documentSelector;
          if (selector) {
            return [id, Object.assign({}, capability, { documentSelector: selector })];
          }
        } else if (Is.boolean(capability) && capability === true || vscode_languageserver_protocol_1.WorkDoneProgressOptions.is(capability)) {
          if (!documentSelector) {
            return [void 0, void 0];
          }
          const options = Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector });
          return [UUID.generateUuid(), options];
        }
        return [void 0, void 0];
      }
      getRegistrationOptions(documentSelector, capability) {
        if (!documentSelector || !capability) {
          return void 0;
        }
        return Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector });
      }
      getProvider(textDocument) {
        for (const registration of this._registrations.values()) {
          let selector = registration.data.registerOptions.documentSelector;
          if (selector !== null && vscode_1.languages.match(this._client.protocol2CodeConverter.asDocumentSelector(selector), textDocument) > 0) {
            return registration.provider;
          }
        }
        return void 0;
      }
      getAllProviders() {
        const result = [];
        for (const item of this._registrations.values()) {
          result.push(item.provider);
        }
        return result;
      }
    };
    exports.TextDocumentLanguageFeature = TextDocumentLanguageFeature;
    var WorkspaceFeature = class {
      constructor(client, registrationType) {
        this._client = client;
        this._registrationType = registrationType;
        this._registrations = /* @__PURE__ */ new Map();
      }
      getState() {
        const registrations = this._registrations.size > 0;
        return { kind: "workspace", id: this._registrationType.method, registrations };
      }
      get registrationType() {
        return this._registrationType;
      }
      register(data) {
        const registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, { disposable: registration[0], provider: registration[1] });
      }
      unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== void 0) {
          registration.disposable.dispose();
        }
      }
      clear() {
        this._registrations.forEach((registration) => {
          registration.disposable.dispose();
        });
        this._registrations.clear();
      }
      getProviders() {
        const result = [];
        for (const registration of this._registrations.values()) {
          result.push(registration.provider);
        }
        return result;
      }
    };
    exports.WorkspaceFeature = WorkspaceFeature;
  }
});

// node_modules/vscode-languageclient/node_modules/minimatch/lib/path.js
var require_path = __commonJS({
  "node_modules/vscode-languageclient/node_modules/minimatch/lib/path.js"(exports, module2) {
    var isWindows = typeof process === "object" && process && process.platform === "win32";
    module2.exports = isWindows ? { sep: "\\" } : { sep: "/" };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/vscode-languageclient/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/vscode-languageclient/node_modules/brace-expansion/index.js"(exports, module2) {
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m)
        return [str];
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/vscode-languageclient/node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/vscode-languageclient/node_modules/minimatch/minimatch.js"(exports, module2) {
    var minimatch = module2.exports = (p, pattern, options = {}) => {
      assertValidPattern(pattern);
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    };
    module2.exports = minimatch;
    var path3 = require_path();
    minimatch.sep = path3.sep;
    var GLOBSTAR = Symbol("globstar **");
    minimatch.GLOBSTAR = GLOBSTAR;
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var charSet = (s) => s.split("").reduce((set, c) => {
      set[c] = true;
      return set;
    }, {});
    var reSpecials = charSet("().*{}+?[]^$\\!");
    var addPatternStartSet = charSet("[.(");
    var slashSplit = /\/+/;
    minimatch.filter = (pattern, options = {}) => (p, i, list) => minimatch(p, pattern, options);
    var ext = (a, b = {}) => {
      const t = {};
      Object.keys(a).forEach((k) => t[k] = a[k]);
      Object.keys(b).forEach((k) => t[k] = b[k]);
      return t;
    };
    minimatch.defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      const orig = minimatch;
      const m = (p, pattern, options) => orig(p, pattern, ext(def, options));
      m.Minimatch = class Minimatch extends orig.Minimatch {
        constructor(pattern, options) {
          super(pattern, ext(def, options));
        }
      };
      m.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
      m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
      m.defaults = (options) => orig.defaults(ext(def, options));
      m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
      m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
      m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));
      return m;
    };
    minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);
    var braceExpand = (pattern, options = {}) => {
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    };
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = (pattern) => {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    var SUBPARSE = Symbol("subparse");
    minimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
    minimatch.match = (list, pattern, options = {}) => {
      const mm = new Minimatch(pattern, options);
      list = list.filter((f) => mm.match(f));
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    var globUnescape = (s) => s.replace(/\\(.)/g, "$1");
    var charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1");
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");
    var Minimatch = class {
      constructor(pattern, options) {
        assertValidPattern(pattern);
        if (!options)
          options = {};
        this.options = options;
        this.set = [];
        this.pattern = pattern;
        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.make();
      }
      debug() {
      }
      make() {
        const pattern = this.pattern;
        const options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        let set = this.globSet = this.braceExpand();
        if (options.debug)
          this.debug = (...args) => console.error(...args);
        this.debug(this.pattern, set);
        set = this.globParts = set.map((s) => s.split(slashSplit));
        this.debug(this.pattern, set);
        set = set.map((s, si, set2) => s.map(this.parse, this));
        this.debug(this.pattern, set);
        set = set.filter((s) => s.indexOf(false) === -1);
        this.debug(this.pattern, set);
        this.set = set;
      }
      parseNegate() {
        if (this.options.nonegate)
          return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
      }
      // set partial to true to test if, for example,
      // "/a/b" matches the start of "/*/b/*/d"
      // Partial means, if you run out of file before you run
      // out of pattern, then that's fine, as long as all
      // the parts match.
      matchOne(file, pattern, partial) {
        var options = this.options;
        this.debug(
          "matchOne",
          { "this": this, file, pattern }
        );
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false)
            return false;
          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl)
                return true;
            }
            return false;
          }
          var hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = f.match(p);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        }
        throw new Error("wtf?");
      }
      braceExpand() {
        return braceExpand(this.pattern, this.options);
      }
      parse(pattern, isSub) {
        assertValidPattern(pattern);
        const options = this.options;
        if (pattern === "**") {
          if (!options.noglobstar)
            return GLOBSTAR;
          else
            pattern = "*";
        }
        if (pattern === "")
          return "";
        let re = "";
        let hasMagic = false;
        let escaping = false;
        const patternListStack = [];
        const negativeLists = [];
        let stateChar;
        let inClass = false;
        let reClassStart = -1;
        let classStart = -1;
        let cs;
        let pl;
        let sp;
        let dotTravAllowed = pattern.charAt(0) === ".";
        let dotFileAllowed = options.dot || dotTravAllowed;
        const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const subPatternStart = (p) => p.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const clearStateChar = () => {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re += star;
                hasMagic = true;
                break;
              case "?":
                re += qmark;
                hasMagic = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            this.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        };
        for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {
          this.debug("%s	%s %s %j", pattern, i, re, c);
          if (escaping) {
            if (c === "/") {
              return false;
            }
            if (reSpecials[c]) {
              re += "\\";
            }
            re += c;
            escaping = false;
            continue;
          }
          switch (c) {
            case "/": {
              return false;
            }
            case "\\":
              if (inClass && pattern.charAt(i + 1) === "-") {
                re += c;
                continue;
              }
              clearStateChar();
              escaping = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
              if (inClass) {
                this.debug("  in class");
                if (c === "!" && i === classStart + 1)
                  c = "^";
                re += c;
                continue;
              }
              this.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c;
              if (options.noext)
                clearStateChar();
              continue;
            case "(": {
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              const plEntry = {
                type: stateChar,
                start: i - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              };
              this.debug(this.pattern, "	", plEntry);
              patternListStack.push(plEntry);
              re += plEntry.open;
              if (plEntry.start === 0 && plEntry.type !== "!") {
                dotTravAllowed = true;
                re += subPatternStart(pattern.slice(i + 1));
              }
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;
            }
            case ")": {
              const plEntry = patternListStack[patternListStack.length - 1];
              if (inClass || !plEntry) {
                re += "\\)";
                continue;
              }
              patternListStack.pop();
              clearStateChar();
              hasMagic = true;
              pl = plEntry;
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(Object.assign(pl, { reEnd: re.length }));
              }
              continue;
            }
            case "|": {
              const plEntry = patternListStack[patternListStack.length - 1];
              if (inClass || !plEntry) {
                re += "\\|";
                continue;
              }
              clearStateChar();
              re += "|";
              if (plEntry.start === 0 && plEntry.type !== "!") {
                dotTravAllowed = true;
                re += subPatternStart(pattern.slice(i + 1));
              }
              continue;
            }
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                continue;
              }
              cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
                re += c;
              } catch (er) {
                re = re.substring(0, reClassStart) + "(?:$.)";
              }
              hasMagic = true;
              inClass = false;
              continue;
            default:
              clearStateChar();
              if (reSpecials[c] && !(c === "^" && inClass)) {
                re += "\\";
              }
              re += c;
              break;
          }
        }
        if (inClass) {
          cs = pattern.slice(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substring(0, reClassStart) + "\\[" + sp[0];
          hasMagic = hasMagic || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          let tail;
          tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
            if (!$2) {
              $2 = "\\";
            }
            return $1 + $1 + $2 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
          hasMagic = true;
          re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re += "\\\\";
        }
        const addPatternStart = addPatternStartSet[re.charAt(0)];
        for (let n = negativeLists.length - 1; n > -1; n--) {
          const nl = negativeLists[n];
          const nlBefore = re.slice(0, nl.reStart);
          const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          let nlAfter = re.slice(nl.reEnd);
          const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
          const closeParensBefore = nlBefore.split(")").length;
          const openParensBefore = nlBefore.split("(").length - closeParensBefore;
          let cleanAfter = nlAfter;
          for (let i = 0; i < openParensBefore; i++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          const dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
          re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        }
        if (re !== "" && hasMagic) {
          re = "(?=.)" + re;
        }
        if (addPatternStart) {
          re = patternStart() + re;
        }
        if (isSub === SUBPARSE) {
          return [re, hasMagic];
        }
        if (options.nocase && !hasMagic) {
          hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();
        }
        if (!hasMagic) {
          return globUnescape(pattern);
        }
        const flags = options.nocase ? "i" : "";
        try {
          return Object.assign(new RegExp("^" + re + "$", flags), {
            _glob: pattern,
            _src: re
          });
        } catch (er) {
          return new RegExp("$.");
        }
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        const flags = options.nocase ? "i" : "";
        let re = set.map((pattern) => {
          pattern = pattern.map(
            (p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src
          ).reduce((set2, p) => {
            if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
              set2.push(p);
            }
            return set2;
          }, []);
          pattern.forEach((p, i) => {
            if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
              return;
            }
            if (i === 0) {
              if (pattern.length > 1) {
                pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
              } else {
                pattern[i] = twoStar;
              }
            } else if (i === pattern.length - 1) {
              pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
            } else {
              pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
              pattern[i + 1] = GLOBSTAR;
            }
          });
          return pattern.filter((p) => p !== GLOBSTAR).join("/");
        }).join("|");
        re = "^(?:" + re + ")$";
        if (this.negate)
          re = "^(?!" + re + ").*$";
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment)
          return false;
        if (this.empty)
          return f === "";
        if (f === "/" && partial)
          return true;
        const options = this.options;
        if (path3.sep !== "/") {
          f = f.split(path3.sep).join("/");
        }
        f = f.split(slashSplit);
        this.debug(this.pattern, "split", f);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename;
        for (let i = f.length - 1; i >= 0; i--) {
          filename = f[i];
          if (filename)
            break;
        }
        for (let i = 0; i < set.length; i++) {
          const pattern = set[i];
          let file = f;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate)
              return true;
            return !this.negate;
          }
        }
        if (options.flipNegate)
          return false;
        return this.negate;
      }
      static defaults(def) {
        return minimatch.defaults(def).Minimatch;
      }
    };
    minimatch.Minimatch = Minimatch;
  }
});

// node_modules/vscode-languageclient/lib/common/diagnostic.js
var require_diagnostic = __commonJS({
  "node_modules/vscode-languageclient/lib/common/diagnostic.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagnosticFeature = exports.DiagnosticPullMode = exports.vsdiag = void 0;
    var minimatch = require_minimatch();
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var uuid_1 = require_uuid();
    var features_1 = require_features();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var vsdiag;
    (function(vsdiag2) {
      let DocumentDiagnosticReportKind;
      (function(DocumentDiagnosticReportKind2) {
        DocumentDiagnosticReportKind2["full"] = "full";
        DocumentDiagnosticReportKind2["unChanged"] = "unChanged";
      })(DocumentDiagnosticReportKind = vsdiag2.DocumentDiagnosticReportKind || (vsdiag2.DocumentDiagnosticReportKind = {}));
    })(vsdiag || (exports.vsdiag = vsdiag = {}));
    var DiagnosticPullMode;
    (function(DiagnosticPullMode2) {
      DiagnosticPullMode2["onType"] = "onType";
      DiagnosticPullMode2["onSave"] = "onSave";
    })(DiagnosticPullMode || (exports.DiagnosticPullMode = DiagnosticPullMode = {}));
    var RequestStateKind;
    (function(RequestStateKind2) {
      RequestStateKind2["active"] = "open";
      RequestStateKind2["reschedule"] = "reschedule";
      RequestStateKind2["outDated"] = "drop";
    })(RequestStateKind || (RequestStateKind = {}));
    var Tabs = class {
      constructor() {
        this.open = /* @__PURE__ */ new Set();
        this._onOpen = new vscode_1.EventEmitter();
        this._onClose = new vscode_1.EventEmitter();
        Tabs.fillTabResources(this.open);
        const openTabsHandler = (event) => {
          if (event.closed.length === 0 && event.opened.length === 0) {
            return;
          }
          const oldTabs = this.open;
          const currentTabs = /* @__PURE__ */ new Set();
          Tabs.fillTabResources(currentTabs);
          const closed = /* @__PURE__ */ new Set();
          const opened = new Set(currentTabs);
          for (const tab of oldTabs.values()) {
            if (currentTabs.has(tab)) {
              opened.delete(tab);
            } else {
              closed.add(tab);
            }
          }
          this.open = currentTabs;
          if (closed.size > 0) {
            const toFire = /* @__PURE__ */ new Set();
            for (const item of closed) {
              toFire.add(vscode_1.Uri.parse(item));
            }
            this._onClose.fire(toFire);
          }
          if (opened.size > 0) {
            const toFire = /* @__PURE__ */ new Set();
            for (const item of opened) {
              toFire.add(vscode_1.Uri.parse(item));
            }
            this._onOpen.fire(toFire);
          }
        };
        if (vscode_1.window.tabGroups.onDidChangeTabs !== void 0) {
          this.disposable = vscode_1.window.tabGroups.onDidChangeTabs(openTabsHandler);
        } else {
          this.disposable = { dispose: () => {
          } };
        }
      }
      get onClose() {
        return this._onClose.event;
      }
      get onOpen() {
        return this._onOpen.event;
      }
      dispose() {
        this.disposable.dispose();
      }
      isActive(document) {
        return document instanceof vscode_1.Uri ? vscode_1.window.activeTextEditor?.document.uri === document : vscode_1.window.activeTextEditor?.document === document;
      }
      isVisible(document) {
        const uri = document instanceof vscode_1.Uri ? document : document.uri;
        return this.open.has(uri.toString());
      }
      getTabResources() {
        const result = /* @__PURE__ */ new Set();
        Tabs.fillTabResources(/* @__PURE__ */ new Set(), result);
        return result;
      }
      static fillTabResources(strings, uris) {
        const seen = strings ?? /* @__PURE__ */ new Set();
        for (const group of vscode_1.window.tabGroups.all) {
          for (const tab of group.tabs) {
            const input = tab.input;
            let uri;
            if (input instanceof vscode_1.TabInputText) {
              uri = input.uri;
            } else if (input instanceof vscode_1.TabInputTextDiff) {
              uri = input.modified;
            } else if (input instanceof vscode_1.TabInputCustom) {
              uri = input.uri;
            }
            if (uri !== void 0 && !seen.has(uri.toString())) {
              seen.add(uri.toString());
              uris !== void 0 && uris.add(uri);
            }
          }
        }
      }
    };
    var PullState;
    (function(PullState2) {
      PullState2[PullState2["document"] = 1] = "document";
      PullState2[PullState2["workspace"] = 2] = "workspace";
    })(PullState || (PullState = {}));
    var DocumentOrUri;
    (function(DocumentOrUri2) {
      function asKey(document) {
        return document instanceof vscode_1.Uri ? document.toString() : document.uri.toString();
      }
      DocumentOrUri2.asKey = asKey;
    })(DocumentOrUri || (DocumentOrUri = {}));
    var DocumentPullStateTracker = class {
      constructor() {
        this.documentPullStates = /* @__PURE__ */ new Map();
        this.workspacePullStates = /* @__PURE__ */ new Map();
      }
      track(kind, document, arg1) {
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version] = document instanceof vscode_1.Uri ? [document.toString(), document, arg1] : [document.uri.toString(), document.uri, document.version];
        let state = states.get(key);
        if (state === void 0) {
          state = { document: uri, pulledVersion: version, resultId: void 0 };
          states.set(key, state);
        }
        return state;
      }
      update(kind, document, arg1, arg2) {
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version, resultId] = document instanceof vscode_1.Uri ? [document.toString(), document, arg1, arg2] : [document.uri.toString(), document.uri, document.version, arg1];
        let state = states.get(key);
        if (state === void 0) {
          state = { document: uri, pulledVersion: version, resultId };
          states.set(key, state);
        } else {
          state.pulledVersion = version;
          state.resultId = resultId;
        }
      }
      unTrack(kind, document) {
        const key = DocumentOrUri.asKey(document);
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        states.delete(key);
      }
      tracks(kind, document) {
        const key = DocumentOrUri.asKey(document);
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        return states.has(key);
      }
      getResultId(kind, document) {
        const key = DocumentOrUri.asKey(document);
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        return states.get(key)?.resultId;
      }
      getAllResultIds() {
        const result = [];
        for (let [uri, value] of this.workspacePullStates) {
          if (this.documentPullStates.has(uri)) {
            value = this.documentPullStates.get(uri);
          }
          if (value.resultId !== void 0) {
            result.push({ uri, value: value.resultId });
          }
        }
        return result;
      }
    };
    var DiagnosticRequestor = class {
      constructor(client, tabs, options) {
        this.client = client;
        this.tabs = tabs;
        this.options = options;
        this.isDisposed = false;
        this.onDidChangeDiagnosticsEmitter = new vscode_1.EventEmitter();
        this.provider = this.createProvider();
        this.diagnostics = vscode_1.languages.createDiagnosticCollection(options.identifier);
        this.openRequests = /* @__PURE__ */ new Map();
        this.documentStates = new DocumentPullStateTracker();
        this.workspaceErrorCounter = 0;
      }
      knows(kind, document) {
        const uri = document instanceof vscode_1.Uri ? document : document.uri;
        return this.documentStates.tracks(kind, document) || this.openRequests.has(uri.toString());
      }
      forget(kind, document) {
        this.documentStates.unTrack(kind, document);
      }
      pull(document, cb) {
        if (this.isDisposed) {
          return;
        }
        const uri = document instanceof vscode_1.Uri ? document : document.uri;
        this.pullAsync(document).then(() => {
          if (cb) {
            cb();
          }
        }, (error) => {
          this.client.error(`Document pull failed for text document ${uri.toString()}`, error, false);
        });
      }
      async pullAsync(document, version) {
        if (this.isDisposed) {
          return;
        }
        const isUri = document instanceof vscode_1.Uri;
        const uri = isUri ? document : document.uri;
        const key = uri.toString();
        version = isUri ? version : document.version;
        const currentRequestState = this.openRequests.get(key);
        const documentState = isUri ? this.documentStates.track(PullState.document, document, version) : this.documentStates.track(PullState.document, document);
        if (currentRequestState === void 0) {
          const tokenSource = new vscode_1.CancellationTokenSource();
          this.openRequests.set(key, { state: RequestStateKind.active, document, version, tokenSource });
          let report;
          let afterState;
          try {
            report = await this.provider.provideDiagnostics(document, documentState.resultId, tokenSource.token) ?? { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
          } catch (error) {
            if (error instanceof features_1.LSPCancellationError && vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data) && error.data.retriggerRequest === false) {
              afterState = { state: RequestStateKind.outDated, document };
            }
            if (afterState === void 0 && error instanceof vscode_1.CancellationError) {
              afterState = { state: RequestStateKind.reschedule, document };
            } else {
              throw error;
            }
          }
          afterState = afterState ?? this.openRequests.get(key);
          if (afterState === void 0) {
            this.client.error(`Lost request state in diagnostic pull model. Clearing diagnostics for ${key}`);
            this.diagnostics.delete(uri);
            return;
          }
          this.openRequests.delete(key);
          if (!this.tabs.isVisible(document)) {
            this.documentStates.unTrack(PullState.document, document);
            return;
          }
          if (afterState.state === RequestStateKind.outDated) {
            return;
          }
          if (report !== void 0) {
            if (report.kind === vsdiag.DocumentDiagnosticReportKind.full) {
              this.diagnostics.set(uri, report.items);
            }
            documentState.pulledVersion = version;
            documentState.resultId = report.resultId;
          }
          if (afterState.state === RequestStateKind.reschedule) {
            this.pull(document);
          }
        } else {
          if (currentRequestState.state === RequestStateKind.active) {
            currentRequestState.tokenSource.cancel();
            this.openRequests.set(key, { state: RequestStateKind.reschedule, document: currentRequestState.document });
          } else if (currentRequestState.state === RequestStateKind.outDated) {
            this.openRequests.set(key, { state: RequestStateKind.reschedule, document: currentRequestState.document });
          }
        }
      }
      forgetDocument(document) {
        const uri = document instanceof vscode_1.Uri ? document : document.uri;
        const key = uri.toString();
        const request = this.openRequests.get(key);
        if (this.options.workspaceDiagnostics) {
          if (request !== void 0) {
            this.openRequests.set(key, { state: RequestStateKind.reschedule, document });
          } else {
            this.pull(document, () => {
              this.forget(PullState.document, document);
            });
          }
        } else {
          if (request !== void 0) {
            if (request.state === RequestStateKind.active) {
              request.tokenSource.cancel();
            }
            this.openRequests.set(key, { state: RequestStateKind.outDated, document });
          }
          this.diagnostics.delete(uri);
          this.forget(PullState.document, document);
        }
      }
      pullWorkspace() {
        if (this.isDisposed) {
          return;
        }
        this.pullWorkspaceAsync().then(() => {
          this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
            this.pullWorkspace();
          }, 2e3);
        }, (error) => {
          if (!(error instanceof features_1.LSPCancellationError) && !vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data)) {
            this.client.error(`Workspace diagnostic pull failed.`, error, false);
            this.workspaceErrorCounter++;
          }
          if (this.workspaceErrorCounter <= 5) {
            this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
              this.pullWorkspace();
            }, 2e3);
          }
        });
      }
      async pullWorkspaceAsync() {
        if (!this.provider.provideWorkspaceDiagnostics || this.isDisposed) {
          return;
        }
        if (this.workspaceCancellation !== void 0) {
          this.workspaceCancellation.cancel();
          this.workspaceCancellation = void 0;
        }
        this.workspaceCancellation = new vscode_1.CancellationTokenSource();
        const previousResultIds = this.documentStates.getAllResultIds().map((item) => {
          return {
            uri: this.client.protocol2CodeConverter.asUri(item.uri),
            value: item.value
          };
        });
        await this.provider.provideWorkspaceDiagnostics(previousResultIds, this.workspaceCancellation.token, (chunk) => {
          if (!chunk || this.isDisposed) {
            return;
          }
          for (const item of chunk.items) {
            if (item.kind === vsdiag.DocumentDiagnosticReportKind.full) {
              if (!this.documentStates.tracks(PullState.document, item.uri)) {
                this.diagnostics.set(item.uri, item.items);
              }
            }
            this.documentStates.update(PullState.workspace, item.uri, item.version ?? void 0, item.resultId);
          }
        });
      }
      createProvider() {
        const result = {
          onDidChangeDiagnostics: this.onDidChangeDiagnosticsEmitter.event,
          provideDiagnostics: (document, previousResultId, token) => {
            const provideDiagnostics = (document2, previousResultId2, token2) => {
              const params = {
                identifier: this.options.identifier,
                textDocument: { uri: this.client.code2ProtocolConverter.asUri(document2 instanceof vscode_1.Uri ? document2 : document2.uri) },
                previousResultId: previousResultId2
              };
              if (this.isDisposed === true || !this.client.isRunning()) {
                return { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
              }
              return this.client.sendRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, params, token2).then(async (result2) => {
                if (result2 === void 0 || result2 === null || this.isDisposed || token2.isCancellationRequested) {
                  return { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
                }
                if (result2.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full) {
                  return { kind: vsdiag.DocumentDiagnosticReportKind.full, resultId: result2.resultId, items: await this.client.protocol2CodeConverter.asDiagnostics(result2.items, token2) };
                } else {
                  return { kind: vsdiag.DocumentDiagnosticReportKind.unChanged, resultId: result2.resultId };
                }
              }, (error) => {
                return this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token2, error, { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] });
              });
            };
            const middleware = this.client.middleware;
            return middleware.provideDiagnostics ? middleware.provideDiagnostics(document, previousResultId, token, provideDiagnostics) : provideDiagnostics(document, previousResultId, token);
          }
        };
        if (this.options.workspaceDiagnostics) {
          result.provideWorkspaceDiagnostics = (resultIds, token, resultReporter) => {
            const convertReport = async (report) => {
              if (report.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full) {
                return {
                  kind: vsdiag.DocumentDiagnosticReportKind.full,
                  uri: this.client.protocol2CodeConverter.asUri(report.uri),
                  resultId: report.resultId,
                  version: report.version,
                  items: await this.client.protocol2CodeConverter.asDiagnostics(report.items, token)
                };
              } else {
                return {
                  kind: vsdiag.DocumentDiagnosticReportKind.unChanged,
                  uri: this.client.protocol2CodeConverter.asUri(report.uri),
                  resultId: report.resultId,
                  version: report.version
                };
              }
            };
            const convertPreviousResultIds = (resultIds2) => {
              const converted = [];
              for (const item of resultIds2) {
                converted.push({ uri: this.client.code2ProtocolConverter.asUri(item.uri), value: item.value });
              }
              return converted;
            };
            const provideDiagnostics = (resultIds2, token2) => {
              const partialResultToken = (0, uuid_1.generateUuid)();
              const disposable = this.client.onProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, partialResultToken, async (partialResult) => {
                if (partialResult === void 0 || partialResult === null) {
                  resultReporter(null);
                  return;
                }
                const converted = {
                  items: []
                };
                for (const item of partialResult.items) {
                  try {
                    converted.items.push(await convertReport(item));
                  } catch (error) {
                    this.client.error(`Converting workspace diagnostics failed.`, error);
                  }
                }
                resultReporter(converted);
              });
              const params = {
                identifier: this.options.identifier,
                previousResultIds: convertPreviousResultIds(resultIds2),
                partialResultToken
              };
              if (this.isDisposed === true || !this.client.isRunning()) {
                return { items: [] };
              }
              return this.client.sendRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, params, token2).then(async (result2) => {
                if (token2.isCancellationRequested) {
                  return { items: [] };
                }
                const converted = {
                  items: []
                };
                for (const item of result2.items) {
                  converted.items.push(await convertReport(item));
                }
                disposable.dispose();
                resultReporter(converted);
                return { items: [] };
              }, (error) => {
                disposable.dispose();
                return this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token2, error, { items: [] });
              });
            };
            const middleware = this.client.middleware;
            return middleware.provideWorkspaceDiagnostics ? middleware.provideWorkspaceDiagnostics(resultIds, token, resultReporter, provideDiagnostics) : provideDiagnostics(resultIds, token, resultReporter);
          };
        }
        return result;
      }
      dispose() {
        this.isDisposed = true;
        this.workspaceCancellation?.cancel();
        this.workspaceTimeout?.dispose();
        for (const [key, request] of this.openRequests) {
          if (request.state === RequestStateKind.active) {
            request.tokenSource.cancel();
          }
          this.openRequests.set(key, { state: RequestStateKind.outDated, document: request.document });
        }
        this.diagnostics.dispose();
      }
    };
    var BackgroundScheduler = class {
      constructor(diagnosticRequestor) {
        this.diagnosticRequestor = diagnosticRequestor;
        this.documents = new vscode_languageserver_protocol_1.LinkedMap();
        this.isDisposed = false;
      }
      add(document) {
        if (this.isDisposed === true) {
          return;
        }
        const key = DocumentOrUri.asKey(document);
        if (this.documents.has(key)) {
          return;
        }
        this.documents.set(key, document, vscode_languageserver_protocol_1.Touch.Last);
        this.trigger();
      }
      remove(document) {
        const key = DocumentOrUri.asKey(document);
        this.documents.delete(key);
        if (this.documents.size === 0) {
          this.stop();
        } else if (key === this.endDocumentKey()) {
          this.endDocument = this.documents.last;
        }
      }
      trigger() {
        if (this.isDisposed === true) {
          return;
        }
        if (this.intervalHandle !== void 0) {
          this.endDocument = this.documents.last;
          return;
        }
        this.endDocument = this.documents.last;
        this.intervalHandle = (0, vscode_languageserver_protocol_1.RAL)().timer.setInterval(() => {
          const document = this.documents.first;
          if (document !== void 0) {
            const key = DocumentOrUri.asKey(document);
            this.diagnosticRequestor.pull(document);
            this.documents.set(key, document, vscode_languageserver_protocol_1.Touch.Last);
            if (key === this.endDocumentKey()) {
              this.stop();
            }
          }
        }, 200);
      }
      dispose() {
        this.isDisposed = true;
        this.stop();
        this.documents.clear();
      }
      stop() {
        this.intervalHandle?.dispose();
        this.intervalHandle = void 0;
        this.endDocument = void 0;
      }
      endDocumentKey() {
        return this.endDocument !== void 0 ? DocumentOrUri.asKey(this.endDocument) : void 0;
      }
    };
    var DiagnosticFeatureProviderImpl = class {
      constructor(client, tabs, options) {
        const diagnosticPullOptions = client.clientOptions.diagnosticPullOptions ?? { onChange: true, onSave: false };
        const documentSelector = client.protocol2CodeConverter.asDocumentSelector(options.documentSelector);
        const disposables = [];
        const matchResource = (resource) => {
          const selector = options.documentSelector;
          if (diagnosticPullOptions.match !== void 0) {
            return diagnosticPullOptions.match(selector, resource);
          }
          for (const filter of selector) {
            if (!vscode_languageserver_protocol_1.TextDocumentFilter.is(filter)) {
              continue;
            }
            if (typeof filter === "string") {
              return false;
            }
            if (filter.language !== void 0 && filter.language !== "*") {
              return false;
            }
            if (filter.scheme !== void 0 && filter.scheme !== "*" && filter.scheme !== resource.scheme) {
              return false;
            }
            if (filter.pattern !== void 0) {
              const matcher = new minimatch.Minimatch(filter.pattern, { noext: true });
              if (!matcher.makeRe()) {
                return false;
              }
              if (!matcher.match(resource.fsPath)) {
                return false;
              }
            }
          }
          return true;
        };
        const matches = (document) => {
          return document instanceof vscode_1.Uri ? matchResource(document) : vscode_1.languages.match(documentSelector, document) > 0 && tabs.isVisible(document);
        };
        const isActiveDocument = (document) => {
          return document instanceof vscode_1.Uri ? this.activeTextDocument?.uri.toString() === document.toString() : this.activeTextDocument === document;
        };
        this.diagnosticRequestor = new DiagnosticRequestor(client, tabs, options);
        this.backgroundScheduler = new BackgroundScheduler(this.diagnosticRequestor);
        const addToBackgroundIfNeeded = (document) => {
          if (!matches(document) || !options.interFileDependencies || isActiveDocument(document)) {
            return;
          }
          this.backgroundScheduler.add(document);
        };
        this.activeTextDocument = vscode_1.window.activeTextEditor?.document;
        vscode_1.window.onDidChangeActiveTextEditor((editor) => {
          const oldActive = this.activeTextDocument;
          this.activeTextDocument = editor?.document;
          if (oldActive !== void 0) {
            addToBackgroundIfNeeded(oldActive);
          }
          if (this.activeTextDocument !== void 0) {
            this.backgroundScheduler.remove(this.activeTextDocument);
          }
        });
        const openFeature = client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method);
        disposables.push(openFeature.onNotificationSent((event) => {
          const textDocument = event.textDocument;
          if (this.diagnosticRequestor.knows(PullState.document, textDocument)) {
            return;
          }
          if (matches(textDocument)) {
            this.diagnosticRequestor.pull(textDocument, () => {
              addToBackgroundIfNeeded(textDocument);
            });
          }
        }));
        disposables.push(tabs.onOpen((opened) => {
          for (const resource of opened) {
            if (this.diagnosticRequestor.knows(PullState.document, resource)) {
              continue;
            }
            const uriStr = resource.toString();
            let textDocument;
            for (const item of vscode_1.workspace.textDocuments) {
              if (uriStr === item.uri.toString()) {
                textDocument = item;
                break;
              }
            }
            if (textDocument !== void 0 && matches(textDocument)) {
              this.diagnosticRequestor.pull(textDocument, () => {
                addToBackgroundIfNeeded(textDocument);
              });
            }
          }
        }));
        const pulledTextDocuments = /* @__PURE__ */ new Set();
        for (const textDocument of vscode_1.workspace.textDocuments) {
          if (matches(textDocument)) {
            this.diagnosticRequestor.pull(textDocument, () => {
              addToBackgroundIfNeeded(textDocument);
            });
            pulledTextDocuments.add(textDocument.uri.toString());
          }
        }
        if (diagnosticPullOptions.onTabs === true) {
          for (const resource of tabs.getTabResources()) {
            if (!pulledTextDocuments.has(resource.toString()) && matches(resource)) {
              this.diagnosticRequestor.pull(resource, () => {
                addToBackgroundIfNeeded(resource);
              });
            }
          }
        }
        if (diagnosticPullOptions.onChange === true) {
          const changeFeature = client.getFeature(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.method);
          disposables.push(changeFeature.onNotificationSent(async (event) => {
            const textDocument = event.textDocument;
            if ((diagnosticPullOptions.filter === void 0 || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onType)) && this.diagnosticRequestor.knows(PullState.document, textDocument)) {
              this.diagnosticRequestor.pull(textDocument, () => {
                this.backgroundScheduler.trigger();
              });
            }
          }));
        }
        if (diagnosticPullOptions.onSave === true) {
          const saveFeature = client.getFeature(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.method);
          disposables.push(saveFeature.onNotificationSent((event) => {
            const textDocument = event.textDocument;
            if ((diagnosticPullOptions.filter === void 0 || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onSave)) && this.diagnosticRequestor.knows(PullState.document, textDocument)) {
              this.diagnosticRequestor.pull(event.textDocument, () => {
                this.backgroundScheduler.trigger();
              });
            }
          }));
        }
        const closeFeature = client.getFeature(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.method);
        disposables.push(closeFeature.onNotificationSent((event) => {
          this.cleanUpDocument(event.textDocument);
        }));
        tabs.onClose((closed) => {
          for (const document of closed) {
            this.cleanUpDocument(document);
          }
        });
        this.diagnosticRequestor.onDidChangeDiagnosticsEmitter.event(() => {
          for (const textDocument of vscode_1.workspace.textDocuments) {
            if (matches(textDocument)) {
              this.diagnosticRequestor.pull(textDocument);
            }
          }
        });
        if (options.workspaceDiagnostics === true && options.identifier !== "da348dc5-c30a-4515-9d98-31ff3be38d14") {
          this.diagnosticRequestor.pullWorkspace();
        }
        this.disposable = vscode_1.Disposable.from(...disposables, this.backgroundScheduler, this.diagnosticRequestor);
      }
      get onDidChangeDiagnosticsEmitter() {
        return this.diagnosticRequestor.onDidChangeDiagnosticsEmitter;
      }
      get diagnostics() {
        return this.diagnosticRequestor.provider;
      }
      cleanUpDocument(document) {
        if (this.diagnosticRequestor.knows(PullState.document, document)) {
          this.diagnosticRequestor.forgetDocument(document);
          this.backgroundScheduler.remove(document);
        }
      }
    };
    var DiagnosticFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, "textDocument"), "diagnostic");
        capability.dynamicRegistration = true;
        capability.relatedDocumentSupport = false;
        ensure(ensure(capabilities, "workspace"), "diagnostics").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type, async () => {
          for (const provider2 of this.getAllProviders()) {
            provider2.onDidChangeDiagnosticsEmitter.fire();
          }
        });
        let [id, options] = this.getRegistration(documentSelector, capabilities.diagnosticProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      clear() {
        if (this.tabs !== void 0) {
          this.tabs.dispose();
          this.tabs = void 0;
        }
        super.clear();
      }
      registerLanguageProvider(options) {
        if (this.tabs === void 0) {
          this.tabs = new Tabs();
        }
        const provider2 = new DiagnosticFeatureProviderImpl(this._client, this.tabs, options);
        return [provider2.disposable, provider2];
      }
    };
    exports.DiagnosticFeature = DiagnosticFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/notebook.js
var require_notebook = __commonJS({
  "node_modules/vscode-languageclient/lib/common/notebook.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NotebookDocumentSyncFeature = void 0;
    var vscode10 = require("vscode");
    var minimatch = require_minimatch();
    var proto = require_main3();
    var UUID = require_uuid();
    var Is = require_is();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var Converter;
    (function(Converter2) {
      let c2p;
      (function(c2p2) {
        function asVersionedNotebookDocumentIdentifier(notebookDocument, base) {
          return {
            version: notebookDocument.version,
            uri: base.asUri(notebookDocument.uri)
          };
        }
        c2p2.asVersionedNotebookDocumentIdentifier = asVersionedNotebookDocumentIdentifier;
        function asNotebookDocument(notebookDocument, cells, base) {
          const result = proto.NotebookDocument.create(base.asUri(notebookDocument.uri), notebookDocument.notebookType, notebookDocument.version, asNotebookCells(cells, base));
          if (Object.keys(notebookDocument.metadata).length > 0) {
            result.metadata = asMetadata(notebookDocument.metadata);
          }
          return result;
        }
        c2p2.asNotebookDocument = asNotebookDocument;
        function asNotebookCells(cells, base) {
          return cells.map((cell) => asNotebookCell(cell, base));
        }
        c2p2.asNotebookCells = asNotebookCells;
        function asMetadata(metadata) {
          const seen = /* @__PURE__ */ new Set();
          return deepCopy(seen, metadata);
        }
        c2p2.asMetadata = asMetadata;
        function asNotebookCell(cell, base) {
          const result = proto.NotebookCell.create(asNotebookCellKind(cell.kind), base.asUri(cell.document.uri));
          if (Object.keys(cell.metadata).length > 0) {
            result.metadata = asMetadata(cell.metadata);
          }
          if (cell.executionSummary !== void 0 && (Is.number(cell.executionSummary.executionOrder) && Is.boolean(cell.executionSummary.success))) {
            result.executionSummary = {
              executionOrder: cell.executionSummary.executionOrder,
              success: cell.executionSummary.success
            };
          }
          return result;
        }
        c2p2.asNotebookCell = asNotebookCell;
        function asNotebookCellKind(kind) {
          switch (kind) {
            case vscode10.NotebookCellKind.Markup:
              return proto.NotebookCellKind.Markup;
            case vscode10.NotebookCellKind.Code:
              return proto.NotebookCellKind.Code;
          }
        }
        function deepCopy(seen, value) {
          if (seen.has(value)) {
            throw new Error(`Can't deep copy cyclic structures.`);
          }
          if (Array.isArray(value)) {
            const result = [];
            for (const elem of value) {
              if (elem !== null && typeof elem === "object" || Array.isArray(elem)) {
                result.push(deepCopy(seen, elem));
              } else {
                if (elem instanceof RegExp) {
                  throw new Error(`Can't transfer regular expressions to the server`);
                }
                result.push(elem);
              }
            }
            return result;
          } else {
            const props = Object.keys(value);
            const result = /* @__PURE__ */ Object.create(null);
            for (const prop of props) {
              const elem = value[prop];
              if (elem !== null && typeof elem === "object" || Array.isArray(elem)) {
                result[prop] = deepCopy(seen, elem);
              } else {
                if (elem instanceof RegExp) {
                  throw new Error(`Can't transfer regular expressions to the server`);
                }
                result[prop] = elem;
              }
            }
            return result;
          }
        }
        function asTextContentChange(event, base) {
          const params = base.asChangeTextDocumentParams(event, event.document.uri, event.document.version);
          return { document: params.textDocument, changes: params.contentChanges };
        }
        c2p2.asTextContentChange = asTextContentChange;
        function asNotebookDocumentChangeEvent(event, base) {
          const result = /* @__PURE__ */ Object.create(null);
          if (event.metadata) {
            result.metadata = Converter2.c2p.asMetadata(event.metadata);
          }
          if (event.cells !== void 0) {
            const cells = /* @__PURE__ */ Object.create(null);
            const changedCells = event.cells;
            if (changedCells.structure) {
              cells.structure = {
                array: {
                  start: changedCells.structure.array.start,
                  deleteCount: changedCells.structure.array.deleteCount,
                  cells: changedCells.structure.array.cells !== void 0 ? changedCells.structure.array.cells.map((cell) => Converter2.c2p.asNotebookCell(cell, base)) : void 0
                },
                didOpen: changedCells.structure.didOpen !== void 0 ? changedCells.structure.didOpen.map((cell) => base.asOpenTextDocumentParams(cell.document).textDocument) : void 0,
                didClose: changedCells.structure.didClose !== void 0 ? changedCells.structure.didClose.map((cell) => base.asCloseTextDocumentParams(cell.document).textDocument) : void 0
              };
            }
            if (changedCells.data !== void 0) {
              cells.data = changedCells.data.map((cell) => Converter2.c2p.asNotebookCell(cell, base));
            }
            if (changedCells.textContent !== void 0) {
              cells.textContent = changedCells.textContent.map((event2) => Converter2.c2p.asTextContentChange(event2, base));
            }
            if (Object.keys(cells).length > 0) {
              result.cells = cells;
            }
          }
          return result;
        }
        c2p2.asNotebookDocumentChangeEvent = asNotebookDocumentChangeEvent;
      })(c2p = Converter2.c2p || (Converter2.c2p = {}));
    })(Converter || (Converter = {}));
    var $NotebookCell;
    (function($NotebookCell2) {
      function computeDiff(originalCells, modifiedCells, compareMetadata) {
        const originalLength = originalCells.length;
        const modifiedLength = modifiedCells.length;
        let startIndex = 0;
        while (startIndex < modifiedLength && startIndex < originalLength && equals(originalCells[startIndex], modifiedCells[startIndex], compareMetadata)) {
          startIndex++;
        }
        if (startIndex < modifiedLength && startIndex < originalLength) {
          let originalEndIndex = originalLength - 1;
          let modifiedEndIndex = modifiedLength - 1;
          while (originalEndIndex >= 0 && modifiedEndIndex >= 0 && equals(originalCells[originalEndIndex], modifiedCells[modifiedEndIndex], compareMetadata)) {
            originalEndIndex--;
            modifiedEndIndex--;
          }
          const deleteCount = originalEndIndex + 1 - startIndex;
          const newCells = startIndex === modifiedEndIndex + 1 ? void 0 : modifiedCells.slice(startIndex, modifiedEndIndex + 1);
          return newCells !== void 0 ? { start: startIndex, deleteCount, cells: newCells } : { start: startIndex, deleteCount };
        } else if (startIndex < modifiedLength) {
          return { start: startIndex, deleteCount: 0, cells: modifiedCells.slice(startIndex) };
        } else if (startIndex < originalLength) {
          return { start: startIndex, deleteCount: originalLength - startIndex };
        } else {
          return void 0;
        }
      }
      $NotebookCell2.computeDiff = computeDiff;
      function equals(one, other, compareMetaData = true) {
        if (one.kind !== other.kind || one.document.uri.toString() !== other.document.uri.toString() || one.document.languageId !== other.document.languageId || !equalsExecution(one.executionSummary, other.executionSummary)) {
          return false;
        }
        return !compareMetaData || compareMetaData && equalsMetadata(one.metadata, other.metadata);
      }
      function equalsExecution(one, other) {
        if (one === other) {
          return true;
        }
        if (one === void 0 || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success && equalsTiming(one.timing, other.timing);
      }
      function equalsTiming(one, other) {
        if (one === other) {
          return true;
        }
        if (one === void 0 || other === void 0) {
          return false;
        }
        return one.startTime === other.startTime && one.endTime === other.endTime;
      }
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (isObjectLiteral(one) && isObjectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      function isObjectLiteral(value) {
        return value !== null && typeof value === "object";
      }
      $NotebookCell2.isObjectLiteral = isObjectLiteral;
    })($NotebookCell || ($NotebookCell = {}));
    var $NotebookDocumentFilter;
    (function($NotebookDocumentFilter2) {
      function matchNotebook(filter, notebookDocument) {
        if (typeof filter === "string") {
          return filter === "*" || notebookDocument.notebookType === filter;
        }
        if (filter.notebookType !== void 0 && filter.notebookType !== "*" && notebookDocument.notebookType !== filter.notebookType) {
          return false;
        }
        const uri = notebookDocument.uri;
        if (filter.scheme !== void 0 && filter.scheme !== "*" && uri.scheme !== filter.scheme) {
          return false;
        }
        if (filter.pattern !== void 0) {
          const matcher = new minimatch.Minimatch(filter.pattern, { noext: true });
          if (!matcher.makeRe()) {
            return false;
          }
          if (!matcher.match(uri.fsPath)) {
            return false;
          }
        }
        return true;
      }
      $NotebookDocumentFilter2.matchNotebook = matchNotebook;
    })($NotebookDocumentFilter || ($NotebookDocumentFilter = {}));
    var $NotebookDocumentSyncOptions;
    (function($NotebookDocumentSyncOptions2) {
      function asDocumentSelector(options) {
        const selector = options.notebookSelector;
        const result = [];
        for (const element of selector) {
          const notebookType = (typeof element.notebook === "string" ? element.notebook : element.notebook?.notebookType) ?? "*";
          const scheme = typeof element.notebook === "string" ? void 0 : element.notebook?.scheme;
          const pattern = typeof element.notebook === "string" ? void 0 : element.notebook?.pattern;
          if (element.cells !== void 0) {
            for (const cell of element.cells) {
              result.push(asDocumentFilter(notebookType, scheme, pattern, cell.language));
            }
          } else {
            result.push(asDocumentFilter(notebookType, scheme, pattern, void 0));
          }
        }
        return result;
      }
      $NotebookDocumentSyncOptions2.asDocumentSelector = asDocumentSelector;
      function asDocumentFilter(notebookType, scheme, pattern, language) {
        return scheme === void 0 && pattern === void 0 ? { notebook: notebookType, language } : { notebook: { notebookType, scheme, pattern }, language };
      }
    })($NotebookDocumentSyncOptions || ($NotebookDocumentSyncOptions = {}));
    var SyncInfo;
    (function(SyncInfo2) {
      function create(cells) {
        return {
          cells,
          uris: new Set(cells.map((cell) => cell.document.uri.toString()))
        };
      }
      SyncInfo2.create = create;
    })(SyncInfo || (SyncInfo = {}));
    var NotebookDocumentSyncFeatureProvider = class {
      constructor(client, options) {
        this.client = client;
        this.options = options;
        this.notebookSyncInfo = /* @__PURE__ */ new Map();
        this.notebookDidOpen = /* @__PURE__ */ new Set();
        this.disposables = [];
        this.selector = client.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options));
        vscode10.workspace.onDidOpenNotebookDocument((notebookDocument) => {
          this.notebookDidOpen.add(notebookDocument.uri.toString());
          this.didOpen(notebookDocument);
        }, void 0, this.disposables);
        for (const notebookDocument of vscode10.workspace.notebookDocuments) {
          this.notebookDidOpen.add(notebookDocument.uri.toString());
          this.didOpen(notebookDocument);
        }
        vscode10.workspace.onDidChangeNotebookDocument((event) => this.didChangeNotebookDocument(event), void 0, this.disposables);
        if (this.options.save === true) {
          vscode10.workspace.onDidSaveNotebookDocument((notebookDocument) => this.didSave(notebookDocument), void 0, this.disposables);
        }
        vscode10.workspace.onDidCloseNotebookDocument((notebookDocument) => {
          this.didClose(notebookDocument);
          this.notebookDidOpen.delete(notebookDocument.uri.toString());
        }, void 0, this.disposables);
      }
      getState() {
        for (const notebook of vscode10.workspace.notebookDocuments) {
          const matchingCells = this.getMatchingCells(notebook);
          if (matchingCells !== void 0) {
            return { kind: "document", id: "$internal", registrations: true, matches: true };
          }
        }
        return { kind: "document", id: "$internal", registrations: true, matches: false };
      }
      get mode() {
        return "notebook";
      }
      handles(textDocument) {
        return vscode10.languages.match(this.selector, textDocument) > 0;
      }
      didOpenNotebookCellTextDocument(notebookDocument, cell) {
        if (vscode10.languages.match(this.selector, cell.document) === 0) {
          return;
        }
        if (!this.notebookDidOpen.has(notebookDocument.uri.toString())) {
          return;
        }
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        const cellMatches = this.cellMatches(notebookDocument, cell);
        if (syncInfo !== void 0) {
          const cellIsSynced = syncInfo.uris.has(cell.document.uri.toString());
          if (cellMatches && cellIsSynced || !cellMatches && !cellIsSynced) {
            return;
          }
          if (cellMatches) {
            const matchingCells = this.getMatchingCells(notebookDocument);
            if (matchingCells !== void 0) {
              const event = this.asNotebookDocumentChangeEvent(notebookDocument, void 0, syncInfo, matchingCells);
              if (event !== void 0) {
                this.doSendChange(event, matchingCells).catch(() => {
                });
              }
            }
          }
        } else {
          if (cellMatches) {
            this.doSendOpen(notebookDocument, [cell]).catch(() => {
            });
          }
        }
      }
      didChangeNotebookCellTextDocument(notebookDocument, event) {
        if (vscode10.languages.match(this.selector, event.document) === 0) {
          return;
        }
        this.doSendChange({
          notebook: notebookDocument,
          cells: { textContent: [event] }
        }, void 0).catch(() => {
        });
      }
      didCloseNotebookCellTextDocument(notebookDocument, cell) {
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        if (syncInfo === void 0) {
          return;
        }
        const cellUri = cell.document.uri;
        const index = syncInfo.cells.findIndex((item) => item.document.uri.toString() === cellUri.toString());
        if (index === -1) {
          return;
        }
        if (index === 0 && syncInfo.cells.length === 1) {
          this.doSendClose(notebookDocument, syncInfo.cells).catch(() => {
          });
        } else {
          const newCells = syncInfo.cells.slice();
          const deleted = newCells.splice(index, 1);
          this.doSendChange({
            notebook: notebookDocument,
            cells: {
              structure: {
                array: { start: index, deleteCount: 1 },
                didClose: deleted
              }
            }
          }, newCells).catch(() => {
          });
        }
      }
      dispose() {
        for (const disposable of this.disposables) {
          disposable.dispose();
        }
      }
      didOpen(notebookDocument, matchingCells = this.getMatchingCells(notebookDocument), syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {
        if (syncInfo !== void 0) {
          if (matchingCells !== void 0) {
            const event = this.asNotebookDocumentChangeEvent(notebookDocument, void 0, syncInfo, matchingCells);
            if (event !== void 0) {
              this.doSendChange(event, matchingCells).catch(() => {
              });
            }
          } else {
            this.doSendClose(notebookDocument, []).catch(() => {
            });
          }
        } else {
          if (matchingCells === void 0) {
            return;
          }
          this.doSendOpen(notebookDocument, matchingCells).catch(() => {
          });
        }
      }
      didChangeNotebookDocument(event) {
        const notebookDocument = event.notebook;
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        if (syncInfo === void 0) {
          if (event.contentChanges.length === 0) {
            return;
          }
          const cells = this.getMatchingCells(notebookDocument);
          if (cells === void 0) {
            return;
          }
          this.didOpen(notebookDocument, cells, syncInfo);
        } else {
          const cells = this.getMatchingCells(notebookDocument);
          if (cells === void 0) {
            this.didClose(notebookDocument, syncInfo);
            return;
          }
          const newEvent = this.asNotebookDocumentChangeEvent(event.notebook, event, syncInfo, cells);
          if (newEvent !== void 0) {
            this.doSendChange(newEvent, cells).catch(() => {
            });
          }
        }
      }
      didSave(notebookDocument) {
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        if (syncInfo === void 0) {
          return;
        }
        this.doSendSave(notebookDocument).catch(() => {
        });
      }
      didClose(notebookDocument, syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {
        if (syncInfo === void 0) {
          return;
        }
        const syncedCells = notebookDocument.getCells().filter((cell) => syncInfo.uris.has(cell.document.uri.toString()));
        this.doSendClose(notebookDocument, syncedCells).catch(() => {
        });
      }
      async sendDidOpenNotebookDocument(notebookDocument) {
        const cells = this.getMatchingCells(notebookDocument);
        if (cells === void 0) {
          return;
        }
        return this.doSendOpen(notebookDocument, cells);
      }
      async doSendOpen(notebookDocument, cells) {
        const send = async (notebookDocument2, cells2) => {
          const nb = Converter.c2p.asNotebookDocument(notebookDocument2, cells2, this.client.code2ProtocolConverter);
          const cellDocuments = cells2.map((cell) => this.client.code2ProtocolConverter.asTextDocumentItem(cell.document));
          try {
            await this.client.sendNotification(proto.DidOpenNotebookDocumentNotification.type, {
              notebookDocument: nb,
              cellTextDocuments: cellDocuments
            });
          } catch (error) {
            this.client.error("Sending DidOpenNotebookDocumentNotification failed", error);
            throw error;
          }
        };
        const middleware = this.client.middleware?.notebooks;
        this.notebookSyncInfo.set(notebookDocument.uri.toString(), SyncInfo.create(cells));
        return middleware?.didOpen !== void 0 ? middleware.didOpen(notebookDocument, cells, send) : send(notebookDocument, cells);
      }
      async sendDidChangeNotebookDocument(event) {
        return this.doSendChange(event, void 0);
      }
      async doSendChange(event, cells = this.getMatchingCells(event.notebook)) {
        const send = async (event2) => {
          try {
            await this.client.sendNotification(proto.DidChangeNotebookDocumentNotification.type, {
              notebookDocument: Converter.c2p.asVersionedNotebookDocumentIdentifier(event2.notebook, this.client.code2ProtocolConverter),
              change: Converter.c2p.asNotebookDocumentChangeEvent(event2, this.client.code2ProtocolConverter)
            });
          } catch (error) {
            this.client.error("Sending DidChangeNotebookDocumentNotification failed", error);
            throw error;
          }
        };
        const middleware = this.client.middleware?.notebooks;
        if (event.cells?.structure !== void 0) {
          this.notebookSyncInfo.set(event.notebook.uri.toString(), SyncInfo.create(cells ?? []));
        }
        return middleware?.didChange !== void 0 ? middleware?.didChange(event, send) : send(event);
      }
      async sendDidSaveNotebookDocument(notebookDocument) {
        return this.doSendSave(notebookDocument);
      }
      async doSendSave(notebookDocument) {
        const send = async (notebookDocument2) => {
          try {
            await this.client.sendNotification(proto.DidSaveNotebookDocumentNotification.type, {
              notebookDocument: { uri: this.client.code2ProtocolConverter.asUri(notebookDocument2.uri) }
            });
          } catch (error) {
            this.client.error("Sending DidSaveNotebookDocumentNotification failed", error);
            throw error;
          }
        };
        const middleware = this.client.middleware?.notebooks;
        return middleware?.didSave !== void 0 ? middleware.didSave(notebookDocument, send) : send(notebookDocument);
      }
      async sendDidCloseNotebookDocument(notebookDocument) {
        return this.doSendClose(notebookDocument, this.getMatchingCells(notebookDocument) ?? []);
      }
      async doSendClose(notebookDocument, cells) {
        const send = async (notebookDocument2, cells2) => {
          try {
            await this.client.sendNotification(proto.DidCloseNotebookDocumentNotification.type, {
              notebookDocument: { uri: this.client.code2ProtocolConverter.asUri(notebookDocument2.uri) },
              cellTextDocuments: cells2.map((cell) => this.client.code2ProtocolConverter.asTextDocumentIdentifier(cell.document))
            });
          } catch (error) {
            this.client.error("Sending DidCloseNotebookDocumentNotification failed", error);
            throw error;
          }
        };
        const middleware = this.client.middleware?.notebooks;
        this.notebookSyncInfo.delete(notebookDocument.uri.toString());
        return middleware?.didClose !== void 0 ? middleware.didClose(notebookDocument, cells, send) : send(notebookDocument, cells);
      }
      asNotebookDocumentChangeEvent(notebook, event, syncInfo, matchingCells) {
        if (event !== void 0 && event.notebook !== notebook) {
          throw new Error("Notebook must be identical");
        }
        const result = {
          notebook
        };
        if (event?.metadata !== void 0) {
          result.metadata = Converter.c2p.asMetadata(event.metadata);
        }
        let matchingCellsSet;
        if (event?.cellChanges !== void 0 && event.cellChanges.length > 0) {
          const data = [];
          matchingCellsSet = new Set(matchingCells.map((cell) => cell.document.uri.toString()));
          for (const cellChange of event.cellChanges) {
            if (matchingCellsSet.has(cellChange.cell.document.uri.toString()) && (cellChange.executionSummary !== void 0 || cellChange.metadata !== void 0)) {
              data.push(cellChange.cell);
            }
          }
          if (data.length > 0) {
            result.cells = result.cells ?? {};
            result.cells.data = data;
          }
        }
        if ((event?.contentChanges !== void 0 && event.contentChanges.length > 0 || event === void 0) && syncInfo !== void 0 && matchingCells !== void 0) {
          const oldCells = syncInfo.cells;
          const newCells = matchingCells;
          const diff = $NotebookCell.computeDiff(oldCells, newCells, false);
          let addedCells;
          let removedCells;
          if (diff !== void 0) {
            addedCells = diff.cells === void 0 ? /* @__PURE__ */ new Map() : new Map(diff.cells.map((cell) => [cell.document.uri.toString(), cell]));
            removedCells = diff.deleteCount === 0 ? /* @__PURE__ */ new Map() : new Map(oldCells.slice(diff.start, diff.start + diff.deleteCount).map((cell) => [cell.document.uri.toString(), cell]));
            for (const key of Array.from(removedCells.keys())) {
              if (addedCells.has(key)) {
                removedCells.delete(key);
                addedCells.delete(key);
              }
            }
            result.cells = result.cells ?? {};
            const didOpen = [];
            const didClose = [];
            if (addedCells.size > 0 || removedCells.size > 0) {
              for (const cell of addedCells.values()) {
                didOpen.push(cell);
              }
              for (const cell of removedCells.values()) {
                didClose.push(cell);
              }
            }
            result.cells.structure = {
              array: diff,
              didOpen,
              didClose
            };
          }
        }
        return Object.keys(result).length > 1 ? result : void 0;
      }
      getMatchingCells(notebookDocument, cells = notebookDocument.getCells()) {
        if (this.options.notebookSelector === void 0) {
          return void 0;
        }
        for (const item of this.options.notebookSelector) {
          if (item.notebook === void 0 || $NotebookDocumentFilter.matchNotebook(item.notebook, notebookDocument)) {
            const filtered = this.filterCells(notebookDocument, cells, item.cells);
            return filtered.length === 0 ? void 0 : filtered;
          }
        }
        return void 0;
      }
      cellMatches(notebookDocument, cell) {
        const cells = this.getMatchingCells(notebookDocument, [cell]);
        return cells !== void 0 && cells[0] === cell;
      }
      filterCells(notebookDocument, cells, cellSelector) {
        const filtered = cellSelector !== void 0 ? cells.filter((cell) => {
          const cellLanguage = cell.document.languageId;
          return cellSelector.some((filter) => filter.language === "*" || cellLanguage === filter.language);
        }) : cells;
        return typeof this.client.clientOptions.notebookDocumentOptions?.filterCells === "function" ? this.client.clientOptions.notebookDocumentOptions.filterCells(notebookDocument, filtered) : filtered;
      }
    };
    var NotebookDocumentSyncFeature = class {
      constructor(client) {
        this.client = client;
        this.registrations = /* @__PURE__ */ new Map();
        this.registrationType = proto.NotebookDocumentSyncRegistrationType.type;
        vscode10.workspace.onDidOpenTextDocument((textDocument) => {
          if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
            return;
          }
          const [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);
          if (notebookDocument === void 0 || notebookCell === void 0) {
            return;
          }
          for (const provider2 of this.registrations.values()) {
            if (provider2 instanceof NotebookDocumentSyncFeatureProvider) {
              provider2.didOpenNotebookCellTextDocument(notebookDocument, notebookCell);
            }
          }
        });
        vscode10.workspace.onDidChangeTextDocument((event) => {
          if (event.contentChanges.length === 0) {
            return;
          }
          const textDocument = event.document;
          if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
            return;
          }
          const [notebookDocument] = this.findNotebookDocumentAndCell(textDocument);
          if (notebookDocument === void 0) {
            return;
          }
          for (const provider2 of this.registrations.values()) {
            if (provider2 instanceof NotebookDocumentSyncFeatureProvider) {
              provider2.didChangeNotebookCellTextDocument(notebookDocument, event);
            }
          }
        });
        vscode10.workspace.onDidCloseTextDocument((textDocument) => {
          if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
            return;
          }
          const [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);
          if (notebookDocument === void 0 || notebookCell === void 0) {
            return;
          }
          for (const provider2 of this.registrations.values()) {
            if (provider2 instanceof NotebookDocumentSyncFeatureProvider) {
              provider2.didCloseNotebookCellTextDocument(notebookDocument, notebookCell);
            }
          }
        });
      }
      getState() {
        if (this.registrations.size === 0) {
          return { kind: "document", id: this.registrationType.method, registrations: false, matches: false };
        }
        for (const provider2 of this.registrations.values()) {
          const state = provider2.getState();
          if (state.kind === "document" && state.registrations === true && state.matches === true) {
            return { kind: "document", id: this.registrationType.method, registrations: true, matches: true };
          }
        }
        return { kind: "document", id: this.registrationType.method, registrations: true, matches: false };
      }
      fillClientCapabilities(capabilities) {
        const synchronization = ensure(ensure(capabilities, "notebookDocument"), "synchronization");
        synchronization.dynamicRegistration = true;
        synchronization.executionSummarySupport = true;
      }
      preInitialize(capabilities) {
        const options = capabilities.notebookDocumentSync;
        if (options === void 0) {
          return;
        }
        this.dedicatedChannel = this.client.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options));
      }
      initialize(capabilities) {
        const options = capabilities.notebookDocumentSync;
        if (options === void 0) {
          return;
        }
        const id = options.id ?? UUID.generateUuid();
        this.register({ id, registerOptions: options });
      }
      register(data) {
        const provider2 = new NotebookDocumentSyncFeatureProvider(this.client, data.registerOptions);
        this.registrations.set(data.id, provider2);
      }
      unregister(id) {
        const provider2 = this.registrations.get(id);
        provider2 && provider2.dispose();
      }
      clear() {
        for (const provider2 of this.registrations.values()) {
          provider2.dispose();
        }
        this.registrations.clear();
      }
      handles(textDocument) {
        if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
          return false;
        }
        if (this.dedicatedChannel !== void 0 && vscode10.languages.match(this.dedicatedChannel, textDocument) > 0) {
          return true;
        }
        for (const provider2 of this.registrations.values()) {
          if (provider2.handles(textDocument)) {
            return true;
          }
        }
        return false;
      }
      getProvider(notebookCell) {
        for (const provider2 of this.registrations.values()) {
          if (provider2.handles(notebookCell.document)) {
            return provider2;
          }
        }
        return void 0;
      }
      findNotebookDocumentAndCell(textDocument) {
        const uri = textDocument.uri.toString();
        for (const notebookDocument of vscode10.workspace.notebookDocuments) {
          for (const cell of notebookDocument.getCells()) {
            if (cell.document.uri.toString() === uri) {
              return [notebookDocument, cell];
            }
          }
        }
        return [void 0, void 0];
      }
    };
    exports.NotebookDocumentSyncFeature = NotebookDocumentSyncFeature;
    NotebookDocumentSyncFeature.CellScheme = "vscode-notebook-cell";
  }
});

// node_modules/vscode-languageclient/lib/common/configuration.js
var require_configuration = __commonJS({
  "node_modules/vscode-languageclient/lib/common/configuration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SyncConfigurationFeature = exports.toJSONObject = exports.ConfigurationFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var UUID = require_uuid();
    var features_1 = require_features();
    var ConfigurationFeature = class {
      constructor(client) {
        this._client = client;
      }
      getState() {
        return { kind: "static" };
      }
      fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.configuration = true;
      }
      initialize() {
        let client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, (params, token) => {
          let configuration = (params2) => {
            let result = [];
            for (let item of params2.items) {
              let resource = item.scopeUri !== void 0 && item.scopeUri !== null ? this._client.protocol2CodeConverter.asUri(item.scopeUri) : void 0;
              result.push(this.getConfiguration(resource, item.section !== null ? item.section : void 0));
            }
            return result;
          };
          let middleware = client.middleware.workspace;
          return middleware && middleware.configuration ? middleware.configuration(params, token, configuration) : configuration(params, token);
        });
      }
      getConfiguration(resource, section) {
        let result = null;
        if (section) {
          let index = section.lastIndexOf(".");
          if (index === -1) {
            result = toJSONObject(vscode_1.workspace.getConfiguration(void 0, resource).get(section));
          } else {
            let config = vscode_1.workspace.getConfiguration(section.substr(0, index), resource);
            if (config) {
              result = toJSONObject(config.get(section.substr(index + 1)));
            }
          }
        } else {
          let config = vscode_1.workspace.getConfiguration(void 0, resource);
          result = {};
          for (let key of Object.keys(config)) {
            if (config.has(key)) {
              result[key] = toJSONObject(config.get(key));
            }
          }
        }
        if (result === void 0) {
          result = null;
        }
        return result;
      }
      clear() {
      }
    };
    exports.ConfigurationFeature = ConfigurationFeature;
    function toJSONObject(obj) {
      if (obj) {
        if (Array.isArray(obj)) {
          return obj.map(toJSONObject);
        } else if (typeof obj === "object") {
          const res = /* @__PURE__ */ Object.create(null);
          for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              res[key] = toJSONObject(obj[key]);
            }
          }
          return res;
        }
      }
      return obj;
    }
    exports.toJSONObject = toJSONObject;
    var SyncConfigurationFeature = class {
      constructor(_client) {
        this._client = _client;
        this.isCleared = false;
        this._listeners = /* @__PURE__ */ new Map();
      }
      getState() {
        return { kind: "workspace", id: this.registrationType.method, registrations: this._listeners.size > 0 };
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type;
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "didChangeConfiguration").dynamicRegistration = true;
      }
      initialize() {
        this.isCleared = false;
        let section = this._client.clientOptions.synchronize?.configurationSection;
        if (section !== void 0) {
          this.register({
            id: UUID.generateUuid(),
            registerOptions: {
              section
            }
          });
        }
      }
      register(data) {
        let disposable = vscode_1.workspace.onDidChangeConfiguration((event) => {
          this.onDidChangeConfiguration(data.registerOptions.section, event);
        });
        this._listeners.set(data.id, disposable);
        if (data.registerOptions.section !== void 0) {
          this.onDidChangeConfiguration(data.registerOptions.section, void 0);
        }
      }
      unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable) {
          this._listeners.delete(id);
          disposable.dispose();
        }
      }
      clear() {
        for (const disposable of this._listeners.values()) {
          disposable.dispose();
        }
        this._listeners.clear();
        this.isCleared = true;
      }
      onDidChangeConfiguration(configurationSection, event) {
        if (this.isCleared) {
          return;
        }
        let sections;
        if (Is.string(configurationSection)) {
          sections = [configurationSection];
        } else {
          sections = configurationSection;
        }
        if (sections !== void 0 && event !== void 0) {
          let affected = sections.some((section) => event.affectsConfiguration(section));
          if (!affected) {
            return;
          }
        }
        const didChangeConfiguration = async (sections2) => {
          if (sections2 === void 0) {
            return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: null });
          } else {
            return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: this.extractSettingsInformation(sections2) });
          }
        };
        let middleware = this._client.middleware.workspace?.didChangeConfiguration;
        (middleware ? middleware(sections, didChangeConfiguration) : didChangeConfiguration(sections)).catch((error) => {
          this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type.method} failed`, error);
        });
      }
      extractSettingsInformation(keys) {
        function ensurePath(config, path3) {
          let current = config;
          for (let i = 0; i < path3.length - 1; i++) {
            let obj = current[path3[i]];
            if (!obj) {
              obj = /* @__PURE__ */ Object.create(null);
              current[path3[i]] = obj;
            }
            current = obj;
          }
          return current;
        }
        let resource = this._client.clientOptions.workspaceFolder ? this._client.clientOptions.workspaceFolder.uri : void 0;
        let result = /* @__PURE__ */ Object.create(null);
        for (let i = 0; i < keys.length; i++) {
          let key = keys[i];
          let index = key.indexOf(".");
          let config = null;
          if (index >= 0) {
            config = vscode_1.workspace.getConfiguration(key.substr(0, index), resource).get(key.substr(index + 1));
          } else {
            config = vscode_1.workspace.getConfiguration(void 0, resource).get(key);
          }
          if (config) {
            let path3 = keys[i].split(".");
            ensurePath(result, path3)[path3[path3.length - 1]] = toJSONObject(config);
          }
        }
        return result;
      }
    };
    exports.SyncConfigurationFeature = SyncConfigurationFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/textSynchronization.js
var require_textSynchronization = __commonJS({
  "node_modules/vscode-languageclient/lib/common/textSynchronization.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidSaveTextDocumentFeature = exports.WillSaveWaitUntilFeature = exports.WillSaveFeature = exports.DidChangeTextDocumentFeature = exports.DidCloseTextDocumentFeature = exports.DidOpenTextDocumentFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var UUID = require_uuid();
    var DidOpenTextDocumentFeature = class extends features_1.TextDocumentEventFeature {
      constructor(client, syncedDocuments) {
        super(client, vscode_1.workspace.onDidOpenTextDocument, vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, () => client.middleware.didOpen, (textDocument) => client.code2ProtocolConverter.asOpenTextDocumentParams(textDocument), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
        this._syncedDocuments = syncedDocuments;
      }
      get openDocuments() {
        return this._syncedDocuments.values();
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
          this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector } });
        }
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type;
      }
      register(data) {
        super.register(data);
        if (!data.registerOptions.documentSelector) {
          return;
        }
        const documentSelector = this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector);
        vscode_1.workspace.textDocuments.forEach((textDocument) => {
          const uri = textDocument.uri.toString();
          if (this._syncedDocuments.has(uri)) {
            return;
          }
          if (vscode_1.languages.match(documentSelector, textDocument) > 0 && !this._client.hasDedicatedTextSynchronizationFeature(textDocument)) {
            const middleware = this._client.middleware;
            const didOpen = (textDocument2) => {
              return this._client.sendNotification(this._type, this._createParams(textDocument2));
            };
            (middleware.didOpen ? middleware.didOpen(textDocument, didOpen) : didOpen(textDocument)).catch((error) => {
              this._client.error(`Sending document notification ${this._type.method} failed`, error);
            });
            this._syncedDocuments.set(uri, textDocument);
          }
        });
      }
      getTextDocument(data) {
        return data;
      }
      notificationSent(textDocument, type, params) {
        this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
        super.notificationSent(textDocument, type, params);
      }
    };
    exports.DidOpenTextDocumentFeature = DidOpenTextDocumentFeature;
    var DidCloseTextDocumentFeature = class extends features_1.TextDocumentEventFeature {
      constructor(client, syncedDocuments, pendingTextDocumentChanges) {
        super(client, vscode_1.workspace.onDidCloseTextDocument, vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, () => client.middleware.didClose, (textDocument) => client.code2ProtocolConverter.asCloseTextDocumentParams(textDocument), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
        this._syncedDocuments = syncedDocuments;
        this._pendingTextDocumentChanges = pendingTextDocumentChanges;
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
          this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector } });
        }
      }
      async callback(data) {
        await super.callback(data);
        this._pendingTextDocumentChanges.delete(data.uri.toString());
      }
      getTextDocument(data) {
        return data;
      }
      notificationSent(textDocument, type, params) {
        this._syncedDocuments.delete(textDocument.uri.toString());
        super.notificationSent(textDocument, type, params);
      }
      unregister(id) {
        const selector = this._selectors.get(id);
        super.unregister(id);
        const selectors = this._selectors.values();
        this._syncedDocuments.forEach((textDocument) => {
          if (vscode_1.languages.match(selector, textDocument) > 0 && !this._selectorFilter(selectors, textDocument) && !this._client.hasDedicatedTextSynchronizationFeature(textDocument)) {
            let middleware = this._client.middleware;
            let didClose = (textDocument2) => {
              return this._client.sendNotification(this._type, this._createParams(textDocument2));
            };
            this._syncedDocuments.delete(textDocument.uri.toString());
            (middleware.didClose ? middleware.didClose(textDocument, didClose) : didClose(textDocument)).catch((error) => {
              this._client.error(`Sending document notification ${this._type.method} failed`, error);
            });
          }
        });
      }
    };
    exports.DidCloseTextDocumentFeature = DidCloseTextDocumentFeature;
    var DidChangeTextDocumentFeature = class extends features_1.DynamicDocumentFeature {
      constructor(client, pendingTextDocumentChanges) {
        super(client);
        this._changeData = /* @__PURE__ */ new Map();
        this._onNotificationSent = new vscode_1.EventEmitter();
        this._onPendingChangeAdded = new vscode_1.EventEmitter();
        this._pendingTextDocumentChanges = pendingTextDocumentChanges;
        this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
      }
      get onNotificationSent() {
        return this._onNotificationSent.event;
      }
      get onPendingChangeAdded() {
        return this._onPendingChangeAdded.event;
      }
      get syncKind() {
        return this._syncKind;
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== void 0 && textDocumentSyncOptions.change !== vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
          this.register({
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector }, { syncKind: textDocumentSyncOptions.change })
          });
        }
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = vscode_1.workspace.onDidChangeTextDocument(this.callback, this);
        }
        this._changeData.set(data.id, {
          syncKind: data.registerOptions.syncKind,
          documentSelector: this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector)
        });
        this.updateSyncKind(data.registerOptions.syncKind);
      }
      *getDocumentSelectors() {
        for (const data of this._changeData.values()) {
          yield data.documentSelector;
        }
      }
      async callback(event) {
        if (event.contentChanges.length === 0) {
          return;
        }
        const uri = event.document.uri;
        const version = event.document.version;
        const promises = [];
        for (const changeData of this._changeData.values()) {
          if (vscode_1.languages.match(changeData.documentSelector, event.document) > 0 && !this._client.hasDedicatedTextSynchronizationFeature(event.document)) {
            const middleware = this._client.middleware;
            if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental) {
              const didChange = async (event2) => {
                const params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event2, uri, version);
                await this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                this.notificationSent(event2.document, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
              };
              promises.push(middleware.didChange ? middleware.didChange(event, (event2) => didChange(event2)) : didChange(event));
            } else if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
              const didChange = async (event2) => {
                const eventUri = event2.document.uri.toString();
                this._pendingTextDocumentChanges.set(eventUri, event2.document);
                this._onPendingChangeAdded.fire();
              };
              promises.push(middleware.didChange ? middleware.didChange(event, (event2) => didChange(event2)) : didChange(event));
            }
          }
        }
        return Promise.all(promises).then(void 0, (error) => {
          this._client.error(`Sending document notification ${vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method} failed`, error);
          throw error;
        });
      }
      notificationSent(textDocument, type, params) {
        this._onNotificationSent.fire({ textDocument, type, params });
      }
      unregister(id) {
        this._changeData.delete(id);
        if (this._changeData.size === 0) {
          if (this._listener) {
            this._listener.dispose();
            this._listener = void 0;
          }
          this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
        } else {
          this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
          for (const changeData of this._changeData.values()) {
            this.updateSyncKind(changeData.syncKind);
            if (this._syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
              break;
            }
          }
        }
      }
      clear() {
        this._pendingTextDocumentChanges.clear();
        this._changeData.clear();
        this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      getPendingDocumentChanges(excludes) {
        if (this._pendingTextDocumentChanges.size === 0) {
          return [];
        }
        let result;
        if (excludes.size === 0) {
          result = Array.from(this._pendingTextDocumentChanges.values());
          this._pendingTextDocumentChanges.clear();
        } else {
          result = [];
          for (const entry of this._pendingTextDocumentChanges) {
            if (!excludes.has(entry[0])) {
              result.push(entry[1]);
              this._pendingTextDocumentChanges.delete(entry[0]);
            }
          }
        }
        return result;
      }
      getProvider(document) {
        for (const changeData of this._changeData.values()) {
          if (vscode_1.languages.match(changeData.documentSelector, document) > 0) {
            return {
              send: (event) => {
                return this.callback(event);
              }
            };
          }
        }
        return void 0;
      }
      updateSyncKind(syncKind) {
        if (this._syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
          return;
        }
        switch (syncKind) {
          case vscode_languageserver_protocol_1.TextDocumentSyncKind.Full:
            this._syncKind = syncKind;
            break;
          case vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental:
            if (this._syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
              this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
            }
            break;
        }
      }
    };
    exports.DidChangeTextDocumentFeature = DidChangeTextDocumentFeature;
    var WillSaveFeature = class extends features_1.TextDocumentEventFeature {
      constructor(client) {
        super(client, vscode_1.workspace.onWillSaveTextDocument, vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, () => client.middleware.willSave, (willSaveEvent) => client.code2ProtocolConverter.asWillSaveTextDocumentParams(willSaveEvent), (event) => event.document, (selectors, willSaveEvent) => features_1.TextDocumentEventFeature.textDocumentFilter(selectors, willSaveEvent.document));
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        let value = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization");
        value.willSave = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {
          this.register({
            id: UUID.generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
      getTextDocument(data) {
        return data.document;
      }
    };
    exports.WillSaveFeature = WillSaveFeature;
    var WillSaveWaitUntilFeature = class extends features_1.DynamicDocumentFeature {
      constructor(client) {
        super(client);
        this._selectors = /* @__PURE__ */ new Map();
      }
      getDocumentSelectors() {
        return this._selectors.values();
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type;
      }
      fillClientCapabilities(capabilities) {
        let value = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization");
        value.willSaveWaitUntil = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {
          this.register({
            id: UUID.generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = vscode_1.workspace.onWillSaveTextDocument(this.callback, this);
        }
        this._selectors.set(data.id, this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector));
      }
      callback(event) {
        if (features_1.TextDocumentEventFeature.textDocumentFilter(this._selectors.values(), event.document) && !this._client.hasDedicatedTextSynchronizationFeature(event.document)) {
          let middleware = this._client.middleware;
          let willSaveWaitUntil = (event2) => {
            return this._client.sendRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, this._client.code2ProtocolConverter.asWillSaveTextDocumentParams(event2)).then(async (edits) => {
              let vEdits = await this._client.protocol2CodeConverter.asTextEdits(edits);
              return vEdits === void 0 ? [] : vEdits;
            });
          };
          event.waitUntil(middleware.willSaveWaitUntil ? middleware.willSaveWaitUntil(event, willSaveWaitUntil) : willSaveWaitUntil(event));
        }
      }
      unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      clear() {
        this._selectors.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
    };
    exports.WillSaveWaitUntilFeature = WillSaveWaitUntilFeature;
    var DidSaveTextDocumentFeature = class extends features_1.TextDocumentEventFeature {
      constructor(client) {
        super(client, vscode_1.workspace.onDidSaveTextDocument, vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, () => client.middleware.didSave, (textDocument) => client.code2ProtocolConverter.asSaveTextDocumentParams(textDocument, this._includeText), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
        this._includeText = false;
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").didSave = true;
      }
      initialize(capabilities, documentSelector) {
        const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
          const saveOptions = typeof textDocumentSyncOptions.save === "boolean" ? { includeText: false } : { includeText: !!textDocumentSyncOptions.save.includeText };
          this.register({
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector }, saveOptions)
          });
        }
      }
      register(data) {
        this._includeText = !!data.registerOptions.includeText;
        super.register(data);
      }
      getTextDocument(data) {
        return data;
      }
    };
    exports.DidSaveTextDocumentFeature = DidSaveTextDocumentFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/completion.js
var require_completion = __commonJS({
  "node_modules/vscode-languageclient/lib/common/completion.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompletionItemFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var UUID = require_uuid();
    var SupportedCompletionItemKinds = [
      vscode_languageserver_protocol_1.CompletionItemKind.Text,
      vscode_languageserver_protocol_1.CompletionItemKind.Method,
      vscode_languageserver_protocol_1.CompletionItemKind.Function,
      vscode_languageserver_protocol_1.CompletionItemKind.Constructor,
      vscode_languageserver_protocol_1.CompletionItemKind.Field,
      vscode_languageserver_protocol_1.CompletionItemKind.Variable,
      vscode_languageserver_protocol_1.CompletionItemKind.Class,
      vscode_languageserver_protocol_1.CompletionItemKind.Interface,
      vscode_languageserver_protocol_1.CompletionItemKind.Module,
      vscode_languageserver_protocol_1.CompletionItemKind.Property,
      vscode_languageserver_protocol_1.CompletionItemKind.Unit,
      vscode_languageserver_protocol_1.CompletionItemKind.Value,
      vscode_languageserver_protocol_1.CompletionItemKind.Enum,
      vscode_languageserver_protocol_1.CompletionItemKind.Keyword,
      vscode_languageserver_protocol_1.CompletionItemKind.Snippet,
      vscode_languageserver_protocol_1.CompletionItemKind.Color,
      vscode_languageserver_protocol_1.CompletionItemKind.File,
      vscode_languageserver_protocol_1.CompletionItemKind.Reference,
      vscode_languageserver_protocol_1.CompletionItemKind.Folder,
      vscode_languageserver_protocol_1.CompletionItemKind.EnumMember,
      vscode_languageserver_protocol_1.CompletionItemKind.Constant,
      vscode_languageserver_protocol_1.CompletionItemKind.Struct,
      vscode_languageserver_protocol_1.CompletionItemKind.Event,
      vscode_languageserver_protocol_1.CompletionItemKind.Operator,
      vscode_languageserver_protocol_1.CompletionItemKind.TypeParameter
    ];
    var CompletionItemFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.CompletionRequest.type);
        this.labelDetailsSupport = /* @__PURE__ */ new Map();
      }
      fillClientCapabilities(capabilities) {
        let completion = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "completion");
        completion.dynamicRegistration = true;
        completion.contextSupport = true;
        completion.completionItem = {
          snippetSupport: true,
          commitCharactersSupport: true,
          documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText],
          deprecatedSupport: true,
          preselectSupport: true,
          tagSupport: { valueSet: [vscode_languageserver_protocol_1.CompletionItemTag.Deprecated] },
          insertReplaceSupport: true,
          resolveSupport: {
            properties: ["documentation", "detail", "additionalTextEdits"]
          },
          insertTextModeSupport: { valueSet: [vscode_languageserver_protocol_1.InsertTextMode.asIs, vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation] },
          labelDetailsSupport: true
        };
        completion.insertTextMode = vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation;
        completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };
        completion.completionList = {
          itemDefaults: [
            "commitCharacters",
            "editRange",
            "insertTextFormat",
            "insertTextMode",
            "data"
          ]
        };
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.completionProvider);
        if (!options) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options, id) {
        this.labelDetailsSupport.set(id, !!options.completionItem?.labelDetailsSupport);
        const triggerCharacters = options.triggerCharacters ?? [];
        const defaultCommitCharacters = options.allCommitCharacters;
        const selector = options.documentSelector;
        const provider2 = {
          provideCompletionItems: (document, position, token, context) => {
            const client = this._client;
            const middleware = this._client.middleware;
            const provideCompletionItems = (document2, position2, context2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.CompletionRequest.type, client.code2ProtocolConverter.asCompletionParams(document2, position2, context2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asCompletionResult(result, defaultCommitCharacters, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionRequest.type, token2, error, null);
              });
            };
            return middleware.provideCompletionItem ? middleware.provideCompletionItem(document, position, context, token, provideCompletionItems) : provideCompletionItems(document, position, context, token);
          },
          resolveCompletionItem: options.resolveProvider ? (item, token) => {
            const client = this._client;
            const middleware = this._client.middleware;
            const resolveCompletionItem = (item2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, client.code2ProtocolConverter.asCompletionItem(item2, !!this.labelDetailsSupport.get(id)), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asCompletionItem(result);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, token2, error, item2);
              });
            };
            return middleware.resolveCompletionItem ? middleware.resolveCompletionItem(item, token, resolveCompletionItem) : resolveCompletionItem(item, token);
          } : void 0
        };
        return [vscode_1.languages.registerCompletionItemProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2, ...triggerCharacters), provider2];
      }
    };
    exports.CompletionItemFeature = CompletionItemFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/hover.js
var require_hover = __commonJS({
  "node_modules/vscode-languageclient/lib/common/hover.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HoverFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var UUID = require_uuid();
    var HoverFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.HoverRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const hoverCapability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "hover");
        hoverCapability.dynamicRegistration = true;
        hoverCapability.contentFormat = [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText];
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.hoverProvider);
        if (!options) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider2 = {
          provideHover: (document, position, token) => {
            const client = this._client;
            const provideHover = (document2, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.HoverRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asHover(result);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.HoverRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideHover ? middleware.provideHover(document, position, token, provideHover) : provideHover(document, position, token);
          }
        };
        return [this.registerProvider(selector, provider2), provider2];
      }
      registerProvider(selector, provider2) {
        return vscode_1.languages.registerHoverProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2);
      }
    };
    exports.HoverFeature = HoverFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/definition.js
var require_definition = __commonJS({
  "node_modules/vscode-languageclient/lib/common/definition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefinitionFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var UUID = require_uuid();
    var DefinitionFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DefinitionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let definitionSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "definition");
        definitionSupport.dynamicRegistration = true;
        definitionSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.definitionProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider2 = {
          provideDefinition: (document, position, token) => {
            const client = this._client;
            const provideDefinition = (document2, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asDefinitionResult(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideDefinition ? middleware.provideDefinition(document, position, token, provideDefinition) : provideDefinition(document, position, token);
          }
        };
        return [this.registerProvider(selector, provider2), provider2];
      }
      registerProvider(selector, provider2) {
        return vscode_1.languages.registerDefinitionProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2);
      }
    };
    exports.DefinitionFeature = DefinitionFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/signatureHelp.js
var require_signatureHelp = __commonJS({
  "node_modules/vscode-languageclient/lib/common/signatureHelp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SignatureHelpFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var UUID = require_uuid();
    var SignatureHelpFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.SignatureHelpRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let config = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "signatureHelp");
        config.dynamicRegistration = true;
        config.signatureInformation = { documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText] };
        config.signatureInformation.parameterInformation = { labelOffsetSupport: true };
        config.signatureInformation.activeParameterSupport = true;
        config.contextSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.signatureHelpProvider);
        if (!options) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider2 = {
          provideSignatureHelp: (document, position, token, context) => {
            const client = this._client;
            const providerSignatureHelp = (document2, position2, context2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, client.code2ProtocolConverter.asSignatureHelpParams(document2, position2, context2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asSignatureHelp(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideSignatureHelp ? middleware.provideSignatureHelp(document, position, context, token, providerSignatureHelp) : providerSignatureHelp(document, position, context, token);
          }
        };
        return [this.registerProvider(options, provider2), provider2];
      }
      registerProvider(options, provider2) {
        const selector = this._client.protocol2CodeConverter.asDocumentSelector(options.documentSelector);
        if (options.retriggerCharacters === void 0) {
          const triggerCharacters = options.triggerCharacters || [];
          return vscode_1.languages.registerSignatureHelpProvider(selector, provider2, ...triggerCharacters);
        } else {
          const metaData = {
            triggerCharacters: options.triggerCharacters || [],
            retriggerCharacters: options.retriggerCharacters || []
          };
          return vscode_1.languages.registerSignatureHelpProvider(selector, provider2, metaData);
        }
      }
    };
    exports.SignatureHelpFeature = SignatureHelpFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/documentHighlight.js
var require_documentHighlight = __commonJS({
  "node_modules/vscode-languageclient/lib/common/documentHighlight.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentHighlightFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var UUID = require_uuid();
    var DocumentHighlightFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentHighlightRequest.type);
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "documentHighlight").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentHighlightProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider2 = {
          provideDocumentHighlights: (document, position, token) => {
            const client = this._client;
            const _provideDocumentHighlights = (document2, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asDocumentHighlights(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideDocumentHighlights ? middleware.provideDocumentHighlights(document, position, token, _provideDocumentHighlights) : _provideDocumentHighlights(document, position, token);
          }
        };
        return [vscode_1.languages.registerDocumentHighlightProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2), provider2];
      }
    };
    exports.DocumentHighlightFeature = DocumentHighlightFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/documentSymbol.js
var require_documentSymbol = __commonJS({
  "node_modules/vscode-languageclient/lib/common/documentSymbol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentSymbolFeature = exports.SupportedSymbolTags = exports.SupportedSymbolKinds = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var UUID = require_uuid();
    exports.SupportedSymbolKinds = [
      vscode_languageserver_protocol_1.SymbolKind.File,
      vscode_languageserver_protocol_1.SymbolKind.Module,
      vscode_languageserver_protocol_1.SymbolKind.Namespace,
      vscode_languageserver_protocol_1.SymbolKind.Package,
      vscode_languageserver_protocol_1.SymbolKind.Class,
      vscode_languageserver_protocol_1.SymbolKind.Method,
      vscode_languageserver_protocol_1.SymbolKind.Property,
      vscode_languageserver_protocol_1.SymbolKind.Field,
      vscode_languageserver_protocol_1.SymbolKind.Constructor,
      vscode_languageserver_protocol_1.SymbolKind.Enum,
      vscode_languageserver_protocol_1.SymbolKind.Interface,
      vscode_languageserver_protocol_1.SymbolKind.Function,
      vscode_languageserver_protocol_1.SymbolKind.Variable,
      vscode_languageserver_protocol_1.SymbolKind.Constant,
      vscode_languageserver_protocol_1.SymbolKind.String,
      vscode_languageserver_protocol_1.SymbolKind.Number,
      vscode_languageserver_protocol_1.SymbolKind.Boolean,
      vscode_languageserver_protocol_1.SymbolKind.Array,
      vscode_languageserver_protocol_1.SymbolKind.Object,
      vscode_languageserver_protocol_1.SymbolKind.Key,
      vscode_languageserver_protocol_1.SymbolKind.Null,
      vscode_languageserver_protocol_1.SymbolKind.EnumMember,
      vscode_languageserver_protocol_1.SymbolKind.Struct,
      vscode_languageserver_protocol_1.SymbolKind.Event,
      vscode_languageserver_protocol_1.SymbolKind.Operator,
      vscode_languageserver_protocol_1.SymbolKind.TypeParameter
    ];
    exports.SupportedSymbolTags = [
      vscode_languageserver_protocol_1.SymbolTag.Deprecated
    ];
    var DocumentSymbolFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentSymbolRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let symbolCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "documentSymbol");
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
          valueSet: exports.SupportedSymbolKinds
        };
        symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
        symbolCapabilities.tagSupport = {
          valueSet: exports.SupportedSymbolTags
        };
        symbolCapabilities.labelSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentSymbolProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider2 = {
          provideDocumentSymbols: (document, token) => {
            const client = this._client;
            const _provideDocumentSymbols = async (document2, token2) => {
              try {
                const data = await client.sendRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, client.code2ProtocolConverter.asDocumentSymbolParams(document2), token2);
                if (token2.isCancellationRequested || data === void 0 || data === null) {
                  return null;
                }
                if (data.length === 0) {
                  return [];
                } else {
                  const first = data[0];
                  if (vscode_languageserver_protocol_1.DocumentSymbol.is(first)) {
                    return await client.protocol2CodeConverter.asDocumentSymbols(data, token2);
                  } else {
                    return await client.protocol2CodeConverter.asSymbolInformations(data, token2);
                  }
                }
              } catch (error) {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, token2, error, null);
              }
            };
            const middleware = client.middleware;
            return middleware.provideDocumentSymbols ? middleware.provideDocumentSymbols(document, token, _provideDocumentSymbols) : _provideDocumentSymbols(document, token);
          }
        };
        const metaData = options.label !== void 0 ? { label: options.label } : void 0;
        return [vscode_1.languages.registerDocumentSymbolProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2, metaData), provider2];
      }
    };
    exports.DocumentSymbolFeature = DocumentSymbolFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/workspaceSymbol.js
var require_workspaceSymbol = __commonJS({
  "node_modules/vscode-languageclient/lib/common/workspaceSymbol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkspaceSymbolFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var documentSymbol_1 = require_documentSymbol();
    var UUID = require_uuid();
    var WorkspaceSymbolFeature = class extends features_1.WorkspaceFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let symbolCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "symbol");
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
          valueSet: documentSymbol_1.SupportedSymbolKinds
        };
        symbolCapabilities.tagSupport = {
          valueSet: documentSymbol_1.SupportedSymbolTags
        };
        symbolCapabilities.resolveSupport = { properties: ["location.range"] };
      }
      initialize(capabilities) {
        if (!capabilities.workspaceSymbolProvider) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: capabilities.workspaceSymbolProvider === true ? { workDoneProgress: false } : capabilities.workspaceSymbolProvider
        });
      }
      registerLanguageProvider(options) {
        const provider2 = {
          provideWorkspaceSymbols: (query, token) => {
            const client = this._client;
            const provideWorkspaceSymbols = (query2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, { query: query2 }, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asSymbolInformations(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideWorkspaceSymbols ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols) : provideWorkspaceSymbols(query, token);
          },
          resolveWorkspaceSymbol: options.resolveProvider === true ? (item, token) => {
            const client = this._client;
            const resolveWorkspaceSymbol = (item2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, client.code2ProtocolConverter.asWorkspaceSymbol(item2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asSymbolInformation(result);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.resolveWorkspaceSymbol ? middleware.resolveWorkspaceSymbol(item, token, resolveWorkspaceSymbol) : resolveWorkspaceSymbol(item, token);
          } : void 0
        };
        return [vscode_1.languages.registerWorkspaceSymbolProvider(provider2), provider2];
      }
    };
    exports.WorkspaceSymbolFeature = WorkspaceSymbolFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/reference.js
var require_reference = __commonJS({
  "node_modules/vscode-languageclient/lib/common/reference.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReferencesFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var UUID = require_uuid();
    var ReferencesFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.ReferencesRequest.type);
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "references").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.referencesProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider2 = {
          provideReferences: (document, position, options2, token) => {
            const client = this._client;
            const _providerReferences = (document2, position2, options3, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, client.code2ProtocolConverter.asReferenceParams(document2, position2, options3), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asReferences(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideReferences ? middleware.provideReferences(document, position, options2, token, _providerReferences) : _providerReferences(document, position, options2, token);
          }
        };
        return [this.registerProvider(selector, provider2), provider2];
      }
      registerProvider(selector, provider2) {
        return vscode_1.languages.registerReferenceProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2);
      }
    };
    exports.ReferencesFeature = ReferencesFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/codeAction.js
var require_codeAction = __commonJS({
  "node_modules/vscode-languageclient/lib/common/codeAction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeActionFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var UUID = require_uuid();
    var features_1 = require_features();
    var CodeActionFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeActionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const cap = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "codeAction");
        cap.dynamicRegistration = true;
        cap.isPreferredSupport = true;
        cap.disabledSupport = true;
        cap.dataSupport = true;
        cap.resolveSupport = {
          properties: ["edit"]
        };
        cap.codeActionLiteralSupport = {
          codeActionKind: {
            valueSet: [
              vscode_languageserver_protocol_1.CodeActionKind.Empty,
              vscode_languageserver_protocol_1.CodeActionKind.QuickFix,
              vscode_languageserver_protocol_1.CodeActionKind.Refactor,
              vscode_languageserver_protocol_1.CodeActionKind.RefactorExtract,
              vscode_languageserver_protocol_1.CodeActionKind.RefactorInline,
              vscode_languageserver_protocol_1.CodeActionKind.RefactorRewrite,
              vscode_languageserver_protocol_1.CodeActionKind.Source,
              vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports
            ]
          }
        };
        cap.honorsChangeAnnotations = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeActionProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider2 = {
          provideCodeActions: (document, range, context, token) => {
            const client = this._client;
            const _provideCodeActions = async (document2, range2, context2, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                range: client.code2ProtocolConverter.asRange(range2),
                context: client.code2ProtocolConverter.asCodeActionContextSync(context2)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, params, token2).then((values) => {
                if (token2.isCancellationRequested || values === null || values === void 0) {
                  return null;
                }
                return client.protocol2CodeConverter.asCodeActionResult(values, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideCodeActions ? middleware.provideCodeActions(document, range, context, token, _provideCodeActions) : _provideCodeActions(document, range, context, token);
          },
          resolveCodeAction: options.resolveProvider ? (item, token) => {
            const client = this._client;
            const middleware = this._client.middleware;
            const resolveCodeAction = async (item2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, client.code2ProtocolConverter.asCodeActionSync(item2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return item2;
                }
                return client.protocol2CodeConverter.asCodeAction(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, token2, error, item2);
              });
            };
            return middleware.resolveCodeAction ? middleware.resolveCodeAction(item, token, resolveCodeAction) : resolveCodeAction(item, token);
          } : void 0
        };
        return [vscode_1.languages.registerCodeActionsProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2, options.codeActionKinds ? { providedCodeActionKinds: this._client.protocol2CodeConverter.asCodeActionKinds(options.codeActionKinds) } : void 0), provider2];
      }
    };
    exports.CodeActionFeature = CodeActionFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/codeLens.js
var require_codeLens = __commonJS({
  "node_modules/vscode-languageclient/lib/common/codeLens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeLensFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var UUID = require_uuid();
    var features_1 = require_features();
    var CodeLensFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeLensRequest.type);
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "codeLens").dynamicRegistration = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "codeLens").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.CodeLensRefreshRequest.type, async () => {
          for (const provider2 of this.getAllProviders()) {
            provider2.onDidChangeCodeLensEmitter.fire();
          }
        });
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const eventEmitter = new vscode_1.EventEmitter();
        const provider2 = {
          onDidChangeCodeLenses: eventEmitter.event,
          provideCodeLenses: (document, token) => {
            const client = this._client;
            const provideCodeLenses = (document2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, client.code2ProtocolConverter.asCodeLensParams(document2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asCodeLenses(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideCodeLenses ? middleware.provideCodeLenses(document, token, provideCodeLenses) : provideCodeLenses(document, token);
          },
          resolveCodeLens: options.resolveProvider ? (codeLens, token) => {
            const client = this._client;
            const resolveCodeLens = (codeLens2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, client.code2ProtocolConverter.asCodeLens(codeLens2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return codeLens2;
                }
                return client.protocol2CodeConverter.asCodeLens(result);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, token2, error, codeLens2);
              });
            };
            const middleware = client.middleware;
            return middleware.resolveCodeLens ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens) : resolveCodeLens(codeLens, token);
          } : void 0
        };
        return [vscode_1.languages.registerCodeLensProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2), { provider: provider2, onDidChangeCodeLensEmitter: eventEmitter }];
      }
    };
    exports.CodeLensFeature = CodeLensFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/formatting.js
var require_formatting = __commonJS({
  "node_modules/vscode-languageclient/lib/common/formatting.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentOnTypeFormattingFeature = exports.DocumentRangeFormattingFeature = exports.DocumentFormattingFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var UUID = require_uuid();
    var features_1 = require_features();
    var FileFormattingOptions;
    (function(FileFormattingOptions2) {
      function fromConfiguration(document) {
        const filesConfig = vscode_1.workspace.getConfiguration("files", document);
        return {
          trimTrailingWhitespace: filesConfig.get("trimTrailingWhitespace"),
          trimFinalNewlines: filesConfig.get("trimFinalNewlines"),
          insertFinalNewline: filesConfig.get("insertFinalNewline")
        };
      }
      FileFormattingOptions2.fromConfiguration = fromConfiguration;
    })(FileFormattingOptions || (FileFormattingOptions = {}));
    var DocumentFormattingFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "formatting").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentFormattingProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider2 = {
          provideDocumentFormattingEdits: (document, options2, token) => {
            const client = this._client;
            const provideDocumentFormattingEdits = (document2, options3, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                options: client.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document2))
              };
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, params, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asTextEdits(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideDocumentFormattingEdits ? middleware.provideDocumentFormattingEdits(document, options2, token, provideDocumentFormattingEdits) : provideDocumentFormattingEdits(document, options2, token);
          }
        };
        return [vscode_1.languages.registerDocumentFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2), provider2];
      }
    };
    exports.DocumentFormattingFeature = DocumentFormattingFeature;
    var DocumentRangeFormattingFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "rangeFormatting");
        capability.dynamicRegistration = true;
        capability.rangesSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentRangeFormattingProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider2 = {
          provideDocumentRangeFormattingEdits: (document, range, options2, token) => {
            const client = this._client;
            const provideDocumentRangeFormattingEdits = (document2, range2, options3, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                range: client.code2ProtocolConverter.asRange(range2),
                options: client.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document2))
              };
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, params, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asTextEdits(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideDocumentRangeFormattingEdits ? middleware.provideDocumentRangeFormattingEdits(document, range, options2, token, provideDocumentRangeFormattingEdits) : provideDocumentRangeFormattingEdits(document, range, options2, token);
          }
        };
        if (options.rangesSupport) {
          provider2.provideDocumentRangesFormattingEdits = (document, ranges, options2, token) => {
            const client = this._client;
            const provideDocumentRangesFormattingEdits = (document2, ranges2, options3, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                ranges: client.code2ProtocolConverter.asRanges(ranges2),
                options: client.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document2))
              };
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentRangesFormattingRequest.type, params, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asTextEdits(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentRangesFormattingRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideDocumentRangesFormattingEdits ? middleware.provideDocumentRangesFormattingEdits(document, ranges, options2, token, provideDocumentRangesFormattingEdits) : provideDocumentRangesFormattingEdits(document, ranges, options2, token);
          };
        }
        return [vscode_1.languages.registerDocumentRangeFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2), provider2];
      }
    };
    exports.DocumentRangeFormattingFeature = DocumentRangeFormattingFeature;
    var DocumentOnTypeFormattingFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "onTypeFormatting").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentOnTypeFormattingProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider2 = {
          provideOnTypeFormattingEdits: (document, position, ch, options2, token) => {
            const client = this._client;
            const provideOnTypeFormattingEdits = (document2, position2, ch2, options3, token2) => {
              let params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                position: client.code2ProtocolConverter.asPosition(position2),
                ch: ch2,
                options: client.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document2))
              };
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, params, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asTextEdits(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideOnTypeFormattingEdits ? middleware.provideOnTypeFormattingEdits(document, position, ch, options2, token, provideOnTypeFormattingEdits) : provideOnTypeFormattingEdits(document, position, ch, options2, token);
          }
        };
        const moreTriggerCharacter = options.moreTriggerCharacter || [];
        return [vscode_1.languages.registerOnTypeFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2, options.firstTriggerCharacter, ...moreTriggerCharacter), provider2];
      }
    };
    exports.DocumentOnTypeFormattingFeature = DocumentOnTypeFormattingFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/rename.js
var require_rename = __commonJS({
  "node_modules/vscode-languageclient/lib/common/rename.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RenameFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var UUID = require_uuid();
    var Is = require_is();
    var features_1 = require_features();
    var RenameFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.RenameRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let rename = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "rename");
        rename.dynamicRegistration = true;
        rename.prepareSupport = true;
        rename.prepareSupportDefaultBehavior = vscode_languageserver_protocol_1.PrepareSupportDefaultBehavior.Identifier;
        rename.honorsChangeAnnotations = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.renameProvider);
        if (!options) {
          return;
        }
        if (Is.boolean(capabilities.renameProvider)) {
          options.prepareProvider = false;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider2 = {
          provideRenameEdits: (document, position, newName, token) => {
            const client = this._client;
            const provideRenameEdits = (document2, position2, newName2, token2) => {
              let params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                position: client.code2ProtocolConverter.asPosition(position2),
                newName: newName2
              };
              return client.sendRequest(vscode_languageserver_protocol_1.RenameRequest.type, params, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asWorkspaceEdit(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.RenameRequest.type, token2, error, null, false);
              });
            };
            const middleware = client.middleware;
            return middleware.provideRenameEdits ? middleware.provideRenameEdits(document, position, newName, token, provideRenameEdits) : provideRenameEdits(document, position, newName, token);
          },
          prepareRename: options.prepareProvider ? (document, position, token) => {
            const client = this._client;
            const prepareRename = (document2, position2, token2) => {
              let params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                position: client.code2ProtocolConverter.asPosition(position2)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, params, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                if (vscode_languageserver_protocol_1.Range.is(result)) {
                  return client.protocol2CodeConverter.asRange(result);
                } else if (this.isDefaultBehavior(result)) {
                  return result.defaultBehavior === true ? null : Promise.reject(new Error(`The element can't be renamed.`));
                } else if (result && vscode_languageserver_protocol_1.Range.is(result.range)) {
                  return {
                    range: client.protocol2CodeConverter.asRange(result.range),
                    placeholder: result.placeholder
                  };
                }
                return Promise.reject(new Error(`The element can't be renamed.`));
              }, (error) => {
                if (typeof error.message === "string") {
                  throw new Error(error.message);
                } else {
                  throw new Error(`The element can't be renamed.`);
                }
              });
            };
            const middleware = client.middleware;
            return middleware.prepareRename ? middleware.prepareRename(document, position, token, prepareRename) : prepareRename(document, position, token);
          } : void 0
        };
        return [this.registerProvider(selector, provider2), provider2];
      }
      registerProvider(selector, provider2) {
        return vscode_1.languages.registerRenameProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2);
      }
      isDefaultBehavior(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.defaultBehavior);
      }
    };
    exports.RenameFeature = RenameFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/documentLink.js
var require_documentLink = __commonJS({
  "node_modules/vscode-languageclient/lib/common/documentLink.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentLinkFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var UUID = require_uuid();
    var DocumentLinkFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentLinkRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const documentLinkCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "documentLink");
        documentLinkCapabilities.dynamicRegistration = true;
        documentLinkCapabilities.tooltipSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentLinkProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider2 = {
          provideDocumentLinks: (document, token) => {
            const client = this._client;
            const provideDocumentLinks = (document2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, client.code2ProtocolConverter.asDocumentLinkParams(document2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asDocumentLinks(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideDocumentLinks ? middleware.provideDocumentLinks(document, token, provideDocumentLinks) : provideDocumentLinks(document, token);
          },
          resolveDocumentLink: options.resolveProvider ? (link, token) => {
            const client = this._client;
            let resolveDocumentLink = (link2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, client.code2ProtocolConverter.asDocumentLink(link2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return link2;
                }
                return client.protocol2CodeConverter.asDocumentLink(result);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, token2, error, link2);
              });
            };
            const middleware = client.middleware;
            return middleware.resolveDocumentLink ? middleware.resolveDocumentLink(link, token, resolveDocumentLink) : resolveDocumentLink(link, token);
          } : void 0
        };
        return [vscode_1.languages.registerDocumentLinkProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2), provider2];
      }
    };
    exports.DocumentLinkFeature = DocumentLinkFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/executeCommand.js
var require_executeCommand = __commonJS({
  "node_modules/vscode-languageclient/lib/common/executeCommand.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExecuteCommandFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var UUID = require_uuid();
    var features_1 = require_features();
    var ExecuteCommandFeature = class {
      constructor(client) {
        this._client = client;
        this._commands = /* @__PURE__ */ new Map();
      }
      getState() {
        return { kind: "workspace", id: this.registrationType.method, registrations: this._commands.size > 0 };
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.ExecuteCommandRequest.type;
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "executeCommand").dynamicRegistration = true;
      }
      initialize(capabilities) {
        if (!capabilities.executeCommandProvider) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: Object.assign({}, capabilities.executeCommandProvider)
        });
      }
      register(data) {
        const client = this._client;
        const middleware = client.middleware;
        const executeCommand = (command, args) => {
          let params = {
            command,
            arguments: args
          };
          return client.sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params).then(void 0, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, void 0, error, void 0);
          });
        };
        if (data.registerOptions.commands) {
          const disposables = [];
          for (const command of data.registerOptions.commands) {
            disposables.push(vscode_1.commands.registerCommand(command, (...args) => {
              return middleware.executeCommand ? middleware.executeCommand(command, args, executeCommand) : executeCommand(command, args);
            }));
          }
          this._commands.set(data.id, disposables);
        }
      }
      unregister(id) {
        let disposables = this._commands.get(id);
        if (disposables) {
          disposables.forEach((disposable) => disposable.dispose());
        }
      }
      clear() {
        this._commands.forEach((value) => {
          value.forEach((disposable) => disposable.dispose());
        });
        this._commands.clear();
      }
    };
    exports.ExecuteCommandFeature = ExecuteCommandFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/fileSystemWatcher.js
var require_fileSystemWatcher = __commonJS({
  "node_modules/vscode-languageclient/lib/common/fileSystemWatcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileSystemWatcherFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var FileSystemWatcherFeature = class {
      constructor(client, notifyFileEvent) {
        this._client = client;
        this._notifyFileEvent = notifyFileEvent;
        this._watchers = /* @__PURE__ */ new Map();
      }
      getState() {
        return { kind: "workspace", id: this.registrationType.method, registrations: this._watchers.size > 0 };
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type;
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "didChangeWatchedFiles").dynamicRegistration = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "didChangeWatchedFiles").relativePatternSupport = true;
      }
      initialize(_capabilities, _documentSelector) {
      }
      register(data) {
        if (!Array.isArray(data.registerOptions.watchers)) {
          return;
        }
        const disposables = [];
        for (const watcher of data.registerOptions.watchers) {
          const globPattern = this._client.protocol2CodeConverter.asGlobPattern(watcher.globPattern);
          if (globPattern === void 0) {
            continue;
          }
          let watchCreate = true, watchChange = true, watchDelete = true;
          if (watcher.kind !== void 0 && watcher.kind !== null) {
            watchCreate = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Create) !== 0;
            watchChange = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Change) !== 0;
            watchDelete = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Delete) !== 0;
          }
          const fileSystemWatcher = vscode_1.workspace.createFileSystemWatcher(globPattern, !watchCreate, !watchChange, !watchDelete);
          this.hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, disposables);
          disposables.push(fileSystemWatcher);
        }
        this._watchers.set(data.id, disposables);
      }
      registerRaw(id, fileSystemWatchers) {
        let disposables = [];
        for (let fileSystemWatcher of fileSystemWatchers) {
          this.hookListeners(fileSystemWatcher, true, true, true, disposables);
        }
        this._watchers.set(id, disposables);
      }
      hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {
        if (watchCreate) {
          fileSystemWatcher.onDidCreate((resource) => this._notifyFileEvent({
            uri: this._client.code2ProtocolConverter.asUri(resource),
            type: vscode_languageserver_protocol_1.FileChangeType.Created
          }), null, listeners);
        }
        if (watchChange) {
          fileSystemWatcher.onDidChange((resource) => this._notifyFileEvent({
            uri: this._client.code2ProtocolConverter.asUri(resource),
            type: vscode_languageserver_protocol_1.FileChangeType.Changed
          }), null, listeners);
        }
        if (watchDelete) {
          fileSystemWatcher.onDidDelete((resource) => this._notifyFileEvent({
            uri: this._client.code2ProtocolConverter.asUri(resource),
            type: vscode_languageserver_protocol_1.FileChangeType.Deleted
          }), null, listeners);
        }
      }
      unregister(id) {
        let disposables = this._watchers.get(id);
        if (disposables) {
          for (let disposable of disposables) {
            disposable.dispose();
          }
        }
      }
      clear() {
        this._watchers.forEach((disposables) => {
          for (let disposable of disposables) {
            disposable.dispose();
          }
        });
        this._watchers.clear();
      }
    };
    exports.FileSystemWatcherFeature = FileSystemWatcherFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/colorProvider.js
var require_colorProvider = __commonJS({
  "node_modules/vscode-languageclient/lib/common/colorProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColorProviderFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var ColorProviderFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentColorRequest.type);
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "colorProvider").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.colorProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider2 = {
          provideColorPresentations: (color, context, token) => {
            const client = this._client;
            const provideColorPresentations = (color2, context2, token2) => {
              const requestParams = {
                color: color2,
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(context2.document),
                range: client.code2ProtocolConverter.asRange(context2.range)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, requestParams, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return this._client.protocol2CodeConverter.asColorPresentations(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideColorPresentations ? middleware.provideColorPresentations(color, context, token, provideColorPresentations) : provideColorPresentations(color, context, token);
          },
          provideDocumentColors: (document, token) => {
            const client = this._client;
            const provideDocumentColors = (document2, token2) => {
              const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, requestParams, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return this._client.protocol2CodeConverter.asColorInformations(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideDocumentColors ? middleware.provideDocumentColors(document, token, provideDocumentColors) : provideDocumentColors(document, token);
          }
        };
        return [vscode_1.languages.registerColorProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2), provider2];
      }
    };
    exports.ColorProviderFeature = ColorProviderFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/implementation.js
var require_implementation = __commonJS({
  "node_modules/vscode-languageclient/lib/common/implementation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImplementationFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var ImplementationFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.ImplementationRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let implementationSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "implementation");
        implementationSupport.dynamicRegistration = true;
        implementationSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.implementationProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider2 = {
          provideImplementation: (document, position, token) => {
            const client = this._client;
            const provideImplementation = (document2, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asDefinitionResult(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideImplementation ? middleware.provideImplementation(document, position, token, provideImplementation) : provideImplementation(document, position, token);
          }
        };
        return [this.registerProvider(selector, provider2), provider2];
      }
      registerProvider(selector, provider2) {
        return vscode_1.languages.registerImplementationProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2);
      }
    };
    exports.ImplementationFeature = ImplementationFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/typeDefinition.js
var require_typeDefinition = __commonJS({
  "node_modules/vscode-languageclient/lib/common/typeDefinition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeDefinitionFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var TypeDefinitionFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.TypeDefinitionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "typeDefinition").dynamicRegistration = true;
        let typeDefinitionSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "typeDefinition");
        typeDefinitionSupport.dynamicRegistration = true;
        typeDefinitionSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.typeDefinitionProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider2 = {
          provideTypeDefinition: (document, position, token) => {
            const client = this._client;
            const provideTypeDefinition = (document2, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asDefinitionResult(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideTypeDefinition ? middleware.provideTypeDefinition(document, position, token, provideTypeDefinition) : provideTypeDefinition(document, position, token);
          }
        };
        return [this.registerProvider(selector, provider2), provider2];
      }
      registerProvider(selector, provider2) {
        return vscode_1.languages.registerTypeDefinitionProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2);
      }
    };
    exports.TypeDefinitionFeature = TypeDefinitionFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/workspaceFolder.js
var require_workspaceFolder = __commonJS({
  "node_modules/vscode-languageclient/lib/common/workspaceFolder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkspaceFoldersFeature = exports.arrayDiff = void 0;
    var UUID = require_uuid();
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    function access(target, key) {
      if (target === void 0 || target === null) {
        return void 0;
      }
      return target[key];
    }
    function arrayDiff(left, right) {
      return left.filter((element) => right.indexOf(element) < 0);
    }
    exports.arrayDiff = arrayDiff;
    var WorkspaceFoldersFeature = class {
      constructor(client) {
        this._client = client;
        this._listeners = /* @__PURE__ */ new Map();
      }
      getState() {
        return { kind: "workspace", id: this.registrationType.method, registrations: this._listeners.size > 0 };
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type;
      }
      fillInitializeParams(params) {
        const folders = vscode_1.workspace.workspaceFolders;
        this.initializeWithFolders(folders);
        if (folders === void 0) {
          params.workspaceFolders = null;
        } else {
          params.workspaceFolders = folders.map((folder) => this.asProtocol(folder));
        }
      }
      initializeWithFolders(currentWorkspaceFolders) {
        this._initialFolders = currentWorkspaceFolders;
      }
      fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.workspaceFolders = true;
      }
      initialize(capabilities) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type, (token) => {
          const workspaceFolders = () => {
            const folders = vscode_1.workspace.workspaceFolders;
            if (folders === void 0) {
              return null;
            }
            const result = folders.map((folder) => {
              return this.asProtocol(folder);
            });
            return result;
          };
          const middleware = client.middleware.workspace;
          return middleware && middleware.workspaceFolders ? middleware.workspaceFolders(token, workspaceFolders) : workspaceFolders(token);
        });
        const value = access(access(access(capabilities, "workspace"), "workspaceFolders"), "changeNotifications");
        let id;
        if (typeof value === "string") {
          id = value;
        } else if (value === true) {
          id = UUID.generateUuid();
        }
        if (id) {
          this.register({ id, registerOptions: void 0 });
        }
      }
      sendInitialEvent(currentWorkspaceFolders) {
        let promise;
        if (this._initialFolders && currentWorkspaceFolders) {
          const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);
          const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
          if (added.length > 0 || removed.length > 0) {
            promise = this.doSendEvent(added, removed);
          }
        } else if (this._initialFolders) {
          promise = this.doSendEvent([], this._initialFolders);
        } else if (currentWorkspaceFolders) {
          promise = this.doSendEvent(currentWorkspaceFolders, []);
        }
        if (promise !== void 0) {
          promise.catch((error) => {
            this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
          });
        }
      }
      doSendEvent(addedFolders, removedFolders) {
        let params = {
          event: {
            added: addedFolders.map((folder) => this.asProtocol(folder)),
            removed: removedFolders.map((folder) => this.asProtocol(folder))
          }
        };
        return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, params);
      }
      register(data) {
        let id = data.id;
        let client = this._client;
        let disposable = vscode_1.workspace.onDidChangeWorkspaceFolders((event) => {
          let didChangeWorkspaceFolders = (event2) => {
            return this.doSendEvent(event2.added, event2.removed);
          };
          let middleware = client.middleware.workspace;
          const promise = middleware && middleware.didChangeWorkspaceFolders ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders) : didChangeWorkspaceFolders(event);
          promise.catch((error) => {
            this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
          });
        });
        this._listeners.set(id, disposable);
        this.sendInitialEvent(vscode_1.workspace.workspaceFolders);
      }
      unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable === void 0) {
          return;
        }
        this._listeners.delete(id);
        disposable.dispose();
      }
      clear() {
        for (let disposable of this._listeners.values()) {
          disposable.dispose();
        }
        this._listeners.clear();
      }
      asProtocol(workspaceFolder) {
        if (workspaceFolder === void 0) {
          return null;
        }
        return { uri: this._client.code2ProtocolConverter.asUri(workspaceFolder.uri), name: workspaceFolder.name };
      }
    };
    exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/foldingRange.js
var require_foldingRange = __commonJS({
  "node_modules/vscode-languageclient/lib/common/foldingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FoldingRangeFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var FoldingRangeFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.FoldingRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "foldingRange");
        capability.dynamicRegistration = true;
        capability.rangeLimit = 5e3;
        capability.lineFoldingOnly = true;
        capability.foldingRangeKind = { valueSet: [vscode_languageserver_protocol_1.FoldingRangeKind.Comment, vscode_languageserver_protocol_1.FoldingRangeKind.Imports, vscode_languageserver_protocol_1.FoldingRangeKind.Region] };
        capability.foldingRange = { collapsedText: false };
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "foldingRange").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        this._client.onRequest(vscode_languageserver_protocol_1.FoldingRangeRefreshRequest.type, async () => {
          for (const provider2 of this.getAllProviders()) {
            provider2.onDidChangeFoldingRange.fire();
          }
        });
        let [id, options] = this.getRegistration(documentSelector, capabilities.foldingRangeProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const eventEmitter = new vscode_1.EventEmitter();
        const provider2 = {
          onDidChangeFoldingRanges: eventEmitter.event,
          provideFoldingRanges: (document, context, token) => {
            const client = this._client;
            const provideFoldingRanges = (document2, _, token2) => {
              const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, requestParams, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asFoldingRanges(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideFoldingRanges ? middleware.provideFoldingRanges(document, context, token, provideFoldingRanges) : provideFoldingRanges(document, context, token);
          }
        };
        return [vscode_1.languages.registerFoldingRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2), { provider: provider2, onDidChangeFoldingRange: eventEmitter }];
      }
    };
    exports.FoldingRangeFeature = FoldingRangeFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/declaration.js
var require_declaration = __commonJS({
  "node_modules/vscode-languageclient/lib/common/declaration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeclarationFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var DeclarationFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DeclarationRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const declarationSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "declaration");
        declarationSupport.dynamicRegistration = true;
        declarationSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.declarationProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider2 = {
          provideDeclaration: (document, position, token) => {
            const client = this._client;
            const provideDeclaration = (document2, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asDeclarationResult(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideDeclaration ? middleware.provideDeclaration(document, position, token, provideDeclaration) : provideDeclaration(document, position, token);
          }
        };
        return [this.registerProvider(selector, provider2), provider2];
      }
      registerProvider(selector, provider2) {
        return vscode_1.languages.registerDeclarationProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2);
      }
    };
    exports.DeclarationFeature = DeclarationFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/selectionRange.js
var require_selectionRange = __commonJS({
  "node_modules/vscode-languageclient/lib/common/selectionRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectionRangeFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var SelectionRangeFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.SelectionRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "selectionRange");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.selectionRangeProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider2 = {
          provideSelectionRanges: (document, positions, token) => {
            const client = this._client;
            const provideSelectionRanges = async (document2, positions2, token2) => {
              const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                positions: client.code2ProtocolConverter.asPositionsSync(positions2, token2)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, requestParams, token2).then((ranges) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asSelectionRanges(ranges, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideSelectionRanges ? middleware.provideSelectionRanges(document, positions, token, provideSelectionRanges) : provideSelectionRanges(document, positions, token);
          }
        };
        return [this.registerProvider(selector, provider2), provider2];
      }
      registerProvider(selector, provider2) {
        return vscode_1.languages.registerSelectionRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2);
      }
    };
    exports.SelectionRangeFeature = SelectionRangeFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/progress.js
var require_progress = __commonJS({
  "node_modules/vscode-languageclient/lib/common/progress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProgressFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var progressPart_1 = require_progressPart();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = /* @__PURE__ */ Object.create(null);
      }
      return target[key];
    }
    var ProgressFeature = class {
      constructor(_client) {
        this._client = _client;
        this.activeParts = /* @__PURE__ */ new Set();
      }
      getState() {
        return { kind: "window", id: vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.method, registrations: this.activeParts.size > 0 };
      }
      fillClientCapabilities(capabilities) {
        ensure(capabilities, "window").workDoneProgress = true;
      }
      initialize() {
        const client = this._client;
        const deleteHandler = (part) => {
          this.activeParts.delete(part);
        };
        const createHandler = (params) => {
          this.activeParts.add(new progressPart_1.ProgressPart(this._client, params.token, deleteHandler));
        };
        client.onRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, createHandler);
      }
      clear() {
        for (const part of this.activeParts) {
          part.done();
        }
        this.activeParts.clear();
      }
    };
    exports.ProgressFeature = ProgressFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/callHierarchy.js
var require_callHierarchy = __commonJS({
  "node_modules/vscode-languageclient/lib/common/callHierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CallHierarchyFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var CallHierarchyProvider = class {
      constructor(client) {
        this.client = client;
        this.middleware = client.middleware;
      }
      prepareCallHierarchy(document, position, token) {
        const client = this.client;
        const middleware = this.middleware;
        const prepareCallHierarchy = (document2, position2, token2) => {
          const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2);
          return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, params, token2).then((result) => {
            if (token2.isCancellationRequested) {
              return null;
            }
            return client.protocol2CodeConverter.asCallHierarchyItems(result, token2);
          }, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, token2, error, null);
          });
        };
        return middleware.prepareCallHierarchy ? middleware.prepareCallHierarchy(document, position, token, prepareCallHierarchy) : prepareCallHierarchy(document, position, token);
      }
      provideCallHierarchyIncomingCalls(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideCallHierarchyIncomingCalls = (item2, token2) => {
          const params = {
            item: client.code2ProtocolConverter.asCallHierarchyItem(item2)
          };
          return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, params, token2).then((result) => {
            if (token2.isCancellationRequested) {
              return null;
            }
            return client.protocol2CodeConverter.asCallHierarchyIncomingCalls(result, token2);
          }, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, token2, error, null);
          });
        };
        return middleware.provideCallHierarchyIncomingCalls ? middleware.provideCallHierarchyIncomingCalls(item, token, provideCallHierarchyIncomingCalls) : provideCallHierarchyIncomingCalls(item, token);
      }
      provideCallHierarchyOutgoingCalls(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideCallHierarchyOutgoingCalls = (item2, token2) => {
          const params = {
            item: client.code2ProtocolConverter.asCallHierarchyItem(item2)
          };
          return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, params, token2).then((result) => {
            if (token2.isCancellationRequested) {
              return null;
            }
            return client.protocol2CodeConverter.asCallHierarchyOutgoingCalls(result, token2);
          }, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, token2, error, null);
          });
        };
        return middleware.provideCallHierarchyOutgoingCalls ? middleware.provideCallHierarchyOutgoingCalls(item, token, provideCallHierarchyOutgoingCalls) : provideCallHierarchyOutgoingCalls(item, token);
      }
    };
    var CallHierarchyFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type);
      }
      fillClientCapabilities(cap) {
        const capabilities = cap;
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "callHierarchy");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.callHierarchyProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const client = this._client;
        const provider2 = new CallHierarchyProvider(client);
        return [vscode_1.languages.registerCallHierarchyProvider(this._client.protocol2CodeConverter.asDocumentSelector(options.documentSelector), provider2), provider2];
      }
    };
    exports.CallHierarchyFeature = CallHierarchyFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/semanticTokens.js
var require_semanticTokens = __commonJS({
  "node_modules/vscode-languageclient/lib/common/semanticTokens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SemanticTokensFeature = void 0;
    var vscode10 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var Is = require_is();
    var SemanticTokensFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.SemanticTokensRegistrationType.type);
      }
      fillClientCapabilities(capabilities) {
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "semanticTokens");
        capability.dynamicRegistration = true;
        capability.tokenTypes = [
          vscode_languageserver_protocol_1.SemanticTokenTypes.namespace,
          vscode_languageserver_protocol_1.SemanticTokenTypes.type,
          vscode_languageserver_protocol_1.SemanticTokenTypes.class,
          vscode_languageserver_protocol_1.SemanticTokenTypes.enum,
          vscode_languageserver_protocol_1.SemanticTokenTypes.interface,
          vscode_languageserver_protocol_1.SemanticTokenTypes.struct,
          vscode_languageserver_protocol_1.SemanticTokenTypes.typeParameter,
          vscode_languageserver_protocol_1.SemanticTokenTypes.parameter,
          vscode_languageserver_protocol_1.SemanticTokenTypes.variable,
          vscode_languageserver_protocol_1.SemanticTokenTypes.property,
          vscode_languageserver_protocol_1.SemanticTokenTypes.enumMember,
          vscode_languageserver_protocol_1.SemanticTokenTypes.event,
          vscode_languageserver_protocol_1.SemanticTokenTypes.function,
          vscode_languageserver_protocol_1.SemanticTokenTypes.method,
          vscode_languageserver_protocol_1.SemanticTokenTypes.macro,
          vscode_languageserver_protocol_1.SemanticTokenTypes.keyword,
          vscode_languageserver_protocol_1.SemanticTokenTypes.modifier,
          vscode_languageserver_protocol_1.SemanticTokenTypes.comment,
          vscode_languageserver_protocol_1.SemanticTokenTypes.string,
          vscode_languageserver_protocol_1.SemanticTokenTypes.number,
          vscode_languageserver_protocol_1.SemanticTokenTypes.regexp,
          vscode_languageserver_protocol_1.SemanticTokenTypes.operator,
          vscode_languageserver_protocol_1.SemanticTokenTypes.decorator
        ];
        capability.tokenModifiers = [
          vscode_languageserver_protocol_1.SemanticTokenModifiers.declaration,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.definition,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.readonly,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.static,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.deprecated,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.abstract,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.async,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.modification,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.documentation,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.defaultLibrary
        ];
        capability.formats = [vscode_languageserver_protocol_1.TokenFormat.Relative];
        capability.requests = {
          range: true,
          full: {
            delta: true
          }
        };
        capability.multilineTokenSupport = false;
        capability.overlappingTokenSupport = false;
        capability.serverCancelSupport = true;
        capability.augmentsSyntaxTokens = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "semanticTokens").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type, async () => {
          for (const provider2 of this.getAllProviders()) {
            provider2.onDidChangeSemanticTokensEmitter.fire();
          }
        });
        const [id, options] = this.getRegistration(documentSelector, capabilities.semanticTokensProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const fullProvider = Is.boolean(options.full) ? options.full : options.full !== void 0;
        const hasEditProvider = options.full !== void 0 && typeof options.full !== "boolean" && options.full.delta === true;
        const eventEmitter = new vscode10.EventEmitter();
        const documentProvider = fullProvider ? {
          onDidChangeSemanticTokens: eventEmitter.event,
          provideDocumentSemanticTokens: (document, token) => {
            const client2 = this._client;
            const middleware = client2.middleware;
            const provideDocumentSemanticTokens = (document2, token2) => {
              const params = {
                textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document2)
              };
              return client2.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, params, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client2.protocol2CodeConverter.asSemanticTokens(result, token2);
              }, (error) => {
                return client2.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, token2, error, null);
              });
            };
            return middleware.provideDocumentSemanticTokens ? middleware.provideDocumentSemanticTokens(document, token, provideDocumentSemanticTokens) : provideDocumentSemanticTokens(document, token);
          },
          provideDocumentSemanticTokensEdits: hasEditProvider ? (document, previousResultId, token) => {
            const client2 = this._client;
            const middleware = client2.middleware;
            const provideDocumentSemanticTokensEdits = (document2, previousResultId2, token2) => {
              const params = {
                textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                previousResultId: previousResultId2
              };
              return client2.sendRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, params, token2).then(async (result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                if (vscode_languageserver_protocol_1.SemanticTokens.is(result)) {
                  return await client2.protocol2CodeConverter.asSemanticTokens(result, token2);
                } else {
                  return await client2.protocol2CodeConverter.asSemanticTokensEdits(result, token2);
                }
              }, (error) => {
                return client2.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, token2, error, null);
              });
            };
            return middleware.provideDocumentSemanticTokensEdits ? middleware.provideDocumentSemanticTokensEdits(document, previousResultId, token, provideDocumentSemanticTokensEdits) : provideDocumentSemanticTokensEdits(document, previousResultId, token);
          } : void 0
        } : void 0;
        const hasRangeProvider = options.range === true;
        const rangeProvider = hasRangeProvider ? {
          provideDocumentRangeSemanticTokens: (document, range, token) => {
            const client2 = this._client;
            const middleware = client2.middleware;
            const provideDocumentRangeSemanticTokens = (document2, range2, token2) => {
              const params = {
                textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                range: client2.code2ProtocolConverter.asRange(range2)
              };
              return client2.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, params, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client2.protocol2CodeConverter.asSemanticTokens(result, token2);
              }, (error) => {
                return client2.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, token2, error, null);
              });
            };
            return middleware.provideDocumentRangeSemanticTokens ? middleware.provideDocumentRangeSemanticTokens(document, range, token, provideDocumentRangeSemanticTokens) : provideDocumentRangeSemanticTokens(document, range, token);
          }
        } : void 0;
        const disposables = [];
        const client = this._client;
        const legend2 = client.protocol2CodeConverter.asSemanticTokensLegend(options.legend);
        const documentSelector = client.protocol2CodeConverter.asDocumentSelector(selector);
        if (documentProvider !== void 0) {
          disposables.push(vscode10.languages.registerDocumentSemanticTokensProvider(documentSelector, documentProvider, legend2));
        }
        if (rangeProvider !== void 0) {
          disposables.push(vscode10.languages.registerDocumentRangeSemanticTokensProvider(documentSelector, rangeProvider, legend2));
        }
        return [new vscode10.Disposable(() => disposables.forEach((item) => item.dispose())), { range: rangeProvider, full: documentProvider, onDidChangeSemanticTokensEmitter: eventEmitter }];
      }
    };
    exports.SemanticTokensFeature = SemanticTokensFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/fileOperations.js
var require_fileOperations = __commonJS({
  "node_modules/vscode-languageclient/lib/common/fileOperations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WillDeleteFilesFeature = exports.WillRenameFilesFeature = exports.WillCreateFilesFeature = exports.DidDeleteFilesFeature = exports.DidRenameFilesFeature = exports.DidCreateFilesFeature = void 0;
    var code = require("vscode");
    var minimatch = require_minimatch();
    var proto = require_main3();
    var UUID = require_uuid();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    function access(target, key) {
      return target[key];
    }
    function assign(target, key, value) {
      target[key] = value;
    }
    var FileOperationFeature = class {
      constructor(client, event, registrationType, clientCapability, serverCapability) {
        this._client = client;
        this._event = event;
        this._registrationType = registrationType;
        this._clientCapability = clientCapability;
        this._serverCapability = serverCapability;
        this._filters = /* @__PURE__ */ new Map();
      }
      getState() {
        return { kind: "workspace", id: this._registrationType.method, registrations: this._filters.size > 0 };
      }
      filterSize() {
        return this._filters.size;
      }
      get registrationType() {
        return this._registrationType;
      }
      fillClientCapabilities(capabilities) {
        const value = ensure(ensure(capabilities, "workspace"), "fileOperations");
        assign(value, "dynamicRegistration", true);
        assign(value, this._clientCapability, true);
      }
      initialize(capabilities) {
        const options = capabilities.workspace?.fileOperations;
        const capability = options !== void 0 ? access(options, this._serverCapability) : void 0;
        if (capability?.filters !== void 0) {
          try {
            this.register({
              id: UUID.generateUuid(),
              registerOptions: { filters: capability.filters }
            });
          } catch (e) {
            this._client.warn(`Ignoring invalid glob pattern for ${this._serverCapability} registration: ${e}`);
          }
        }
      }
      register(data) {
        if (!this._listener) {
          this._listener = this._event(this.send, this);
        }
        const minimatchFilter = data.registerOptions.filters.map((filter) => {
          const matcher = new minimatch.Minimatch(filter.pattern.glob, FileOperationFeature.asMinimatchOptions(filter.pattern.options));
          if (!matcher.makeRe()) {
            throw new Error(`Invalid pattern ${filter.pattern.glob}!`);
          }
          return { scheme: filter.scheme, matcher, kind: filter.pattern.matches };
        });
        this._filters.set(data.id, minimatchFilter);
      }
      unregister(id) {
        this._filters.delete(id);
        if (this._filters.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      clear() {
        this._filters.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      getFileType(uri) {
        return FileOperationFeature.getFileType(uri);
      }
      async filter(event, prop) {
        const fileMatches = await Promise.all(event.files.map(async (item) => {
          const uri = prop(item);
          const path3 = uri.fsPath.replace(/\\/g, "/");
          for (const filters of this._filters.values()) {
            for (const filter of filters) {
              if (filter.scheme !== void 0 && filter.scheme !== uri.scheme) {
                continue;
              }
              if (filter.matcher.match(path3)) {
                if (filter.kind === void 0) {
                  return true;
                }
                const fileType = await this.getFileType(uri);
                if (fileType === void 0) {
                  this._client.error(`Failed to determine file type for ${uri.toString()}.`);
                  return true;
                }
                if (fileType === code.FileType.File && filter.kind === proto.FileOperationPatternKind.file || fileType === code.FileType.Directory && filter.kind === proto.FileOperationPatternKind.folder) {
                  return true;
                }
              } else if (filter.kind === proto.FileOperationPatternKind.folder) {
                const fileType = await FileOperationFeature.getFileType(uri);
                if (fileType === code.FileType.Directory && filter.matcher.match(`${path3}/`)) {
                  return true;
                }
              }
            }
          }
          return false;
        }));
        const files = event.files.filter((_, index) => fileMatches[index]);
        return { ...event, files };
      }
      static async getFileType(uri) {
        try {
          return (await code.workspace.fs.stat(uri)).type;
        } catch (e) {
          return void 0;
        }
      }
      static asMinimatchOptions(options) {
        const result = { dot: true };
        if (options?.ignoreCase === true) {
          result.nocase = true;
        }
        return result;
      }
    };
    var NotificationFileOperationFeature = class extends FileOperationFeature {
      constructor(client, event, notificationType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, notificationType, clientCapability, serverCapability);
        this._notificationType = notificationType;
        this._accessUri = accessUri;
        this._createParams = createParams;
      }
      async send(originalEvent) {
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
          const next = async (event) => {
            return this._client.sendNotification(this._notificationType, this._createParams(event));
          };
          return this.doSend(filteredEvent, next);
        }
      }
    };
    var CachingNotificationFileOperationFeature = class extends NotificationFileOperationFeature {
      constructor() {
        super(...arguments);
        this._fsPathFileTypes = /* @__PURE__ */ new Map();
      }
      async getFileType(uri) {
        const fsPath = uri.fsPath;
        if (this._fsPathFileTypes.has(fsPath)) {
          return this._fsPathFileTypes.get(fsPath);
        }
        const type = await FileOperationFeature.getFileType(uri);
        if (type) {
          this._fsPathFileTypes.set(fsPath, type);
        }
        return type;
      }
      async cacheFileTypes(event, prop) {
        await this.filter(event, prop);
      }
      clearFileTypeCache() {
        this._fsPathFileTypes.clear();
      }
      unregister(id) {
        super.unregister(id);
        if (this.filterSize() === 0 && this._willListener) {
          this._willListener.dispose();
          this._willListener = void 0;
        }
      }
      clear() {
        super.clear();
        if (this._willListener) {
          this._willListener.dispose();
          this._willListener = void 0;
        }
      }
    };
    var DidCreateFilesFeature = class extends NotificationFileOperationFeature {
      constructor(client) {
        super(client, code.workspace.onDidCreateFiles, proto.DidCreateFilesNotification.type, "didCreate", "didCreate", (i) => i, client.code2ProtocolConverter.asDidCreateFilesParams);
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.didCreateFiles ? middleware.didCreateFiles(event, next) : next(event);
      }
    };
    exports.DidCreateFilesFeature = DidCreateFilesFeature;
    var DidRenameFilesFeature = class extends CachingNotificationFileOperationFeature {
      constructor(client) {
        super(client, code.workspace.onDidRenameFiles, proto.DidRenameFilesNotification.type, "didRename", "didRename", (i) => i.oldUri, client.code2ProtocolConverter.asDidRenameFilesParams);
      }
      register(data) {
        if (!this._willListener) {
          this._willListener = code.workspace.onWillRenameFiles(this.willRename, this);
        }
        super.register(data);
      }
      willRename(e) {
        e.waitUntil(this.cacheFileTypes(e, (i) => i.oldUri));
      }
      doSend(event, next) {
        this.clearFileTypeCache();
        const middleware = this._client.middleware.workspace;
        return middleware?.didRenameFiles ? middleware.didRenameFiles(event, next) : next(event);
      }
    };
    exports.DidRenameFilesFeature = DidRenameFilesFeature;
    var DidDeleteFilesFeature = class extends CachingNotificationFileOperationFeature {
      constructor(client) {
        super(client, code.workspace.onDidDeleteFiles, proto.DidDeleteFilesNotification.type, "didDelete", "didDelete", (i) => i, client.code2ProtocolConverter.asDidDeleteFilesParams);
      }
      register(data) {
        if (!this._willListener) {
          this._willListener = code.workspace.onWillDeleteFiles(this.willDelete, this);
        }
        super.register(data);
      }
      willDelete(e) {
        e.waitUntil(this.cacheFileTypes(e, (i) => i));
      }
      doSend(event, next) {
        this.clearFileTypeCache();
        const middleware = this._client.middleware.workspace;
        return middleware?.didDeleteFiles ? middleware.didDeleteFiles(event, next) : next(event);
      }
    };
    exports.DidDeleteFilesFeature = DidDeleteFilesFeature;
    var RequestFileOperationFeature = class extends FileOperationFeature {
      constructor(client, event, requestType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, requestType, clientCapability, serverCapability);
        this._requestType = requestType;
        this._accessUri = accessUri;
        this._createParams = createParams;
      }
      async send(originalEvent) {
        const waitUntil = this.waitUntil(originalEvent);
        originalEvent.waitUntil(waitUntil);
      }
      async waitUntil(originalEvent) {
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
          const next = (event) => {
            return this._client.sendRequest(this._requestType, this._createParams(event), event.token).then(this._client.protocol2CodeConverter.asWorkspaceEdit);
          };
          return this.doSend(filteredEvent, next);
        } else {
          return void 0;
        }
      }
    };
    var WillCreateFilesFeature = class extends RequestFileOperationFeature {
      constructor(client) {
        super(client, code.workspace.onWillCreateFiles, proto.WillCreateFilesRequest.type, "willCreate", "willCreate", (i) => i, client.code2ProtocolConverter.asWillCreateFilesParams);
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.willCreateFiles ? middleware.willCreateFiles(event, next) : next(event);
      }
    };
    exports.WillCreateFilesFeature = WillCreateFilesFeature;
    var WillRenameFilesFeature = class extends RequestFileOperationFeature {
      constructor(client) {
        super(client, code.workspace.onWillRenameFiles, proto.WillRenameFilesRequest.type, "willRename", "willRename", (i) => i.oldUri, client.code2ProtocolConverter.asWillRenameFilesParams);
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.willRenameFiles ? middleware.willRenameFiles(event, next) : next(event);
      }
    };
    exports.WillRenameFilesFeature = WillRenameFilesFeature;
    var WillDeleteFilesFeature = class extends RequestFileOperationFeature {
      constructor(client) {
        super(client, code.workspace.onWillDeleteFiles, proto.WillDeleteFilesRequest.type, "willDelete", "willDelete", (i) => i, client.code2ProtocolConverter.asWillDeleteFilesParams);
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.willDeleteFiles ? middleware.willDeleteFiles(event, next) : next(event);
      }
    };
    exports.WillDeleteFilesFeature = WillDeleteFilesFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/linkedEditingRange.js
var require_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageclient/lib/common/linkedEditingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkedEditingFeature = void 0;
    var code = require("vscode");
    var proto = require_main3();
    var features_1 = require_features();
    var LinkedEditingFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, proto.LinkedEditingRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const linkedEditingSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "linkedEditingRange");
        linkedEditingSupport.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.linkedEditingRangeProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider2 = {
          provideLinkedEditingRanges: (document, position, token) => {
            const client = this._client;
            const provideLinkedEditing = (document2, position2, token2) => {
              return client.sendRequest(proto.LinkedEditingRangeRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asLinkedEditingRanges(result, token2);
              }, (error) => {
                return client.handleFailedRequest(proto.LinkedEditingRangeRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideLinkedEditingRange ? middleware.provideLinkedEditingRange(document, position, token, provideLinkedEditing) : provideLinkedEditing(document, position, token);
          }
        };
        return [this.registerProvider(selector, provider2), provider2];
      }
      registerProvider(selector, provider2) {
        return code.languages.registerLinkedEditingRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2);
      }
    };
    exports.LinkedEditingFeature = LinkedEditingFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/typeHierarchy.js
var require_typeHierarchy = __commonJS({
  "node_modules/vscode-languageclient/lib/common/typeHierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeHierarchyFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var TypeHierarchyProvider = class {
      constructor(client) {
        this.client = client;
        this.middleware = client.middleware;
      }
      prepareTypeHierarchy(document, position, token) {
        const client = this.client;
        const middleware = this.middleware;
        const prepareTypeHierarchy = (document2, position2, token2) => {
          const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2);
          return client.sendRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, params, token2).then((result) => {
            if (token2.isCancellationRequested) {
              return null;
            }
            return client.protocol2CodeConverter.asTypeHierarchyItems(result, token2);
          }, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, token2, error, null);
          });
        };
        return middleware.prepareTypeHierarchy ? middleware.prepareTypeHierarchy(document, position, token, prepareTypeHierarchy) : prepareTypeHierarchy(document, position, token);
      }
      provideTypeHierarchySupertypes(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideTypeHierarchySupertypes = (item2, token2) => {
          const params = {
            item: client.code2ProtocolConverter.asTypeHierarchyItem(item2)
          };
          return client.sendRequest(vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type, params, token2).then((result) => {
            if (token2.isCancellationRequested) {
              return null;
            }
            return client.protocol2CodeConverter.asTypeHierarchyItems(result, token2);
          }, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type, token2, error, null);
          });
        };
        return middleware.provideTypeHierarchySupertypes ? middleware.provideTypeHierarchySupertypes(item, token, provideTypeHierarchySupertypes) : provideTypeHierarchySupertypes(item, token);
      }
      provideTypeHierarchySubtypes(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideTypeHierarchySubtypes = (item2, token2) => {
          const params = {
            item: client.code2ProtocolConverter.asTypeHierarchyItem(item2)
          };
          return client.sendRequest(vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type, params, token2).then((result) => {
            if (token2.isCancellationRequested) {
              return null;
            }
            return client.protocol2CodeConverter.asTypeHierarchyItems(result, token2);
          }, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type, token2, error, null);
          });
        };
        return middleware.provideTypeHierarchySubtypes ? middleware.provideTypeHierarchySubtypes(item, token, provideTypeHierarchySubtypes) : provideTypeHierarchySubtypes(item, token);
      }
    };
    var TypeHierarchyFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "typeHierarchy");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.typeHierarchyProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const client = this._client;
        const provider2 = new TypeHierarchyProvider(client);
        return [vscode_1.languages.registerTypeHierarchyProvider(client.protocol2CodeConverter.asDocumentSelector(options.documentSelector), provider2), provider2];
      }
    };
    exports.TypeHierarchyFeature = TypeHierarchyFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/inlineValue.js
var require_inlineValue = __commonJS({
  "node_modules/vscode-languageclient/lib/common/inlineValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlineValueFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var InlineValueFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.InlineValueRequest.type);
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "inlineValue").dynamicRegistration = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "inlineValue").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        this._client.onRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type, async () => {
          for (const provider2 of this.getAllProviders()) {
            provider2.onDidChangeInlineValues.fire();
          }
        });
        const [id, options] = this.getRegistration(documentSelector, capabilities.inlineValueProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const eventEmitter = new vscode_1.EventEmitter();
        const provider2 = {
          onDidChangeInlineValues: eventEmitter.event,
          provideInlineValues: (document, viewPort, context, token) => {
            const client = this._client;
            const provideInlineValues = (document2, viewPort2, context2, token2) => {
              const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                range: client.code2ProtocolConverter.asRange(viewPort2),
                context: client.code2ProtocolConverter.asInlineValueContext(context2)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, requestParams, token2).then((values) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asInlineValues(values, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideInlineValues ? middleware.provideInlineValues(document, viewPort, context, token, provideInlineValues) : provideInlineValues(document, viewPort, context, token);
          }
        };
        return [this.registerProvider(selector, provider2), { provider: provider2, onDidChangeInlineValues: eventEmitter }];
      }
      registerProvider(selector, provider2) {
        return vscode_1.languages.registerInlineValuesProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2);
      }
    };
    exports.InlineValueFeature = InlineValueFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/inlayHint.js
var require_inlayHint = __commonJS({
  "node_modules/vscode-languageclient/lib/common/inlayHint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlayHintsFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var InlayHintsFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.InlayHintRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const inlayHint = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "inlayHint");
        inlayHint.dynamicRegistration = true;
        inlayHint.resolveSupport = {
          properties: ["tooltip", "textEdits", "label.tooltip", "label.location", "label.command"]
        };
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "inlayHint").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        this._client.onRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type, async () => {
          for (const provider2 of this.getAllProviders()) {
            provider2.onDidChangeInlayHints.fire();
          }
        });
        const [id, options] = this.getRegistration(documentSelector, capabilities.inlayHintProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const eventEmitter = new vscode_1.EventEmitter();
        const provider2 = {
          onDidChangeInlayHints: eventEmitter.event,
          provideInlayHints: (document, viewPort, token) => {
            const client = this._client;
            const provideInlayHints = async (document2, viewPort2, token2) => {
              const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                range: client.code2ProtocolConverter.asRange(viewPort2)
              };
              try {
                const values = await client.sendRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, requestParams, token2);
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asInlayHints(values, token2);
              } catch (error) {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, token2, error, null);
              }
            };
            const middleware = client.middleware;
            return middleware.provideInlayHints ? middleware.provideInlayHints(document, viewPort, token, provideInlayHints) : provideInlayHints(document, viewPort, token);
          }
        };
        provider2.resolveInlayHint = options.resolveProvider === true ? (hint, token) => {
          const client = this._client;
          const resolveInlayHint = async (item, token2) => {
            try {
              const value = await client.sendRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, client.code2ProtocolConverter.asInlayHint(item), token2);
              if (token2.isCancellationRequested) {
                return null;
              }
              const result = client.protocol2CodeConverter.asInlayHint(value, token2);
              return token2.isCancellationRequested ? null : result;
            } catch (error) {
              return client.handleFailedRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, token2, error, null);
            }
          };
          const middleware = client.middleware;
          return middleware.resolveInlayHint ? middleware.resolveInlayHint(hint, token, resolveInlayHint) : resolveInlayHint(hint, token);
        } : void 0;
        return [this.registerProvider(selector, provider2), { provider: provider2, onDidChangeInlayHints: eventEmitter }];
      }
      registerProvider(selector, provider2) {
        return vscode_1.languages.registerInlayHintsProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2);
      }
    };
    exports.InlayHintsFeature = InlayHintsFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/inlineCompletion.js
var require_inlineCompletion = __commonJS({
  "node_modules/vscode-languageclient/lib/common/inlineCompletion.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlineCompletionItemFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var UUID = require_uuid();
    var InlineCompletionItemFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.InlineCompletionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let inlineCompletion = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "inlineCompletion");
        inlineCompletion.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.inlineCompletionProvider);
        if (!options) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider2 = {
          provideInlineCompletionItems: (document, position, context, token) => {
            const client = this._client;
            const middleware = this._client.middleware;
            const provideInlineCompletionItems = (document2, position2, context2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.InlineCompletionRequest.type, client.code2ProtocolConverter.asInlineCompletionParams(document2, position2, context2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asInlineCompletionResult(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.InlineCompletionRequest.type, token2, error, null);
              });
            };
            return middleware.provideInlineCompletionItems ? middleware.provideInlineCompletionItems(document, position, context, token, provideInlineCompletionItems) : provideInlineCompletionItems(document, position, context, token);
          }
        };
        return [vscode_1.languages.registerInlineCompletionItemProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider2), provider2];
      }
    };
    exports.InlineCompletionItemFeature = InlineCompletionItemFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/client.js
var require_client = __commonJS({
  "node_modules/vscode-languageclient/lib/common/client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProposedFeatures = exports.BaseLanguageClient = exports.MessageTransports = exports.SuspendMode = exports.State = exports.CloseAction = exports.ErrorAction = exports.RevealOutputChannelOn = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var c2p = require_codeConverter();
    var p2c = require_protocolConverter();
    var Is = require_is();
    var async_1 = require_async();
    var UUID = require_uuid();
    var progressPart_1 = require_progressPart();
    var features_1 = require_features();
    var diagnostic_1 = require_diagnostic();
    var notebook_1 = require_notebook();
    var configuration_1 = require_configuration();
    var textSynchronization_1 = require_textSynchronization();
    var completion_1 = require_completion();
    var hover_1 = require_hover();
    var definition_1 = require_definition();
    var signatureHelp_1 = require_signatureHelp();
    var documentHighlight_1 = require_documentHighlight();
    var documentSymbol_1 = require_documentSymbol();
    var workspaceSymbol_1 = require_workspaceSymbol();
    var reference_1 = require_reference();
    var codeAction_1 = require_codeAction();
    var codeLens_1 = require_codeLens();
    var formatting_1 = require_formatting();
    var rename_1 = require_rename();
    var documentLink_1 = require_documentLink();
    var executeCommand_1 = require_executeCommand();
    var fileSystemWatcher_1 = require_fileSystemWatcher();
    var colorProvider_1 = require_colorProvider();
    var implementation_1 = require_implementation();
    var typeDefinition_1 = require_typeDefinition();
    var workspaceFolder_1 = require_workspaceFolder();
    var foldingRange_1 = require_foldingRange();
    var declaration_1 = require_declaration();
    var selectionRange_1 = require_selectionRange();
    var progress_1 = require_progress();
    var callHierarchy_1 = require_callHierarchy();
    var semanticTokens_1 = require_semanticTokens();
    var fileOperations_1 = require_fileOperations();
    var linkedEditingRange_1 = require_linkedEditingRange();
    var typeHierarchy_1 = require_typeHierarchy();
    var inlineValue_1 = require_inlineValue();
    var inlayHint_1 = require_inlayHint();
    var inlineCompletion_1 = require_inlineCompletion();
    var RevealOutputChannelOn;
    (function(RevealOutputChannelOn2) {
      RevealOutputChannelOn2[RevealOutputChannelOn2["Debug"] = 0] = "Debug";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Info"] = 1] = "Info";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Warn"] = 2] = "Warn";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Error"] = 3] = "Error";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Never"] = 4] = "Never";
    })(RevealOutputChannelOn || (exports.RevealOutputChannelOn = RevealOutputChannelOn = {}));
    var ErrorAction;
    (function(ErrorAction2) {
      ErrorAction2[ErrorAction2["Continue"] = 1] = "Continue";
      ErrorAction2[ErrorAction2["Shutdown"] = 2] = "Shutdown";
    })(ErrorAction || (exports.ErrorAction = ErrorAction = {}));
    var CloseAction;
    (function(CloseAction2) {
      CloseAction2[CloseAction2["DoNotRestart"] = 1] = "DoNotRestart";
      CloseAction2[CloseAction2["Restart"] = 2] = "Restart";
    })(CloseAction || (exports.CloseAction = CloseAction = {}));
    var State;
    (function(State2) {
      State2[State2["Stopped"] = 1] = "Stopped";
      State2[State2["Starting"] = 3] = "Starting";
      State2[State2["Running"] = 2] = "Running";
    })(State || (exports.State = State = {}));
    var SuspendMode;
    (function(SuspendMode2) {
      SuspendMode2["off"] = "off";
      SuspendMode2["on"] = "on";
    })(SuspendMode || (exports.SuspendMode = SuspendMode = {}));
    var ResolvedClientOptions;
    (function(ResolvedClientOptions2) {
      function sanitizeIsTrusted(isTrusted) {
        if (isTrusted === void 0 || isTrusted === null) {
          return false;
        }
        if (typeof isTrusted === "boolean" || typeof isTrusted === "object" && isTrusted !== null && Is.stringArray(isTrusted.enabledCommands)) {
          return isTrusted;
        }
        return false;
      }
      ResolvedClientOptions2.sanitizeIsTrusted = sanitizeIsTrusted;
    })(ResolvedClientOptions || (ResolvedClientOptions = {}));
    var DefaultErrorHandler = class {
      constructor(client, maxRestartCount) {
        this.client = client;
        this.maxRestartCount = maxRestartCount;
        this.restarts = [];
      }
      error(_error, _message, count) {
        if (count && count <= 3) {
          return { action: ErrorAction.Continue };
        }
        return { action: ErrorAction.Shutdown };
      }
      closed() {
        this.restarts.push(Date.now());
        if (this.restarts.length <= this.maxRestartCount) {
          return { action: CloseAction.Restart };
        } else {
          let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
          if (diff <= 3 * 60 * 1e3) {
            return { action: CloseAction.DoNotRestart, message: `The ${this.client.name} server crashed ${this.maxRestartCount + 1} times in the last 3 minutes. The server will not be restarted. See the output for more information.` };
          } else {
            this.restarts.shift();
            return { action: CloseAction.Restart };
          }
        }
      }
    };
    var ClientState;
    (function(ClientState2) {
      ClientState2["Initial"] = "initial";
      ClientState2["Starting"] = "starting";
      ClientState2["StartFailed"] = "startFailed";
      ClientState2["Running"] = "running";
      ClientState2["Stopping"] = "stopping";
      ClientState2["Stopped"] = "stopped";
    })(ClientState || (ClientState = {}));
    var MessageTransports;
    (function(MessageTransports2) {
      function is(value) {
        let candidate = value;
        return candidate && vscode_languageserver_protocol_1.MessageReader.is(value.reader) && vscode_languageserver_protocol_1.MessageWriter.is(value.writer);
      }
      MessageTransports2.is = is;
    })(MessageTransports || (exports.MessageTransports = MessageTransports = {}));
    var BaseLanguageClient = class {
      constructor(id, name, clientOptions) {
        this._traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        this._diagnosticQueue = /* @__PURE__ */ new Map();
        this._diagnosticQueueState = { state: "idle" };
        this._features = [];
        this._dynamicFeatures = /* @__PURE__ */ new Map();
        this.workspaceEditLock = new async_1.Semaphore(1);
        this._id = id;
        this._name = name;
        clientOptions = clientOptions || {};
        const markdown = { isTrusted: false, supportHtml: false };
        if (clientOptions.markdown !== void 0) {
          markdown.isTrusted = ResolvedClientOptions.sanitizeIsTrusted(clientOptions.markdown.isTrusted);
          markdown.supportHtml = clientOptions.markdown.supportHtml === true;
        }
        this._clientOptions = {
          documentSelector: clientOptions.documentSelector ?? [],
          synchronize: clientOptions.synchronize ?? {},
          diagnosticCollectionName: clientOptions.diagnosticCollectionName,
          outputChannelName: clientOptions.outputChannelName ?? this._name,
          revealOutputChannelOn: clientOptions.revealOutputChannelOn ?? RevealOutputChannelOn.Error,
          stdioEncoding: clientOptions.stdioEncoding ?? "utf8",
          initializationOptions: clientOptions.initializationOptions,
          initializationFailedHandler: clientOptions.initializationFailedHandler,
          progressOnInitialization: !!clientOptions.progressOnInitialization,
          errorHandler: clientOptions.errorHandler ?? this.createDefaultErrorHandler(clientOptions.connectionOptions?.maxRestartCount),
          middleware: clientOptions.middleware ?? {},
          uriConverters: clientOptions.uriConverters,
          workspaceFolder: clientOptions.workspaceFolder,
          connectionOptions: clientOptions.connectionOptions,
          markdown,
          // suspend: {
          // 	mode: clientOptions.suspend?.mode ?? SuspendMode.off,
          // 	callback: clientOptions.suspend?.callback ?? (() => Promise.resolve(true)),
          // 	interval: clientOptions.suspend?.interval ? Math.max(clientOptions.suspend.interval, defaultInterval) : defaultInterval
          // },
          diagnosticPullOptions: clientOptions.diagnosticPullOptions ?? { onChange: true, onSave: false },
          notebookDocumentOptions: clientOptions.notebookDocumentOptions ?? {}
        };
        this._clientOptions.synchronize = this._clientOptions.synchronize || {};
        this._state = ClientState.Initial;
        this._ignoredRegistrations = /* @__PURE__ */ new Set();
        this._listeners = [];
        this._notificationHandlers = /* @__PURE__ */ new Map();
        this._pendingNotificationHandlers = /* @__PURE__ */ new Map();
        this._notificationDisposables = /* @__PURE__ */ new Map();
        this._requestHandlers = /* @__PURE__ */ new Map();
        this._pendingRequestHandlers = /* @__PURE__ */ new Map();
        this._requestDisposables = /* @__PURE__ */ new Map();
        this._progressHandlers = /* @__PURE__ */ new Map();
        this._pendingProgressHandlers = /* @__PURE__ */ new Map();
        this._progressDisposables = /* @__PURE__ */ new Map();
        this._connection = void 0;
        this._initializeResult = void 0;
        if (clientOptions.outputChannel) {
          this._outputChannel = clientOptions.outputChannel;
          this._disposeOutputChannel = false;
        } else {
          this._outputChannel = void 0;
          this._disposeOutputChannel = true;
        }
        this._traceOutputChannel = clientOptions.traceOutputChannel;
        this._diagnostics = void 0;
        this._pendingOpenNotifications = /* @__PURE__ */ new Set();
        this._pendingChangeSemaphore = new async_1.Semaphore(1);
        this._pendingChangeDelayer = new async_1.Delayer(250);
        this._fileEvents = [];
        this._fileEventDelayer = new async_1.Delayer(250);
        this._onStop = void 0;
        this._telemetryEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._stateChangeEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
        this._tracer = {
          log: (messageOrDataObject, data) => {
            if (Is.string(messageOrDataObject)) {
              this.logTrace(messageOrDataObject, data);
            } else {
              this.logObjectTrace(messageOrDataObject);
            }
          }
        };
        this._c2p = c2p.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.code2Protocol : void 0);
        this._p2c = p2c.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.protocol2Code : void 0, this._clientOptions.markdown.isTrusted, this._clientOptions.markdown.supportHtml);
        this._syncedDocuments = /* @__PURE__ */ new Map();
        this.registerBuiltinFeatures();
      }
      get name() {
        return this._name;
      }
      get middleware() {
        return this._clientOptions.middleware ?? /* @__PURE__ */ Object.create(null);
      }
      get clientOptions() {
        return this._clientOptions;
      }
      get protocol2CodeConverter() {
        return this._p2c;
      }
      get code2ProtocolConverter() {
        return this._c2p;
      }
      get onTelemetry() {
        return this._telemetryEmitter.event;
      }
      get onDidChangeState() {
        return this._stateChangeEmitter.event;
      }
      get outputChannel() {
        if (!this._outputChannel) {
          this._outputChannel = vscode_1.window.createOutputChannel(this._clientOptions.outputChannelName ? this._clientOptions.outputChannelName : this._name);
        }
        return this._outputChannel;
      }
      get traceOutputChannel() {
        if (this._traceOutputChannel) {
          return this._traceOutputChannel;
        }
        return this.outputChannel;
      }
      get diagnostics() {
        return this._diagnostics;
      }
      get state() {
        return this.getPublicState();
      }
      get $state() {
        return this._state;
      }
      set $state(value) {
        let oldState = this.getPublicState();
        this._state = value;
        let newState = this.getPublicState();
        if (newState !== oldState) {
          this._stateChangeEmitter.fire({ oldState, newState });
        }
      }
      getPublicState() {
        switch (this.$state) {
          case ClientState.Starting:
            return State.Starting;
          case ClientState.Running:
            return State.Running;
          default:
            return State.Stopped;
        }
      }
      get initializeResult() {
        return this._initializeResult;
      }
      async sendRequest(type, ...params) {
        if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
          return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
        }
        const connection = await this.$start();
        if (this._didChangeTextDocumentFeature.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
          await this.sendPendingFullTextDocumentChanges(connection);
        }
        const _sendRequest = this._clientOptions.middleware?.sendRequest;
        if (_sendRequest !== void 0) {
          let param = void 0;
          let token = void 0;
          if (params.length === 1) {
            if (vscode_languageserver_protocol_1.CancellationToken.is(params[0])) {
              token = params[0];
            } else {
              param = params[0];
            }
          } else if (params.length === 2) {
            param = params[0];
            token = params[1];
          }
          return _sendRequest(type, param, token, (type2, param2, token2) => {
            const params2 = [];
            if (param2 !== void 0) {
              params2.push(param2);
            }
            if (token2 !== void 0) {
              params2.push(token2);
            }
            return connection.sendRequest(type2, ...params2);
          });
        } else {
          return connection.sendRequest(type, ...params);
        }
      }
      onRequest(type, handler) {
        const method = typeof type === "string" ? type : type.method;
        this._requestHandlers.set(method, handler);
        const connection = this.activeConnection();
        let disposable;
        if (connection !== void 0) {
          this._requestDisposables.set(method, connection.onRequest(type, handler));
          disposable = {
            dispose: () => {
              const disposable2 = this._requestDisposables.get(method);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._requestDisposables.delete(method);
              }
            }
          };
        } else {
          this._pendingRequestHandlers.set(method, handler);
          disposable = {
            dispose: () => {
              this._pendingRequestHandlers.delete(method);
              const disposable2 = this._requestDisposables.get(method);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._requestDisposables.delete(method);
              }
            }
          };
        }
        return {
          dispose: () => {
            this._requestHandlers.delete(method);
            disposable.dispose();
          }
        };
      }
      async sendNotification(type, params) {
        if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
          return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
        }
        const needsPendingFullTextDocumentSync = this._didChangeTextDocumentFeature.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full;
        let openNotification;
        if (needsPendingFullTextDocumentSync && typeof type !== "string" && type.method === vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method) {
          openNotification = params?.textDocument.uri;
          this._pendingOpenNotifications.add(openNotification);
        }
        const connection = await this.$start();
        if (needsPendingFullTextDocumentSync) {
          await this.sendPendingFullTextDocumentChanges(connection);
        }
        if (openNotification !== void 0) {
          this._pendingOpenNotifications.delete(openNotification);
        }
        const _sendNotification = this._clientOptions.middleware?.sendNotification;
        return _sendNotification ? _sendNotification(type, connection.sendNotification.bind(connection), params) : connection.sendNotification(type, params);
      }
      onNotification(type, handler) {
        const method = typeof type === "string" ? type : type.method;
        this._notificationHandlers.set(method, handler);
        const connection = this.activeConnection();
        let disposable;
        if (connection !== void 0) {
          this._notificationDisposables.set(method, connection.onNotification(type, handler));
          disposable = {
            dispose: () => {
              const disposable2 = this._notificationDisposables.get(method);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._notificationDisposables.delete(method);
              }
            }
          };
        } else {
          this._pendingNotificationHandlers.set(method, handler);
          disposable = {
            dispose: () => {
              this._pendingNotificationHandlers.delete(method);
              const disposable2 = this._notificationDisposables.get(method);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._notificationDisposables.delete(method);
              }
            }
          };
        }
        return {
          dispose: () => {
            this._notificationHandlers.delete(method);
            disposable.dispose();
          }
        };
      }
      async sendProgress(type, token, value) {
        if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
          return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
        }
        try {
          const connection = await this.$start();
          return connection.sendProgress(type, token, value);
        } catch (error) {
          this.error(`Sending progress for token ${token} failed.`, error);
          throw error;
        }
      }
      onProgress(type, token, handler) {
        this._progressHandlers.set(token, { type, handler });
        const connection = this.activeConnection();
        let disposable;
        const handleWorkDoneProgress = this._clientOptions.middleware?.handleWorkDoneProgress;
        const realHandler = vscode_languageserver_protocol_1.WorkDoneProgress.is(type) && handleWorkDoneProgress !== void 0 ? (params) => {
          handleWorkDoneProgress(token, params, () => handler(params));
        } : handler;
        if (connection !== void 0) {
          this._progressDisposables.set(token, connection.onProgress(type, token, realHandler));
          disposable = {
            dispose: () => {
              const disposable2 = this._progressDisposables.get(token);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._progressDisposables.delete(token);
              }
            }
          };
        } else {
          this._pendingProgressHandlers.set(token, { type, handler });
          disposable = {
            dispose: () => {
              this._pendingProgressHandlers.delete(token);
              const disposable2 = this._progressDisposables.get(token);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._progressDisposables.delete(token);
              }
            }
          };
        }
        return {
          dispose: () => {
            this._progressHandlers.delete(token);
            disposable.dispose();
          }
        };
      }
      createDefaultErrorHandler(maxRestartCount) {
        if (maxRestartCount !== void 0 && maxRestartCount < 0) {
          throw new Error(`Invalid maxRestartCount: ${maxRestartCount}`);
        }
        return new DefaultErrorHandler(this, maxRestartCount ?? 4);
      }
      async setTrace(value) {
        this._trace = value;
        const connection = this.activeConnection();
        if (connection !== void 0) {
          await connection.trace(this._trace, this._tracer, {
            sendNotification: false,
            traceFormat: this._traceFormat
          });
        }
      }
      data2String(data) {
        if (data instanceof vscode_languageserver_protocol_1.ResponseError) {
          const responseError = data;
          return `  Message: ${responseError.message}
  Code: ${responseError.code} ${responseError.data ? "\n" + responseError.data.toString() : ""}`;
        }
        if (data instanceof Error) {
          if (Is.string(data.stack)) {
            return data.stack;
          }
          return data.message;
        }
        if (Is.string(data)) {
          return data;
        }
        return data.toString();
      }
      debug(message, data, showNotification = true) {
        this.logOutputMessage(vscode_languageserver_protocol_1.MessageType.Debug, RevealOutputChannelOn.Debug, "Debug", message, data, showNotification);
      }
      info(message, data, showNotification = true) {
        this.logOutputMessage(vscode_languageserver_protocol_1.MessageType.Info, RevealOutputChannelOn.Info, "Info", message, data, showNotification);
      }
      warn(message, data, showNotification = true) {
        this.logOutputMessage(vscode_languageserver_protocol_1.MessageType.Warning, RevealOutputChannelOn.Warn, "Warn", message, data, showNotification);
      }
      error(message, data, showNotification = true) {
        this.logOutputMessage(vscode_languageserver_protocol_1.MessageType.Error, RevealOutputChannelOn.Error, "Error", message, data, showNotification);
      }
      logOutputMessage(type, reveal, name, message, data, showNotification) {
        this.outputChannel.appendLine(`[${name.padEnd(5)} - ${new Date().toLocaleTimeString()}] ${message}`);
        if (data !== null && data !== void 0) {
          this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification === "force" || showNotification && this._clientOptions.revealOutputChannelOn <= reveal) {
          this.showNotificationMessage(type, message);
        }
      }
      showNotificationMessage(type, message) {
        message = message ?? "A request has failed. See the output for more information.";
        const messageFunc = type === vscode_languageserver_protocol_1.MessageType.Error ? vscode_1.window.showErrorMessage : type === vscode_languageserver_protocol_1.MessageType.Warning ? vscode_1.window.showWarningMessage : vscode_1.window.showInformationMessage;
        void messageFunc(message, "Go to output").then((selection) => {
          if (selection !== void 0) {
            this.outputChannel.show(true);
          }
        });
      }
      logTrace(message, data) {
        this.traceOutputChannel.appendLine(`[Trace - ${new Date().toLocaleTimeString()}] ${message}`);
        if (data) {
          this.traceOutputChannel.appendLine(this.data2String(data));
        }
      }
      logObjectTrace(data) {
        if (data.isLSPMessage && data.type) {
          this.traceOutputChannel.append(`[LSP   - ${new Date().toLocaleTimeString()}] `);
        } else {
          this.traceOutputChannel.append(`[Trace - ${new Date().toLocaleTimeString()}] `);
        }
        if (data) {
          this.traceOutputChannel.appendLine(`${JSON.stringify(data)}`);
        }
      }
      needsStart() {
        return this.$state === ClientState.Initial || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped;
      }
      needsStop() {
        return this.$state === ClientState.Starting || this.$state === ClientState.Running;
      }
      activeConnection() {
        return this.$state === ClientState.Running && this._connection !== void 0 ? this._connection : void 0;
      }
      isRunning() {
        return this.$state === ClientState.Running;
      }
      async start() {
        if (this._disposed === "disposing" || this._disposed === "disposed") {
          throw new Error(`Client got disposed and can't be restarted.`);
        }
        if (this.$state === ClientState.Stopping) {
          throw new Error(`Client is currently stopping. Can only restart a full stopped client`);
        }
        if (this._onStart !== void 0) {
          return this._onStart;
        }
        const [promise, resolve, reject] = this.createOnStartPromise();
        this._onStart = promise;
        if (this._diagnostics === void 0) {
          this._diagnostics = this._clientOptions.diagnosticCollectionName ? vscode_1.languages.createDiagnosticCollection(this._clientOptions.diagnosticCollectionName) : vscode_1.languages.createDiagnosticCollection();
        }
        for (const [method, handler] of this._notificationHandlers) {
          if (!this._pendingNotificationHandlers.has(method)) {
            this._pendingNotificationHandlers.set(method, handler);
          }
        }
        for (const [method, handler] of this._requestHandlers) {
          if (!this._pendingRequestHandlers.has(method)) {
            this._pendingRequestHandlers.set(method, handler);
          }
        }
        for (const [token, data] of this._progressHandlers) {
          if (!this._pendingProgressHandlers.has(token)) {
            this._pendingProgressHandlers.set(token, data);
          }
        }
        this.$state = ClientState.Starting;
        try {
          const connection = await this.createConnection();
          connection.onNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, (message) => {
            switch (message.type) {
              case vscode_languageserver_protocol_1.MessageType.Error:
                this.error(message.message, void 0, false);
                break;
              case vscode_languageserver_protocol_1.MessageType.Warning:
                this.warn(message.message, void 0, false);
                break;
              case vscode_languageserver_protocol_1.MessageType.Info:
                this.info(message.message, void 0, false);
                break;
              case vscode_languageserver_protocol_1.MessageType.Debug:
                this.debug(message.message, void 0, false);
                break;
              default:
                this.outputChannel.appendLine(message.message);
            }
          });
          connection.onNotification(vscode_languageserver_protocol_1.ShowMessageNotification.type, (message) => {
            switch (message.type) {
              case vscode_languageserver_protocol_1.MessageType.Error:
                void vscode_1.window.showErrorMessage(message.message);
                break;
              case vscode_languageserver_protocol_1.MessageType.Warning:
                void vscode_1.window.showWarningMessage(message.message);
                break;
              case vscode_languageserver_protocol_1.MessageType.Info:
                void vscode_1.window.showInformationMessage(message.message);
                break;
              default:
                void vscode_1.window.showInformationMessage(message.message);
            }
          });
          connection.onRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, (params) => {
            let messageFunc;
            switch (params.type) {
              case vscode_languageserver_protocol_1.MessageType.Error:
                messageFunc = vscode_1.window.showErrorMessage;
                break;
              case vscode_languageserver_protocol_1.MessageType.Warning:
                messageFunc = vscode_1.window.showWarningMessage;
                break;
              case vscode_languageserver_protocol_1.MessageType.Info:
                messageFunc = vscode_1.window.showInformationMessage;
                break;
              default:
                messageFunc = vscode_1.window.showInformationMessage;
            }
            let actions = params.actions || [];
            return messageFunc(params.message, ...actions);
          });
          connection.onNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, (data) => {
            this._telemetryEmitter.fire(data);
          });
          connection.onRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, async (params) => {
            const showDocument = async (params2) => {
              const uri = this.protocol2CodeConverter.asUri(params2.uri);
              try {
                if (params2.external === true) {
                  const success = await vscode_1.env.openExternal(uri);
                  return { success };
                } else {
                  const options = {};
                  if (params2.selection !== void 0) {
                    options.selection = this.protocol2CodeConverter.asRange(params2.selection);
                  }
                  if (params2.takeFocus === void 0 || params2.takeFocus === false) {
                    options.preserveFocus = true;
                  } else if (params2.takeFocus === true) {
                    options.preserveFocus = false;
                  }
                  await vscode_1.window.showTextDocument(uri, options);
                  return { success: true };
                }
              } catch (error) {
                return { success: false };
              }
            };
            const middleware = this._clientOptions.middleware.window?.showDocument;
            if (middleware !== void 0) {
              return middleware(params, showDocument);
            } else {
              return showDocument(params);
            }
          });
          connection.listen();
          await this.initialize(connection);
          resolve();
        } catch (error) {
          this.$state = ClientState.StartFailed;
          this.error(`${this._name} client: couldn't create connection to server.`, error, "force");
          reject(error);
        }
        return this._onStart;
      }
      createOnStartPromise() {
        let resolve;
        let reject;
        const promise = new Promise((_resolve, _reject) => {
          resolve = _resolve;
          reject = _reject;
        });
        return [promise, resolve, reject];
      }
      async initialize(connection) {
        this.refreshTrace(connection, false);
        const initOption = this._clientOptions.initializationOptions;
        const [rootPath, workspaceFolders] = this._clientOptions.workspaceFolder !== void 0 ? [this._clientOptions.workspaceFolder.uri.fsPath, [{ uri: this._c2p.asUri(this._clientOptions.workspaceFolder.uri), name: this._clientOptions.workspaceFolder.name }]] : [this._clientGetRootPath(), null];
        const initParams = {
          processId: null,
          clientInfo: {
            name: vscode_1.env.appName,
            version: vscode_1.version
          },
          locale: this.getLocale(),
          rootPath: rootPath ? rootPath : null,
          rootUri: rootPath ? this._c2p.asUri(vscode_1.Uri.file(rootPath)) : null,
          capabilities: this.computeClientCapabilities(),
          initializationOptions: Is.func(initOption) ? initOption() : initOption,
          trace: vscode_languageserver_protocol_1.Trace.toString(this._trace),
          workspaceFolders
        };
        this.fillInitializeParams(initParams);
        if (this._clientOptions.progressOnInitialization) {
          const token = UUID.generateUuid();
          const part = new progressPart_1.ProgressPart(connection, token);
          initParams.workDoneToken = token;
          try {
            const result = await this.doInitialize(connection, initParams);
            part.done();
            return result;
          } catch (error) {
            part.cancel();
            throw error;
          }
        } else {
          return this.doInitialize(connection, initParams);
        }
      }
      async doInitialize(connection, initParams) {
        try {
          const result = await connection.initialize(initParams);
          if (result.capabilities.positionEncoding !== void 0 && result.capabilities.positionEncoding !== vscode_languageserver_protocol_1.PositionEncodingKind.UTF16) {
            throw new Error(`Unsupported position encoding (${result.capabilities.positionEncoding}) received from server ${this.name}`);
          }
          this._initializeResult = result;
          this.$state = ClientState.Running;
          let textDocumentSyncOptions = void 0;
          if (Is.number(result.capabilities.textDocumentSync)) {
            if (result.capabilities.textDocumentSync === vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
              textDocumentSyncOptions = {
                openClose: false,
                change: vscode_languageserver_protocol_1.TextDocumentSyncKind.None,
                save: void 0
              };
            } else {
              textDocumentSyncOptions = {
                openClose: true,
                change: result.capabilities.textDocumentSync,
                save: {
                  includeText: false
                }
              };
            }
          } else if (result.capabilities.textDocumentSync !== void 0 && result.capabilities.textDocumentSync !== null) {
            textDocumentSyncOptions = result.capabilities.textDocumentSync;
          }
          this._capabilities = Object.assign({}, result.capabilities, { resolvedTextDocumentSync: textDocumentSyncOptions });
          connection.onNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, (params) => this.handleDiagnostics(params));
          connection.onRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, (params) => this.handleRegistrationRequest(params));
          connection.onRequest("client/registerFeature", (params) => this.handleRegistrationRequest(params));
          connection.onRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, (params) => this.handleUnregistrationRequest(params));
          connection.onRequest("client/unregisterFeature", (params) => this.handleUnregistrationRequest(params));
          connection.onRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, (params) => this.handleApplyWorkspaceEdit(params));
          for (const [method, handler] of this._pendingNotificationHandlers) {
            this._notificationDisposables.set(method, connection.onNotification(method, handler));
          }
          this._pendingNotificationHandlers.clear();
          for (const [method, handler] of this._pendingRequestHandlers) {
            this._requestDisposables.set(method, connection.onRequest(method, handler));
          }
          this._pendingRequestHandlers.clear();
          for (const [token, data] of this._pendingProgressHandlers) {
            this._progressDisposables.set(token, connection.onProgress(data.type, token, data.handler));
          }
          this._pendingProgressHandlers.clear();
          await connection.sendNotification(vscode_languageserver_protocol_1.InitializedNotification.type, {});
          this.hookFileEvents(connection);
          this.hookConfigurationChanged(connection);
          this.initializeFeatures(connection);
          return result;
        } catch (error) {
          if (this._clientOptions.initializationFailedHandler) {
            if (this._clientOptions.initializationFailedHandler(error)) {
              void this.initialize(connection);
            } else {
              void this.stop();
            }
          } else if (error instanceof vscode_languageserver_protocol_1.ResponseError && error.data && error.data.retry) {
            void vscode_1.window.showErrorMessage(error.message, { title: "Retry", id: "retry" }).then((item) => {
              if (item && item.id === "retry") {
                void this.initialize(connection);
              } else {
                void this.stop();
              }
            });
          } else {
            if (error && error.message) {
              void vscode_1.window.showErrorMessage(error.message);
            }
            this.error("Server initialization failed.", error);
            void this.stop();
          }
          throw error;
        }
      }
      _clientGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
          return void 0;
        }
        let folder = folders[0];
        if (folder.uri.scheme === "file") {
          return folder.uri.fsPath;
        }
        return void 0;
      }
      stop(timeout = 2e3) {
        return this.shutdown("stop", timeout);
      }
      dispose(timeout = 2e3) {
        try {
          this._disposed = "disposing";
          return this.stop(timeout);
        } finally {
          this._disposed = "disposed";
        }
      }
      async shutdown(mode, timeout) {
        if (this.$state === ClientState.Stopped || this.$state === ClientState.Initial) {
          return;
        }
        if (this.$state === ClientState.Stopping) {
          if (this._onStop !== void 0) {
            return this._onStop;
          } else {
            throw new Error(`Client is stopping but no stop promise available.`);
          }
        }
        const connection = this.activeConnection();
        if (connection === void 0 || this.$state !== ClientState.Running) {
          throw new Error(`Client is not running and can't be stopped. It's current state is: ${this.$state}`);
        }
        this._initializeResult = void 0;
        this.$state = ClientState.Stopping;
        this.cleanUp(mode);
        const tp = new Promise((c) => {
          (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(c, timeout);
        });
        const shutdown = (async (connection2) => {
          await connection2.shutdown();
          await connection2.exit();
          return connection2;
        })(connection);
        return this._onStop = Promise.race([tp, shutdown]).then((connection2) => {
          if (connection2 !== void 0) {
            connection2.end();
            connection2.dispose();
          } else {
            this.error(`Stopping server timed out`, void 0, false);
            throw new Error(`Stopping the server timed out`);
          }
        }, (error) => {
          this.error(`Stopping server failed`, error, false);
          throw error;
        }).finally(() => {
          this.$state = ClientState.Stopped;
          mode === "stop" && this.cleanUpChannel();
          this._onStart = void 0;
          this._onStop = void 0;
          this._connection = void 0;
          this._ignoredRegistrations.clear();
        });
      }
      cleanUp(mode) {
        this._fileEvents = [];
        this._fileEventDelayer.cancel();
        const disposables = this._listeners.splice(0, this._listeners.length);
        for (const disposable of disposables) {
          disposable.dispose();
        }
        if (this._syncedDocuments) {
          this._syncedDocuments.clear();
        }
        for (const feature of Array.from(this._features.entries()).map((entry) => entry[1]).reverse()) {
          feature.clear();
        }
        if (mode === "stop" && this._diagnostics !== void 0) {
          this._diagnostics.dispose();
          this._diagnostics = void 0;
        }
        if (this._idleInterval !== void 0) {
          this._idleInterval.dispose();
          this._idleInterval = void 0;
        }
      }
      cleanUpChannel() {
        if (this._outputChannel !== void 0 && this._disposeOutputChannel) {
          this._outputChannel.dispose();
          this._outputChannel = void 0;
        }
      }
      notifyFileEvent(event) {
        const client = this;
        async function didChangeWatchedFile(event2) {
          client._fileEvents.push(event2);
          return client._fileEventDelayer.trigger(async () => {
            await client.sendNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, { changes: client._fileEvents });
            client._fileEvents = [];
          });
        }
        const workSpaceMiddleware = this.clientOptions.middleware?.workspace;
        (workSpaceMiddleware?.didChangeWatchedFile ? workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile) : didChangeWatchedFile(event)).catch((error) => {
          client.error(`Notify file events failed.`, error);
        });
      }
      async sendPendingFullTextDocumentChanges(connection) {
        return this._pendingChangeSemaphore.lock(async () => {
          try {
            const changes = this._didChangeTextDocumentFeature.getPendingDocumentChanges(this._pendingOpenNotifications);
            if (changes.length === 0) {
              return;
            }
            for (const document of changes) {
              const params = this.code2ProtocolConverter.asChangeTextDocumentParams(document);
              await connection.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
              this._didChangeTextDocumentFeature.notificationSent(document, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
            }
          } catch (error) {
            this.error(`Sending pending changes failed`, error, false);
            throw error;
          }
        });
      }
      triggerPendingChangeDelivery() {
        this._pendingChangeDelayer.trigger(async () => {
          const connection = this.activeConnection();
          if (connection === void 0) {
            this.triggerPendingChangeDelivery();
            return;
          }
          await this.sendPendingFullTextDocumentChanges(connection);
        }).catch((error) => this.error(`Delivering pending changes failed`, error, false));
      }
      handleDiagnostics(params) {
        if (!this._diagnostics) {
          return;
        }
        const key = params.uri;
        if (this._diagnosticQueueState.state === "busy" && this._diagnosticQueueState.document === key) {
          this._diagnosticQueueState.tokenSource.cancel();
        }
        this._diagnosticQueue.set(params.uri, params.diagnostics);
        this.triggerDiagnosticQueue();
      }
      triggerDiagnosticQueue() {
        (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
          this.workDiagnosticQueue();
        });
      }
      workDiagnosticQueue() {
        if (this._diagnosticQueueState.state === "busy") {
          return;
        }
        const next = this._diagnosticQueue.entries().next();
        if (next.done === true) {
          return;
        }
        const [document, diagnostics] = next.value;
        this._diagnosticQueue.delete(document);
        const tokenSource = new vscode_1.CancellationTokenSource();
        this._diagnosticQueueState = { state: "busy", document, tokenSource };
        this._p2c.asDiagnostics(diagnostics, tokenSource.token).then((converted) => {
          if (!tokenSource.token.isCancellationRequested) {
            const uri = this._p2c.asUri(document);
            const middleware = this.clientOptions.middleware;
            if (middleware.handleDiagnostics) {
              middleware.handleDiagnostics(uri, converted, (uri2, diagnostics2) => this.setDiagnostics(uri2, diagnostics2));
            } else {
              this.setDiagnostics(uri, converted);
            }
          }
        }).finally(() => {
          this._diagnosticQueueState = { state: "idle" };
          this.triggerDiagnosticQueue();
        });
      }
      setDiagnostics(uri, diagnostics) {
        if (!this._diagnostics) {
          return;
        }
        this._diagnostics.set(uri, diagnostics);
      }
      getLocale() {
        return vscode_1.env.language;
      }
      async $start() {
        if (this.$state === ClientState.StartFailed) {
          throw new Error(`Previous start failed. Can't restart server.`);
        }
        await this.start();
        const connection = this.activeConnection();
        if (connection === void 0) {
          throw new Error(`Starting server failed`);
        }
        return connection;
      }
      async createConnection() {
        let errorHandler = (error, message, count) => {
          this.handleConnectionError(error, message, count).catch((error2) => this.error(`Handling connection error failed`, error2));
        };
        let closeHandler = () => {
          this.handleConnectionClosed().catch((error) => this.error(`Handling connection close failed`, error));
        };
        const transports = await this.createMessageTransports(this._clientOptions.stdioEncoding || "utf8");
        this._connection = createConnection(transports.reader, transports.writer, errorHandler, closeHandler, this._clientOptions.connectionOptions);
        return this._connection;
      }
      async handleConnectionClosed() {
        if (this.$state === ClientState.Stopped) {
          return;
        }
        try {
          if (this._connection !== void 0) {
            this._connection.dispose();
          }
        } catch (error) {
        }
        let handlerResult = { action: CloseAction.DoNotRestart };
        if (this.$state !== ClientState.Stopping) {
          try {
            handlerResult = await this._clientOptions.errorHandler.closed();
          } catch (error) {
          }
        }
        this._connection = void 0;
        if (handlerResult.action === CloseAction.DoNotRestart) {
          this.error(handlerResult.message ?? "Connection to server got closed. Server will not be restarted.", void 0, handlerResult.handled === true ? false : "force");
          this.cleanUp("stop");
          if (this.$state === ClientState.Starting) {
            this.$state = ClientState.StartFailed;
          } else {
            this.$state = ClientState.Stopped;
          }
          this._onStop = Promise.resolve();
          this._onStart = void 0;
        } else if (handlerResult.action === CloseAction.Restart) {
          this.info(handlerResult.message ?? "Connection to server got closed. Server will restart.", !handlerResult.handled);
          this.cleanUp("restart");
          this.$state = ClientState.Initial;
          this._onStop = Promise.resolve();
          this._onStart = void 0;
          this.start().catch((error) => this.error(`Restarting server failed`, error, "force"));
        }
      }
      async handleConnectionError(error, message, count) {
        const handlerResult = await this._clientOptions.errorHandler.error(error, message, count);
        if (handlerResult.action === ErrorAction.Shutdown) {
          this.error(handlerResult.message ?? `Client ${this._name}: connection to server is erroring.
${error.message}
Shutting down server.`, void 0, handlerResult.handled === true ? false : "force");
          this.stop().catch((error2) => {
            this.error(`Stopping server failed`, error2, false);
          });
        } else {
          this.error(handlerResult.message ?? `Client ${this._name}: connection to server is erroring.
${error.message}`, void 0, handlerResult.handled === true ? false : "force");
        }
      }
      hookConfigurationChanged(connection) {
        this._listeners.push(vscode_1.workspace.onDidChangeConfiguration(() => {
          this.refreshTrace(connection, true);
        }));
      }
      refreshTrace(connection, sendNotification = false) {
        const config = vscode_1.workspace.getConfiguration(this._id);
        let trace = vscode_languageserver_protocol_1.Trace.Off;
        let traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        if (config) {
          const traceConfig = config.get("trace.server", "off");
          if (typeof traceConfig === "string") {
            trace = vscode_languageserver_protocol_1.Trace.fromString(traceConfig);
          } else {
            trace = vscode_languageserver_protocol_1.Trace.fromString(config.get("trace.server.verbosity", "off"));
            traceFormat = vscode_languageserver_protocol_1.TraceFormat.fromString(config.get("trace.server.format", "text"));
          }
        }
        this._trace = trace;
        this._traceFormat = traceFormat;
        connection.trace(this._trace, this._tracer, {
          sendNotification,
          traceFormat: this._traceFormat
        }).catch((error) => {
          this.error(`Updating trace failed with error`, error, false);
        });
      }
      hookFileEvents(_connection) {
        let fileEvents = this._clientOptions.synchronize.fileEvents;
        if (!fileEvents) {
          return;
        }
        let watchers;
        if (Is.array(fileEvents)) {
          watchers = fileEvents;
        } else {
          watchers = [fileEvents];
        }
        if (!watchers) {
          return;
        }
        this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type.method).registerRaw(UUID.generateUuid(), watchers);
      }
      registerFeatures(features) {
        for (let feature of features) {
          this.registerFeature(feature);
        }
      }
      registerFeature(feature) {
        this._features.push(feature);
        if (features_1.DynamicFeature.is(feature)) {
          const registrationType = feature.registrationType;
          this._dynamicFeatures.set(registrationType.method, feature);
        }
      }
      getFeature(request) {
        return this._dynamicFeatures.get(request);
      }
      hasDedicatedTextSynchronizationFeature(textDocument) {
        const feature = this.getFeature(vscode_languageserver_protocol_1.NotebookDocumentSyncRegistrationType.method);
        if (feature === void 0 || !(feature instanceof notebook_1.NotebookDocumentSyncFeature)) {
          return false;
        }
        return feature.handles(textDocument);
      }
      registerBuiltinFeatures() {
        const pendingFullTextDocumentChanges = /* @__PURE__ */ new Map();
        this.registerFeature(new configuration_1.ConfigurationFeature(this));
        this.registerFeature(new textSynchronization_1.DidOpenTextDocumentFeature(this, this._syncedDocuments));
        this._didChangeTextDocumentFeature = new textSynchronization_1.DidChangeTextDocumentFeature(this, pendingFullTextDocumentChanges);
        this._didChangeTextDocumentFeature.onPendingChangeAdded(() => {
          this.triggerPendingChangeDelivery();
        });
        this.registerFeature(this._didChangeTextDocumentFeature);
        this.registerFeature(new textSynchronization_1.WillSaveFeature(this));
        this.registerFeature(new textSynchronization_1.WillSaveWaitUntilFeature(this));
        this.registerFeature(new textSynchronization_1.DidSaveTextDocumentFeature(this));
        this.registerFeature(new textSynchronization_1.DidCloseTextDocumentFeature(this, this._syncedDocuments, pendingFullTextDocumentChanges));
        this.registerFeature(new fileSystemWatcher_1.FileSystemWatcherFeature(this, (event) => this.notifyFileEvent(event)));
        this.registerFeature(new completion_1.CompletionItemFeature(this));
        this.registerFeature(new hover_1.HoverFeature(this));
        this.registerFeature(new signatureHelp_1.SignatureHelpFeature(this));
        this.registerFeature(new definition_1.DefinitionFeature(this));
        this.registerFeature(new reference_1.ReferencesFeature(this));
        this.registerFeature(new documentHighlight_1.DocumentHighlightFeature(this));
        this.registerFeature(new documentSymbol_1.DocumentSymbolFeature(this));
        this.registerFeature(new workspaceSymbol_1.WorkspaceSymbolFeature(this));
        this.registerFeature(new codeAction_1.CodeActionFeature(this));
        this.registerFeature(new codeLens_1.CodeLensFeature(this));
        this.registerFeature(new formatting_1.DocumentFormattingFeature(this));
        this.registerFeature(new formatting_1.DocumentRangeFormattingFeature(this));
        this.registerFeature(new formatting_1.DocumentOnTypeFormattingFeature(this));
        this.registerFeature(new rename_1.RenameFeature(this));
        this.registerFeature(new documentLink_1.DocumentLinkFeature(this));
        this.registerFeature(new executeCommand_1.ExecuteCommandFeature(this));
        this.registerFeature(new configuration_1.SyncConfigurationFeature(this));
        this.registerFeature(new typeDefinition_1.TypeDefinitionFeature(this));
        this.registerFeature(new implementation_1.ImplementationFeature(this));
        this.registerFeature(new colorProvider_1.ColorProviderFeature(this));
        if (this.clientOptions.workspaceFolder === void 0) {
          this.registerFeature(new workspaceFolder_1.WorkspaceFoldersFeature(this));
        }
        this.registerFeature(new foldingRange_1.FoldingRangeFeature(this));
        this.registerFeature(new declaration_1.DeclarationFeature(this));
        this.registerFeature(new selectionRange_1.SelectionRangeFeature(this));
        this.registerFeature(new progress_1.ProgressFeature(this));
        this.registerFeature(new callHierarchy_1.CallHierarchyFeature(this));
        this.registerFeature(new semanticTokens_1.SemanticTokensFeature(this));
        this.registerFeature(new linkedEditingRange_1.LinkedEditingFeature(this));
        this.registerFeature(new fileOperations_1.DidCreateFilesFeature(this));
        this.registerFeature(new fileOperations_1.DidRenameFilesFeature(this));
        this.registerFeature(new fileOperations_1.DidDeleteFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillCreateFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillRenameFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillDeleteFilesFeature(this));
        this.registerFeature(new typeHierarchy_1.TypeHierarchyFeature(this));
        this.registerFeature(new inlineValue_1.InlineValueFeature(this));
        this.registerFeature(new inlayHint_1.InlayHintsFeature(this));
        this.registerFeature(new diagnostic_1.DiagnosticFeature(this));
        this.registerFeature(new notebook_1.NotebookDocumentSyncFeature(this));
      }
      registerProposedFeatures() {
        this.registerFeatures(ProposedFeatures.createAll(this));
      }
      fillInitializeParams(params) {
        for (let feature of this._features) {
          if (Is.func(feature.fillInitializeParams)) {
            feature.fillInitializeParams(params);
          }
        }
      }
      computeClientCapabilities() {
        const result = {};
        (0, features_1.ensure)(result, "workspace").applyEdit = true;
        const workspaceEdit = (0, features_1.ensure)((0, features_1.ensure)(result, "workspace"), "workspaceEdit");
        workspaceEdit.documentChanges = true;
        workspaceEdit.resourceOperations = [vscode_languageserver_protocol_1.ResourceOperationKind.Create, vscode_languageserver_protocol_1.ResourceOperationKind.Rename, vscode_languageserver_protocol_1.ResourceOperationKind.Delete];
        workspaceEdit.failureHandling = vscode_languageserver_protocol_1.FailureHandlingKind.TextOnlyTransactional;
        workspaceEdit.normalizesLineEndings = true;
        workspaceEdit.changeAnnotationSupport = {
          groupsOnLabel: true
        };
        const diagnostics = (0, features_1.ensure)((0, features_1.ensure)(result, "textDocument"), "publishDiagnostics");
        diagnostics.relatedInformation = true;
        diagnostics.versionSupport = false;
        diagnostics.tagSupport = { valueSet: [vscode_languageserver_protocol_1.DiagnosticTag.Unnecessary, vscode_languageserver_protocol_1.DiagnosticTag.Deprecated] };
        diagnostics.codeDescriptionSupport = true;
        diagnostics.dataSupport = true;
        const windowCapabilities = (0, features_1.ensure)(result, "window");
        const showMessage = (0, features_1.ensure)(windowCapabilities, "showMessage");
        showMessage.messageActionItem = { additionalPropertiesSupport: true };
        const showDocument = (0, features_1.ensure)(windowCapabilities, "showDocument");
        showDocument.support = true;
        const generalCapabilities = (0, features_1.ensure)(result, "general");
        generalCapabilities.staleRequestSupport = {
          cancel: true,
          retryOnContentModified: Array.from(BaseLanguageClient.RequestsToCancelOnContentModified)
        };
        generalCapabilities.regularExpressions = { engine: "ECMAScript", version: "ES2020" };
        generalCapabilities.markdown = {
          parser: "marked",
          version: "1.1.0"
        };
        generalCapabilities.positionEncodings = ["utf-16"];
        if (this._clientOptions.markdown.supportHtml) {
          generalCapabilities.markdown.allowedTags = ["ul", "li", "p", "code", "blockquote", "ol", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "em", "pre", "table", "thead", "tbody", "tr", "th", "td", "div", "del", "a", "strong", "br", "img", "span"];
        }
        for (let feature of this._features) {
          feature.fillClientCapabilities(result);
        }
        return result;
      }
      initializeFeatures(_connection) {
        const documentSelector = this._clientOptions.documentSelector;
        for (const feature of this._features) {
          if (Is.func(feature.preInitialize)) {
            feature.preInitialize(this._capabilities, documentSelector);
          }
        }
        for (const feature of this._features) {
          feature.initialize(this._capabilities, documentSelector);
        }
      }
      async handleRegistrationRequest(params) {
        const middleware = this.clientOptions.middleware?.handleRegisterCapability;
        if (middleware) {
          return middleware(params, (nextParams) => this.doRegisterCapability(nextParams));
        } else {
          return this.doRegisterCapability(params);
        }
      }
      async doRegisterCapability(params) {
        if (!this.isRunning()) {
          for (const registration of params.registrations) {
            this._ignoredRegistrations.add(registration.id);
          }
          return;
        }
        for (const registration of params.registrations) {
          const feature = this._dynamicFeatures.get(registration.method);
          if (feature === void 0) {
            return Promise.reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));
          }
          const options = registration.registerOptions ?? {};
          options.documentSelector = options.documentSelector ?? this._clientOptions.documentSelector;
          const data = {
            id: registration.id,
            registerOptions: options
          };
          try {
            feature.register(data);
          } catch (err) {
            return Promise.reject(err);
          }
        }
      }
      async handleUnregistrationRequest(params) {
        const middleware = this.clientOptions.middleware?.handleUnregisterCapability;
        if (middleware) {
          return middleware(params, (nextParams) => this.doUnregisterCapability(nextParams));
        } else {
          return this.doUnregisterCapability(params);
        }
      }
      async doUnregisterCapability(params) {
        for (const unregistration of params.unregisterations) {
          if (this._ignoredRegistrations.has(unregistration.id)) {
            continue;
          }
          const feature = this._dynamicFeatures.get(unregistration.method);
          if (!feature) {
            return Promise.reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));
          }
          feature.unregister(unregistration.id);
        }
      }
      async handleApplyWorkspaceEdit(params) {
        const workspaceEdit = params.edit;
        const converted = await this.workspaceEditLock.lock(() => {
          return this._p2c.asWorkspaceEdit(workspaceEdit);
        });
        const openTextDocuments = /* @__PURE__ */ new Map();
        vscode_1.workspace.textDocuments.forEach((document) => openTextDocuments.set(document.uri.toString(), document));
        let versionMismatch = false;
        if (workspaceEdit.documentChanges) {
          for (const change of workspaceEdit.documentChanges) {
            if (vscode_languageserver_protocol_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
              const changeUri = this._p2c.asUri(change.textDocument.uri).toString();
              const textDocument = openTextDocuments.get(changeUri);
              if (textDocument && textDocument.version !== change.textDocument.version) {
                versionMismatch = true;
                break;
              }
            }
          }
        }
        if (versionMismatch) {
          return Promise.resolve({ applied: false });
        }
        return Is.asPromise(vscode_1.workspace.applyEdit(converted).then((value) => {
          return { applied: value };
        }));
      }
      handleFailedRequest(type, token, error, defaultValue, showNotification = true) {
        if (error instanceof vscode_languageserver_protocol_1.ResponseError) {
          if (error.code === vscode_languageserver_protocol_1.ErrorCodes.PendingResponseRejected || error.code === vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive) {
            return defaultValue;
          }
          if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.RequestCancelled || error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ServerCancelled) {
            if (token !== void 0 && token.isCancellationRequested) {
              return defaultValue;
            } else {
              if (error.data !== void 0) {
                throw new features_1.LSPCancellationError(error.data);
              } else {
                throw new vscode_1.CancellationError();
              }
            }
          } else if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ContentModified) {
            if (BaseLanguageClient.RequestsToCancelOnContentModified.has(type.method) || BaseLanguageClient.CancellableResolveCalls.has(type.method)) {
              throw new vscode_1.CancellationError();
            } else {
              return defaultValue;
            }
          }
        }
        this.error(`Request ${type.method} failed.`, error, showNotification);
        throw error;
      }
    };
    exports.BaseLanguageClient = BaseLanguageClient;
    BaseLanguageClient.RequestsToCancelOnContentModified = /* @__PURE__ */ new Set([
      vscode_languageserver_protocol_1.SemanticTokensRequest.method,
      vscode_languageserver_protocol_1.SemanticTokensRangeRequest.method,
      vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.method
    ]);
    BaseLanguageClient.CancellableResolveCalls = /* @__PURE__ */ new Set([
      vscode_languageserver_protocol_1.CompletionResolveRequest.method,
      vscode_languageserver_protocol_1.CodeLensResolveRequest.method,
      vscode_languageserver_protocol_1.CodeActionResolveRequest.method,
      vscode_languageserver_protocol_1.InlayHintResolveRequest.method,
      vscode_languageserver_protocol_1.DocumentLinkResolveRequest.method,
      vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.method
    ]);
    var ConsoleLogger = class {
      error(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.error(message);
      }
      warn(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.warn(message);
      }
      info(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.info(message);
      }
      log(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.log(message);
      }
    };
    function createConnection(input, output, errorHandler, closeHandler, options) {
      const logger = new ConsoleLogger();
      const connection = (0, vscode_languageserver_protocol_1.createProtocolConnection)(input, output, logger, options);
      connection.onError((data) => {
        errorHandler(data[0], data[1], data[2]);
      });
      connection.onClose(closeHandler);
      const result = {
        listen: () => connection.listen(),
        sendRequest: connection.sendRequest,
        onRequest: connection.onRequest,
        hasPendingResponse: connection.hasPendingResponse,
        sendNotification: connection.sendNotification,
        onNotification: connection.onNotification,
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        trace: (value, tracer, sendNotificationOrTraceOptions) => {
          const defaultTraceOptions = {
            sendNotification: false,
            traceFormat: vscode_languageserver_protocol_1.TraceFormat.Text
          };
          if (sendNotificationOrTraceOptions === void 0) {
            return connection.trace(value, tracer, defaultTraceOptions);
          } else if (Is.boolean(sendNotificationOrTraceOptions)) {
            return connection.trace(value, tracer, sendNotificationOrTraceOptions);
          } else {
            return connection.trace(value, tracer, sendNotificationOrTraceOptions);
          }
        },
        initialize: (params) => {
          return connection.sendRequest(vscode_languageserver_protocol_1.InitializeRequest.type, params);
        },
        shutdown: () => {
          return connection.sendRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, void 0);
        },
        exit: () => {
          return connection.sendNotification(vscode_languageserver_protocol_1.ExitNotification.type);
        },
        end: () => connection.end(),
        dispose: () => connection.dispose()
      };
      return result;
    }
    var ProposedFeatures;
    (function(ProposedFeatures2) {
      function createAll(_client) {
        let result = [
          new inlineCompletion_1.InlineCompletionItemFeature(_client)
        ];
        return result;
      }
      ProposedFeatures2.createAll = createAll;
    })(ProposedFeatures || (exports.ProposedFeatures = ProposedFeatures = {}));
  }
});

// node_modules/vscode-languageclient/lib/node/processes.js
var require_processes = __commonJS({
  "node_modules/vscode-languageclient/lib/node/processes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.terminate = void 0;
    var cp = require("child_process");
    var path_1 = require("path");
    var isWindows = process.platform === "win32";
    var isMacintosh = process.platform === "darwin";
    var isLinux = process.platform === "linux";
    function terminate(process2, cwd) {
      if (isWindows) {
        try {
          let options = {
            stdio: ["pipe", "pipe", "ignore"]
          };
          if (cwd) {
            options.cwd = cwd;
          }
          cp.execFileSync("taskkill", ["/T", "/F", "/PID", process2.pid.toString()], options);
          return true;
        } catch (err) {
          return false;
        }
      } else if (isLinux || isMacintosh) {
        try {
          var cmd = (0, path_1.join)(__dirname, "terminateProcess.sh");
          var result = cp.spawnSync(cmd, [process2.pid.toString()]);
          return result.error ? false : true;
        } catch (err) {
          return false;
        }
      } else {
        process2.kill("SIGKILL");
        return true;
      }
    }
    exports.terminate = terminate;
  }
});

// node_modules/vscode-languageserver-protocol/node.js
var require_node2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/node.js"(exports, module2) {
    "use strict";
    module2.exports = require_main3();
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports, module2) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports = module2.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports, module2) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports, module2) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports, module2) {
    var SemVer = require_semver();
    var parse = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/semver/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/semver/node_modules/yallist/iterator.js"(exports, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/semver/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/semver/node_modules/yallist/yallist.js"(exports, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/semver/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/semver/node_modules/lru-cache/index.js"(exports, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports, module2) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports, module2) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports, module2) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports, module2) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports, module2) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports, module2) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports, module2) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range3(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range3(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range3 = require_range();
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports, module2) {
    var Range3 = class {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof Range3) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new Range3(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().split(/\s+/).join(" ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof Range3)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range3;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports, module2) {
    var Range3 = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range3(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// node_modules/vscode-languageclient/lib/common/api.js
var require_api3 = __commonJS({
  "node_modules/vscode-languageclient/lib/common/api.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding2(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagnosticPullMode = exports.vsdiag = void 0;
    __exportStar2(require_main3(), exports);
    __exportStar2(require_features(), exports);
    var diagnostic_1 = require_diagnostic();
    Object.defineProperty(exports, "vsdiag", { enumerable: true, get: function() {
      return diagnostic_1.vsdiag;
    } });
    Object.defineProperty(exports, "DiagnosticPullMode", { enumerable: true, get: function() {
      return diagnostic_1.DiagnosticPullMode;
    } });
    __exportStar2(require_client(), exports);
  }
});

// node_modules/vscode-languageclient/lib/node/main.js
var require_main4 = __commonJS({
  "node_modules/vscode-languageclient/lib/node/main.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding2(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SettingMonitor = exports.LanguageClient = exports.TransportKind = void 0;
    var cp = require("child_process");
    var fs = require("fs");
    var path3 = require("path");
    var vscode_1 = require("vscode");
    var Is = require_is();
    var client_1 = require_client();
    var processes_1 = require_processes();
    var node_1 = require_node2();
    var semverParse = require_parse();
    var semverSatisfies = require_satisfies();
    __exportStar2(require_node2(), exports);
    __exportStar2(require_api3(), exports);
    var REQUIRED_VSCODE_VERSION = "^1.82.0";
    var TransportKind2;
    (function(TransportKind3) {
      TransportKind3[TransportKind3["stdio"] = 0] = "stdio";
      TransportKind3[TransportKind3["ipc"] = 1] = "ipc";
      TransportKind3[TransportKind3["pipe"] = 2] = "pipe";
      TransportKind3[TransportKind3["socket"] = 3] = "socket";
    })(TransportKind2 || (exports.TransportKind = TransportKind2 = {}));
    var Transport;
    (function(Transport2) {
      function isSocket(value) {
        const candidate = value;
        return candidate && candidate.kind === TransportKind2.socket && Is.number(candidate.port);
      }
      Transport2.isSocket = isSocket;
    })(Transport || (Transport = {}));
    var Executable;
    (function(Executable2) {
      function is(value) {
        return Is.string(value.command);
      }
      Executable2.is = is;
    })(Executable || (Executable = {}));
    var NodeModule;
    (function(NodeModule2) {
      function is(value) {
        return Is.string(value.module);
      }
      NodeModule2.is = is;
    })(NodeModule || (NodeModule = {}));
    var StreamInfo;
    (function(StreamInfo2) {
      function is(value) {
        let candidate = value;
        return candidate && candidate.writer !== void 0 && candidate.reader !== void 0;
      }
      StreamInfo2.is = is;
    })(StreamInfo || (StreamInfo = {}));
    var ChildProcessInfo;
    (function(ChildProcessInfo2) {
      function is(value) {
        let candidate = value;
        return candidate && candidate.process !== void 0 && typeof candidate.detached === "boolean";
      }
      ChildProcessInfo2.is = is;
    })(ChildProcessInfo || (ChildProcessInfo = {}));
    var LanguageClient2 = class extends client_1.BaseLanguageClient {
      constructor(arg1, arg2, arg3, arg4, arg5) {
        let id;
        let name;
        let serverOptions;
        let clientOptions;
        let forceDebug;
        if (Is.string(arg2)) {
          id = arg1;
          name = arg2;
          serverOptions = arg3;
          clientOptions = arg4;
          forceDebug = !!arg5;
        } else {
          id = arg1.toLowerCase();
          name = arg1;
          serverOptions = arg2;
          clientOptions = arg3;
          forceDebug = arg4;
        }
        if (forceDebug === void 0) {
          forceDebug = false;
        }
        super(id, name, clientOptions);
        this._serverOptions = serverOptions;
        this._forceDebug = forceDebug;
        this._isInDebugMode = forceDebug;
        try {
          this.checkVersion();
        } catch (error) {
          if (Is.string(error.message)) {
            this.outputChannel.appendLine(error.message);
          }
          throw error;
        }
      }
      checkVersion() {
        const codeVersion = semverParse(vscode_1.version);
        if (!codeVersion) {
          throw new Error(`No valid VS Code version detected. Version string is: ${vscode_1.version}`);
        }
        if (codeVersion.prerelease && codeVersion.prerelease.length > 0) {
          codeVersion.prerelease = [];
        }
        if (!semverSatisfies(codeVersion, REQUIRED_VSCODE_VERSION)) {
          throw new Error(`The language client requires VS Code version ${REQUIRED_VSCODE_VERSION} but received version ${vscode_1.version}`);
        }
      }
      get isInDebugMode() {
        return this._isInDebugMode;
      }
      async restart() {
        await this.stop();
        if (this.isInDebugMode) {
          await new Promise((resolve) => setTimeout(resolve, 1e3));
          await this.start();
        } else {
          await this.start();
        }
      }
      stop(timeout = 2e3) {
        return super.stop(timeout).finally(() => {
          if (this._serverProcess) {
            const toCheck = this._serverProcess;
            this._serverProcess = void 0;
            if (this._isDetached === void 0 || !this._isDetached) {
              this.checkProcessDied(toCheck);
            }
            this._isDetached = void 0;
          }
        });
      }
      checkProcessDied(childProcess) {
        if (!childProcess || childProcess.pid === void 0) {
          return;
        }
        setTimeout(() => {
          try {
            if (childProcess.pid !== void 0) {
              process.kill(childProcess.pid, 0);
              (0, processes_1.terminate)(childProcess);
            }
          } catch (error) {
          }
        }, 2e3);
      }
      handleConnectionClosed() {
        this._serverProcess = void 0;
        return super.handleConnectionClosed();
      }
      fillInitializeParams(params) {
        super.fillInitializeParams(params);
        if (params.processId === null) {
          params.processId = process.pid;
        }
      }
      createMessageTransports(encoding) {
        function getEnvironment(env2, fork) {
          if (!env2 && !fork) {
            return void 0;
          }
          const result = /* @__PURE__ */ Object.create(null);
          Object.keys(process.env).forEach((key) => result[key] = process.env[key]);
          if (fork) {
            result["ELECTRON_RUN_AS_NODE"] = "1";
            result["ELECTRON_NO_ASAR"] = "1";
          }
          if (env2) {
            Object.keys(env2).forEach((key) => result[key] = env2[key]);
          }
          return result;
        }
        const debugStartWith = ["--debug=", "--debug-brk=", "--inspect=", "--inspect-brk="];
        const debugEquals = ["--debug", "--debug-brk", "--inspect", "--inspect-brk"];
        function startedInDebugMode() {
          let args = process.execArgv;
          if (args) {
            return args.some((arg) => {
              return debugStartWith.some((value) => arg.startsWith(value)) || debugEquals.some((value) => arg === value);
            });
          }
          return false;
        }
        function assertStdio(process2) {
          if (process2.stdin === null || process2.stdout === null || process2.stderr === null) {
            throw new Error("Process created without stdio streams");
          }
        }
        const server = this._serverOptions;
        if (Is.func(server)) {
          return server().then((result) => {
            if (client_1.MessageTransports.is(result)) {
              this._isDetached = !!result.detached;
              return result;
            } else if (StreamInfo.is(result)) {
              this._isDetached = !!result.detached;
              return { reader: new node_1.StreamMessageReader(result.reader), writer: new node_1.StreamMessageWriter(result.writer) };
            } else {
              let cp2;
              if (ChildProcessInfo.is(result)) {
                cp2 = result.process;
                this._isDetached = result.detached;
              } else {
                cp2 = result;
                this._isDetached = false;
              }
              cp2.stderr.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
              return { reader: new node_1.StreamMessageReader(cp2.stdout), writer: new node_1.StreamMessageWriter(cp2.stdin) };
            }
          });
        }
        let json;
        let runDebug = server;
        if (runDebug.run || runDebug.debug) {
          if (this._forceDebug || startedInDebugMode()) {
            json = runDebug.debug;
            this._isInDebugMode = true;
          } else {
            json = runDebug.run;
            this._isInDebugMode = false;
          }
        } else {
          json = server;
        }
        return this._getServerWorkingDir(json.options).then((serverWorkingDir) => {
          if (NodeModule.is(json) && json.module) {
            let node = json;
            let transport = node.transport || TransportKind2.stdio;
            if (node.runtime) {
              const args = [];
              const options = node.options ?? /* @__PURE__ */ Object.create(null);
              if (options.execArgv) {
                options.execArgv.forEach((element) => args.push(element));
              }
              args.push(node.module);
              if (node.args) {
                node.args.forEach((element) => args.push(element));
              }
              const execOptions = /* @__PURE__ */ Object.create(null);
              execOptions.cwd = serverWorkingDir;
              execOptions.env = getEnvironment(options.env, false);
              const runtime = this._getRuntimePath(node.runtime, serverWorkingDir);
              let pipeName = void 0;
              if (transport === TransportKind2.ipc) {
                execOptions.stdio = [null, null, null, "ipc"];
                args.push("--node-ipc");
              } else if (transport === TransportKind2.stdio) {
                args.push("--stdio");
              } else if (transport === TransportKind2.pipe) {
                pipeName = (0, node_1.generateRandomPipeName)();
                args.push(`--pipe=${pipeName}`);
              } else if (Transport.isSocket(transport)) {
                args.push(`--socket=${transport.port}`);
              }
              args.push(`--clientProcessId=${process.pid.toString()}`);
              if (transport === TransportKind2.ipc || transport === TransportKind2.stdio) {
                const serverProcess = cp.spawn(runtime, args, execOptions);
                if (!serverProcess || !serverProcess.pid) {
                  return handleChildProcessStartError(serverProcess, `Launching server using runtime ${runtime} failed.`);
                }
                this._serverProcess = serverProcess;
                serverProcess.stderr.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                if (transport === TransportKind2.ipc) {
                  serverProcess.stdout.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                  return Promise.resolve({ reader: new node_1.IPCMessageReader(serverProcess), writer: new node_1.IPCMessageWriter(serverProcess) });
                } else {
                  return Promise.resolve({ reader: new node_1.StreamMessageReader(serverProcess.stdout), writer: new node_1.StreamMessageWriter(serverProcess.stdin) });
                }
              } else if (transport === TransportKind2.pipe) {
                return (0, node_1.createClientPipeTransport)(pipeName).then((transport2) => {
                  const process2 = cp.spawn(runtime, args, execOptions);
                  if (!process2 || !process2.pid) {
                    return handleChildProcessStartError(process2, `Launching server using runtime ${runtime} failed.`);
                  }
                  this._serverProcess = process2;
                  process2.stderr.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                  process2.stdout.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                  return transport2.onConnected().then((protocol) => {
                    return { reader: protocol[0], writer: protocol[1] };
                  });
                });
              } else if (Transport.isSocket(transport)) {
                return (0, node_1.createClientSocketTransport)(transport.port).then((transport2) => {
                  const process2 = cp.spawn(runtime, args, execOptions);
                  if (!process2 || !process2.pid) {
                    return handleChildProcessStartError(process2, `Launching server using runtime ${runtime} failed.`);
                  }
                  this._serverProcess = process2;
                  process2.stderr.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                  process2.stdout.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                  return transport2.onConnected().then((protocol) => {
                    return { reader: protocol[0], writer: protocol[1] };
                  });
                });
              }
            } else {
              let pipeName = void 0;
              return new Promise((resolve, reject) => {
                const args = (node.args && node.args.slice()) ?? [];
                if (transport === TransportKind2.ipc) {
                  args.push("--node-ipc");
                } else if (transport === TransportKind2.stdio) {
                  args.push("--stdio");
                } else if (transport === TransportKind2.pipe) {
                  pipeName = (0, node_1.generateRandomPipeName)();
                  args.push(`--pipe=${pipeName}`);
                } else if (Transport.isSocket(transport)) {
                  args.push(`--socket=${transport.port}`);
                }
                args.push(`--clientProcessId=${process.pid.toString()}`);
                const options = node.options ?? /* @__PURE__ */ Object.create(null);
                options.env = getEnvironment(options.env, true);
                options.execArgv = options.execArgv || [];
                options.cwd = serverWorkingDir;
                options.silent = true;
                if (transport === TransportKind2.ipc || transport === TransportKind2.stdio) {
                  const sp = cp.fork(node.module, args || [], options);
                  assertStdio(sp);
                  this._serverProcess = sp;
                  sp.stderr.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                  if (transport === TransportKind2.ipc) {
                    sp.stdout.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                    resolve({ reader: new node_1.IPCMessageReader(this._serverProcess), writer: new node_1.IPCMessageWriter(this._serverProcess) });
                  } else {
                    resolve({ reader: new node_1.StreamMessageReader(sp.stdout), writer: new node_1.StreamMessageWriter(sp.stdin) });
                  }
                } else if (transport === TransportKind2.pipe) {
                  (0, node_1.createClientPipeTransport)(pipeName).then((transport2) => {
                    const sp = cp.fork(node.module, args || [], options);
                    assertStdio(sp);
                    this._serverProcess = sp;
                    sp.stderr.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                    sp.stdout.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                    transport2.onConnected().then((protocol) => {
                      resolve({ reader: protocol[0], writer: protocol[1] });
                    }, reject);
                  }, reject);
                } else if (Transport.isSocket(transport)) {
                  (0, node_1.createClientSocketTransport)(transport.port).then((transport2) => {
                    const sp = cp.fork(node.module, args || [], options);
                    assertStdio(sp);
                    this._serverProcess = sp;
                    sp.stderr.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                    sp.stdout.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                    transport2.onConnected().then((protocol) => {
                      resolve({ reader: protocol[0], writer: protocol[1] });
                    }, reject);
                  }, reject);
                }
              });
            }
          } else if (Executable.is(json) && json.command) {
            const command = json;
            const args = json.args !== void 0 ? json.args.slice(0) : [];
            let pipeName = void 0;
            const transport = json.transport;
            if (transport === TransportKind2.stdio) {
              args.push("--stdio");
            } else if (transport === TransportKind2.pipe) {
              pipeName = (0, node_1.generateRandomPipeName)();
              args.push(`--pipe=${pipeName}`);
            } else if (Transport.isSocket(transport)) {
              args.push(`--socket=${transport.port}`);
            } else if (transport === TransportKind2.ipc) {
              throw new Error(`Transport kind ipc is not support for command executable`);
            }
            const options = Object.assign({}, command.options);
            options.cwd = options.cwd || serverWorkingDir;
            if (transport === void 0 || transport === TransportKind2.stdio) {
              const serverProcess = cp.spawn(command.command, args, options);
              if (!serverProcess || !serverProcess.pid) {
                return handleChildProcessStartError(serverProcess, `Launching server using command ${command.command} failed.`);
              }
              serverProcess.stderr.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
              this._serverProcess = serverProcess;
              this._isDetached = !!options.detached;
              return Promise.resolve({ reader: new node_1.StreamMessageReader(serverProcess.stdout), writer: new node_1.StreamMessageWriter(serverProcess.stdin) });
            } else if (transport === TransportKind2.pipe) {
              return (0, node_1.createClientPipeTransport)(pipeName).then((transport2) => {
                const serverProcess = cp.spawn(command.command, args, options);
                if (!serverProcess || !serverProcess.pid) {
                  return handleChildProcessStartError(serverProcess, `Launching server using command ${command.command} failed.`);
                }
                this._serverProcess = serverProcess;
                this._isDetached = !!options.detached;
                serverProcess.stderr.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                serverProcess.stdout.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                return transport2.onConnected().then((protocol) => {
                  return { reader: protocol[0], writer: protocol[1] };
                });
              });
            } else if (Transport.isSocket(transport)) {
              return (0, node_1.createClientSocketTransport)(transport.port).then((transport2) => {
                const serverProcess = cp.spawn(command.command, args, options);
                if (!serverProcess || !serverProcess.pid) {
                  return handleChildProcessStartError(serverProcess, `Launching server using command ${command.command} failed.`);
                }
                this._serverProcess = serverProcess;
                this._isDetached = !!options.detached;
                serverProcess.stderr.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                serverProcess.stdout.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                return transport2.onConnected().then((protocol) => {
                  return { reader: protocol[0], writer: protocol[1] };
                });
              });
            }
          }
          return Promise.reject(new Error(`Unsupported server configuration ` + JSON.stringify(server, null, 4)));
        }).finally(() => {
          if (this._serverProcess !== void 0) {
            this._serverProcess.on("exit", (code, signal) => {
              if (code !== null) {
                this.error(`Server process exited with code ${code}.`, void 0, false);
              }
              if (signal !== null) {
                this.error(`Server process exited with signal ${signal}.`, void 0, false);
              }
            });
          }
        });
      }
      _getRuntimePath(runtime, serverWorkingDirectory) {
        if (path3.isAbsolute(runtime)) {
          return runtime;
        }
        const mainRootPath = this._mainGetRootPath();
        if (mainRootPath !== void 0) {
          const result = path3.join(mainRootPath, runtime);
          if (fs.existsSync(result)) {
            return result;
          }
        }
        if (serverWorkingDirectory !== void 0) {
          const result = path3.join(serverWorkingDirectory, runtime);
          if (fs.existsSync(result)) {
            return result;
          }
        }
        return runtime;
      }
      _mainGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
          return void 0;
        }
        let folder = folders[0];
        if (folder.uri.scheme === "file") {
          return folder.uri.fsPath;
        }
        return void 0;
      }
      _getServerWorkingDir(options) {
        let cwd = options && options.cwd;
        if (!cwd) {
          cwd = this.clientOptions.workspaceFolder ? this.clientOptions.workspaceFolder.uri.fsPath : this._mainGetRootPath();
        }
        if (cwd) {
          return new Promise((s) => {
            fs.lstat(cwd, (err, stats) => {
              s(!err && stats.isDirectory() ? cwd : void 0);
            });
          });
        }
        return Promise.resolve(void 0);
      }
    };
    exports.LanguageClient = LanguageClient2;
    var SettingMonitor = class {
      constructor(_client, _setting) {
        this._client = _client;
        this._setting = _setting;
        this._listeners = [];
      }
      start() {
        vscode_1.workspace.onDidChangeConfiguration(this.onDidChangeConfiguration, this, this._listeners);
        this.onDidChangeConfiguration();
        return new vscode_1.Disposable(() => {
          if (this._client.needsStop()) {
            void this._client.stop();
          }
        });
      }
      onDidChangeConfiguration() {
        let index = this._setting.indexOf(".");
        let primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
        let rest = index >= 0 ? this._setting.substr(index + 1) : void 0;
        let enabled = rest ? vscode_1.workspace.getConfiguration(primary).get(rest, false) : vscode_1.workspace.getConfiguration(primary);
        if (enabled && this._client.needsStart()) {
          this._client.start().catch((error) => this._client.error("Start failed after configuration change", error, "force"));
        } else if (!enabled && this._client.needsStop()) {
          void this._client.stop().catch((error) => this._client.error("Stop failed after configuration change", error, "force"));
        }
      }
    };
    exports.SettingMonitor = SettingMonitor;
    function handleChildProcessStartError(process2, message) {
      if (process2 === null) {
        return Promise.reject(message);
      }
      return new Promise((_, reject) => {
        process2.on("error", (err) => {
          reject(`${message} ${err}`);
        });
        setImmediate(() => reject(message));
      });
    }
  }
});

// node_modules/vscode-languageclient/node.js
var require_node3 = __commonJS({
  "node_modules/vscode-languageclient/node.js"(exports, module2) {
    "use strict";
    module2.exports = require_main4();
  }
});

// node_modules/millan/dist/millan.js
var require_millan = __commonJS({
  "node_modules/millan/dist/millan.js"(exports, module2) {
    !function(t, e) {
      "object" == typeof exports && "object" == typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define("millan", [], e) : "object" == typeof exports ? exports.millan = e() : t.millan = e();
    }("undefined" != typeof self ? self : exports, function() {
      return function(t) {
        var e = {};
        function n(r) {
          if (e[r])
            return e[r].exports;
          var i = e[r] = { i: r, l: false, exports: {} };
          return t[r].call(i.exports, i, i.exports, n), i.l = true, i.exports;
        }
        return n.m = t, n.c = e, n.d = function(t2, e2, r) {
          n.o(t2, e2) || Object.defineProperty(t2, e2, { enumerable: true, get: r });
        }, n.r = function(t2) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
        }, n.t = function(t2, e2) {
          if (1 & e2 && (t2 = n(t2)), 8 & e2)
            return t2;
          if (4 & e2 && "object" == typeof t2 && t2 && t2.__esModule)
            return t2;
          var r = /* @__PURE__ */ Object.create(null);
          if (n.r(r), Object.defineProperty(r, "default", { enumerable: true, value: t2 }), 2 & e2 && "string" != typeof t2)
            for (var i in t2)
              n.d(r, i, function(e3) {
                return t2[e3];
              }.bind(null, i));
          return r;
        }, n.n = function(t2) {
          var e2 = t2 && t2.__esModule ? function() {
            return t2.default;
          } : function() {
            return t2;
          };
          return n.d(e2, "a", e2), e2;
        }, n.o = function(t2, e2) {
          return Object.prototype.hasOwnProperty.call(t2, e2);
        }, n.p = "", n(n.s = 72);
      }([function(t, e, n) {
        "use strict";
        n.r(e);
        var r = n(1), i = function() {
          return (i = Object.assign || function(t2) {
            for (var e2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
              for (var i2 in e2 = arguments[n2])
                Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
            return t2;
          }).apply(this, arguments);
        }, o = function(t2, e2) {
          var n2 = {};
          for (var r2 in t2)
            Object.prototype.hasOwnProperty.call(t2, r2) && e2.indexOf(r2) < 0 && (n2[r2] = t2[r2]);
          if (null != t2 && "function" == typeof Object.getOwnPropertySymbols) {
            var i2 = 0;
            for (r2 = Object.getOwnPropertySymbols(t2); i2 < r2.length; i2++)
              e2.indexOf(r2[i2]) < 0 && (n2[r2[i2]] = t2[r2[i2]]);
          }
          return n2;
        };
        n.d(e, "createKeyword", function() {
          return s;
        }), n.d(e, "keywords", function() {
          return l;
        });
        var a = function() {
          return (a = Object.assign || function(t2) {
            for (var e2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
              for (var i2 in e2 = arguments[n2])
                Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
            return t2;
          }).apply(this, arguments);
        }, u = function(t2, e2) {
          var n2 = {};
          for (var r2 in t2)
            Object.prototype.hasOwnProperty.call(t2, r2) && e2.indexOf(r2) < 0 && (n2[r2] = t2[r2]);
          if (null != t2 && "function" == typeof Object.getOwnPropertySymbols) {
            var i2 = 0;
            for (r2 = Object.getOwnPropertySymbols(t2); i2 < r2.length; i2++)
              e2.indexOf(r2[i2]) < 0 && (n2[r2[i2]] = t2[r2[i2]]);
          }
          return n2;
        }, s = function(t2) {
          var e2 = t2.longer_alt, n2 = void 0 === e2 ? c : e2, s2 = u(t2, ["longer_alt"]);
          return function(t3) {
            var e3 = t3.name, n3 = t3.pattern, a2 = o(t3, ["name", "pattern"]);
            return Object(r.createToken)(i({ name: e3, pattern: n3 || new RegExp(e3, "i") }, a2));
          }(a({ longer_alt: n2 }, s2));
        }, c = Object(r.createToken)({ name: "UNKNOWN", pattern: /\w+/i }), l = { SELECT: s({ name: "SELECT" }), CONSTRUCT: s({ name: "CONSTRUCT" }), DISTINCT: s({ name: "DISTINCT" }), START: s({ name: "START" }), END: s({ name: "END" }), VIA: s({ name: "VIA" }), PATHS: s({ name: "PATHS" }), PATHS_ALL: s({ name: "PATHS_ALL", pattern: /PATHS ALL/i }), PATHS_SHORTEST: s({ name: "PATHS_SHORTEST", pattern: /PATHS SHORTEST/i }), CYCLIC: s({ name: "CYCLIC" }), AS: s({ name: "AS" }), WHERE: s({ name: "WHERE" }), A: s({ name: "A", pattern: /a/ }), GROUP_BY: s({ name: "GROUP_BY", pattern: /GROUP BY/i }), ORDER_BY: s({ name: "ORDER_BY", pattern: /ORDER BY/i }), BY: s({ name: "BY" }), BASE: s({ name: "BASE" }), PREFIX: s({ name: "PREFIX" }), DESCRIBE: s({ name: "DESCRIBE" }), ASK: s({ name: "ASK" }), FROM: s({ name: "FROM" }), REDUCED: s({ name: "REDUCED" }), NAMED: s({ name: "NAMED" }), HAVING: s({ name: "HAVING" }), ASC: s({ name: "ASC" }), DESC: s({ name: "DESC" }), OFFSET: s({ name: "OFFSET" }), LIMIT: s({ name: "LIMIT" }), VALUES: s({ name: "VALUES" }), LOAD: s({ name: "LOAD" }), SILENT: s({ name: "SILENT" }), INTO: s({ name: "INTO" }), CLEAR: s({ name: "CLEAR" }), DROP: s({ name: "DROP" }), CREATE: s({ name: "CREATE" }), ADD: s({ name: "ADD" }), TO: s({ name: "TO" }), MOVE: s({ name: "MOVE" }), COPY: s({ name: "COPY" }), INSERT_DATA: s({ name: "INSERT_DATA", pattern: /INSERT +DATA/i }), DELETE_DATA: s({ name: "DELETE_DATA", pattern: /DELETE +DATA/i }), DELETE_WHERE: s({ name: "DELETE_WHERE", pattern: /DELETE +WHERE/i }), WITH: s({ name: "WITH" }), DELETE: s({ name: "DELETE" }), INSERT: s({ name: "INSERT" }), USING: s({ name: "USING" }), DEFAULT: s({ name: "DEFAULT" }), GRAPH: s({ name: "GRAPH" }), ALL: s({ name: "ALL" }), OPTIONAL: s({ name: "OPTIONAL" }), SERVICE: s({ name: "SERVICE" }), BIND: s({ name: "BIND" }), UNNEST: s({ name: "UNNEST" }), UNDEF: s({ name: "UNDEF" }), MINUS: s({ name: "MINUS" }), UNION: s({ name: "UNION" }), FILTER: s({ name: "FILTER" }), STR: s({ name: "STR" }), LANG: s({ name: "LANG" }), LANGMATCHES: s({ name: "LANGMATCHES" }), DATATYPE: s({ name: "DATATYPE" }), BOUND: s({ name: "BOUND" }), IRI: s({ name: "IRI" }), URI: s({ name: "URI" }), BNODE: s({ name: "BNODE" }), RAND: s({ name: "RAND" }), ABS: s({ name: "ABS" }), CEIL: s({ name: "CEIL" }), FLOOR: s({ name: "FLOOR" }), ROUND: s({ name: "ROUND" }), CONCAT: s({ name: "CONCAT" }), STRLEN: s({ name: "STRLEN" }), UCASE: s({ name: "UCASE" }), LCASE: s({ name: "LCASE" }), ENCODE_FOR_URI: s({ name: "ENCODE_FOR_URI" }), CONTAINS: s({ name: "CONTAINS" }), STRSTARTS: s({ name: "STRSTARTS" }), STRENDS: s({ name: "STRENDS" }), STRBEFORE: s({ name: "STRBEFORE" }), STRAFTER: s({ name: "STRAFTER" }), YEAR: s({ name: "YEAR" }), MONTH: s({ name: "MONTH" }), DAY: s({ name: "DAY" }), HOURS: s({ name: "HOURS" }), MINUTES: s({ name: "MINUTES" }), SECONDS: s({ name: "SECONDS" }), TIMEZONE: s({ name: "TIMEZONE" }), TZ: s({ name: "TZ" }), NOW: s({ name: "NOW" }), UUID: s({ name: "UUID" }), STRUUID: s({ name: "STRUUID" }), MD5: s({ name: "MD5" }), SHA1: s({ name: "SHA1" }), SHA256: s({ name: "SHA256" }), SHA384: s({ name: "SHA384" }), SHA512: s({ name: "SHA512" }), COALESCE: s({ name: "COALESCE" }), IF: s({ name: "IF" }), STRLANG: s({ name: "STRLANG" }), STRDT: s({ name: "STRDT" }), sameTerm: s({ name: "sameTerm" }), isIRI: s({ name: "isIRI" }), isURI: s({ name: "isURI" }), isBLANK: s({ name: "isBLANK" }), isLITERAL: s({ name: "isLITERAL" }), isNUMERIC: s({ name: "isNUMERIC" }), REGEX: s({ name: "REGEX" }), SUBSTR: s({ name: "SUBSTR" }), REPLACE: s({ name: "REPLACE" }), EXISTS: s({ name: "EXISTS" }), NOT_EXISTS: s({ name: "NOT_EXISTS", pattern: /NOT EXISTS/i }), COUNT: s({ name: "COUNT" }), SUM: s({ name: "SUM" }), MIN: s({ name: "MIN" }), AVG: s({ name: "AVG" }), SAMPLE: s({ name: "SAMPLE" }), GROUP_CONCAT: s({ name: "GROUP_CONCAT" }), SEPARATOR: s({ name: "SEPARATOR" }), TRUE: s({ name: "TRUE" }), FALSE: s({ name: "FALSE" }), IN: s({ name: "IN" }), NOT_IN: s({ name: "NOT_IN", pattern: /NOT IN/i }), MAX_LENGTH: s({ name: "MAX_LENGTH", pattern: /MAX LENGTH/i }), MAX: s({ name: "MAX" }), VALIDATE: s({ name: "VALIDATE" }), SHAPES: s({ name: "SHAPES" }), SHAPE: s({ name: "SHAPE" }), PER: s({ name: "PER" }), UNKNOWN: c };
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(8), i = n(23), o = n(7), a = n(13), u = n(25), s = n(17), c = n(50), l = n(11), E = n(6), p = n(33), f = n(51), L = n(29), S = {};
        S.VERSION = u.VERSION, S.Parser = r.Parser, S.CstParser = r.CstParser, S.EmbeddedActionsParser = r.EmbeddedActionsParser;
        S.ParserDefinitionErrorType = r.ParserDefinitionErrorType, S.Lexer = i.Lexer, S.LexerDefinitionErrorType = i.LexerDefinitionErrorType, S.EOF = o.EOF, S.tokenName = o.tokenName, S.tokenLabel = o.tokenLabel, S.tokenMatcher = o.tokenMatcher, S.createToken = o.createToken, S.createTokenInstance = o.createTokenInstance, S.EMPTY_ALT = r.EMPTY_ALT, S.defaultParserErrorProvider = s.defaultParserErrorProvider, S.isRecognitionException = a.isRecognitionException, S.EarlyExitException = a.EarlyExitException, S.MismatchedTokenException = a.MismatchedTokenException, S.NotAllInputParsedException = a.NotAllInputParsedException, S.NoViableAltException = a.NoViableAltException, S.defaultLexerErrorProvider = L.defaultLexerErrorProvider, S.Flat = E.Flat, S.Repetition = E.Repetition, S.RepetitionWithSeparator = E.RepetitionWithSeparator, S.RepetitionMandatory = E.RepetitionMandatory, S.RepetitionMandatoryWithSeparator = E.RepetitionMandatoryWithSeparator, S.Option = E.Option, S.Alternation = E.Alternation, S.NonTerminal = E.NonTerminal, S.Terminal = E.Terminal, S.Rule = E.Rule, S.GAstVisitor = l.GAstVisitor, S.serializeGrammar = E.serializeGrammar, S.serializeProduction = E.serializeProduction, S.resolveGrammar = p.resolveGrammar, S.defaultGrammarResolverErrorProvider = s.defaultGrammarResolverErrorProvider, S.validateGrammar = p.validateGrammar, S.defaultGrammarValidatorErrorProvider = s.defaultGrammarValidatorErrorProvider, S.assignOccurrenceIndices = p.assignOccurrenceIndices, S.clearCache = function() {
          console.warn("The clearCache function was 'soft' removed from the Chevrotain API.\n	 It performs no action other than printing this message.\n	 Please avoid using it as it will be completely removed in the future");
        }, S.createSyntaxDiagramsCode = c.createSyntaxDiagramsCode, S.generateParserFactory = f.generateParserFactory, S.generateParserModule = f.generateParserModule, t.exports = S;
      }, function(t, e, n) {
        "use strict";
        n.d(e, "a", function() {
          return r;
        });
        var r = { or: function() {
          for (var t2 = [], e2 = 0; e2 < arguments.length; e2++)
            t2[e2] = arguments[e2];
          return new RegExp(t2.map(function(t3) {
            return "(" + t3.source + ")";
          }).join("|"));
        }, and: function() {
          for (var t2 = [], e2 = 0; e2 < arguments.length; e2++)
            t2[e2] = arguments[e2];
          return new RegExp(t2.map(function(t3) {
            return "(" + t3.source + ")";
          }).join(""));
        }, option: function(t2) {
          return new RegExp("(" + t2.source + ")?");
        }, many: function(t2) {
          return new RegExp("(" + t2.source + ")*");
        } };
      }, function(t, e, n) {
        "use strict";
        n.r(e), n.d(e, "CATCH_ALL", function() {
          return i;
        }), n.d(e, "CATCH_ALL_AT_LEAST_ONE", function() {
          return o;
        }), n.d(e, "IRIREF", function() {
          return a;
        }), n.d(e, "PN_CHARS_BASE", function() {
          return u;
        }), n.d(e, "LANGTAG", function() {
          return s;
        }), n.d(e, "INTEGER", function() {
          return c;
        }), n.d(e, "DECIMAL", function() {
          return l;
        }), n.d(e, "EXPONENT", function() {
          return E;
        }), n.d(e, "ECHAR", function() {
          return p;
        }), n.d(e, "WS", function() {
          return f;
        }), n.d(e, "HEX", function() {
          return L;
        }), n.d(e, "PN_LOCAL_ESC", function() {
          return S;
        }), n.d(e, "PN_CHARS_U", function() {
          return h;
        }), n.d(e, "PN_CHARS", function() {
          return T;
        }), n.d(e, "PN_PREFIX", function() {
          return U;
        }), n.d(e, "PERCENT", function() {
          return R;
        }), n.d(e, "PLX", function() {
          return d;
        }), n.d(e, "PN_LOCAL", function() {
          return O;
        }), n.d(e, "VARNAME", function() {
          return N;
        }), n.d(e, "ANON", function() {
          return A;
        }), n.d(e, "NIL", function() {
          return m;
        }), n.d(e, "STRING_LITERAL1", function() {
          return C;
        }), n.d(e, "STRING_LITERAL2", function() {
          return I;
        }), n.d(e, "STRING_LITERAL_LONG1", function() {
          return y;
        }), n.d(e, "STRING_LITERAL_LONG2", function() {
          return _;
        }), n.d(e, "DOUBLE", function() {
          return P;
        }), n.d(e, "INTEGER_POSITIVE", function() {
          return v;
        }), n.d(e, "DECIMAL_POSITIVE", function() {
          return M;
        }), n.d(e, "DOUBLE_POSITIVE", function() {
          return g;
        }), n.d(e, "INTEGER_NEGATIVE", function() {
          return B;
        }), n.d(e, "DECIMAL_NEGATIVE", function() {
          return k;
        }), n.d(e, "DOUBLE_NEGATIVE", function() {
          return D;
        }), n.d(e, "VAR1", function() {
          return b;
        }), n.d(e, "VAR2", function() {
          return x;
        }), n.d(e, "BLANK_NODE_LABEL", function() {
          return F;
        }), n.d(e, "PNAME_NS", function() {
          return G;
        }), n.d(e, "PNAME_LN", function() {
          return w;
        });
        var r = n(2), i = /[\s\S]*/, o = /[\s\S]+/, a = /<[^<>\\{}|\^`\u0000-\u0020]*>/, u = /[A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDBFF][\uDC00-\uDFFF]/, s = /@[a-zA-Z]+(-[a-zA-Z0-9]+)*/, c = /\d+/, l = /(\d*\.\d+)|(\d+\.\d*)/, E = /[eE][+-]?\d+/, p = /\\[tbnrf"'\\]/, f = /[\u0020\u0009\u000d\u000a]/, L = /[0-9A-Fa-f]/, S = /\\[_~.\-!\$&'()*+,=\/?#@%;]/, h = r.a.or(u, /_/), T = r.a.or(h, /-/, /\d/, /\u00b7/, /[\u0300-\u036f]/, /[\u203f-\u2040]/), U = r.a.and(u, r.a.option(r.a.and(r.a.many(r.a.or(T, /\./)), T))), R = r.a.and(/%/, L, L), d = r.a.or(R, S), O = r.a.and(r.a.or(h, /:/, /\d/, d), r.a.option(r.a.and(r.a.many(r.a.or(T, /\./, /:/, d)), r.a.or(T, /:/, d)))), N = r.a.and(r.a.or(h, /\d/), r.a.many(r.a.or(h, /\d/, /\u00b7/, /[\u0300-\u036f]/, /[\u203f-\u2040]/))), A = r.a.and(/\[/, r.a.many(f), /\]/), m = r.a.and(/\(/, r.a.many(f), /\)/), C = r.a.and(/'/, r.a.many(r.a.or(/[^\u0027\u005C\u000A\u000D]/, p)), /'/), I = r.a.and(/"/, r.a.many(r.a.or(/[^\u0022\u005C\u000A\u000D]/, p)), /"/), y = r.a.and(/'''/, r.a.many(r.a.and(r.a.option(r.a.or(/'/, /''/)), r.a.or(/[^'\\]/, p))), /'''/), _ = r.a.and(/"""/, r.a.many(r.a.and(r.a.option(r.a.or(/"/, /""/)), r.a.or(/[^"\\]/, p))), /"""/), P = r.a.or(r.a.and(/\d+\.\d*/, E), r.a.and(/\.\d+/, E), r.a.and(/\d+/, E)), v = r.a.and(/\+/, c), M = r.a.and(/\+/, l), g = r.a.and(/\+/, P), B = r.a.and(/-/, c), k = r.a.and(/-/, l), D = r.a.and(/-/, P), b = r.a.and(/\?/, N), x = r.a.and(/\$/, N), F = r.a.and(/_:/, r.a.or(h, /\d/), r.a.option(r.a.and(r.a.many(r.a.or(T, /\./)), T))), G = r.a.and(r.a.option(U), /:/), w = r.a.and(G, O);
      }, function(t, e, n) {
        "use strict";
        function r(t2) {
          return t2 && 0 === t2.length;
        }
        function i(t2) {
          return null == t2 ? [] : Object.keys(t2);
        }
        function o(t2) {
          for (var e2 = [], n2 = Object.keys(t2), r2 = 0; r2 < n2.length; r2++)
            e2.push(t2[n2[r2]]);
          return e2;
        }
        function a(t2, e2) {
          for (var n2 = [], r2 = i(t2), o2 = 0; o2 < r2.length; o2++) {
            var a2 = r2[o2];
            n2.push(e2.call(null, t2[a2], a2));
          }
          return n2;
        }
        function u(t2, e2) {
          for (var n2 = [], r2 = 0; r2 < t2.length; r2++)
            n2.push(e2.call(null, t2[r2], r2));
          return n2;
        }
        function s(t2) {
          for (var e2 = [], n2 = 0; n2 < t2.length; n2++) {
            var r2 = t2[n2];
            Array.isArray(r2) ? e2 = e2.concat(s(r2)) : e2.push(r2);
          }
          return e2;
        }
        function c(t2) {
          return r(t2) ? void 0 : t2[0];
        }
        function l(t2) {
          var e2 = t2 && t2.length;
          return e2 ? t2[e2 - 1] : void 0;
        }
        function E(t2, e2) {
          if (Array.isArray(t2))
            for (var n2 = 0; n2 < t2.length; n2++)
              e2.call(null, t2[n2], n2);
          else {
            if (!g(t2))
              throw Error("non exhaustive match");
            var r2 = i(t2);
            for (n2 = 0; n2 < r2.length; n2++) {
              var o2 = r2[n2], a2 = t2[o2];
              e2.call(null, a2, o2);
            }
          }
        }
        function p(t2) {
          return "string" == typeof t2;
        }
        function f(t2) {
          return void 0 === t2;
        }
        function L(t2) {
          return t2 instanceof Function;
        }
        function S(t2, e2) {
          return void 0 === e2 && (e2 = 1), t2.slice(e2, t2.length);
        }
        function h(t2, e2) {
          return void 0 === e2 && (e2 = 1), t2.slice(0, t2.length - e2);
        }
        function T(t2, e2) {
          var n2 = [];
          if (Array.isArray(t2))
            for (var r2 = 0; r2 < t2.length; r2++) {
              var i2 = t2[r2];
              e2.call(null, i2) && n2.push(i2);
            }
          return n2;
        }
        function U(t2, e2) {
          return T(t2, function(t3) {
            return !e2(t3);
          });
        }
        function R(t2, e2) {
          for (var n2 = Object.keys(t2), r2 = {}, i2 = 0; i2 < n2.length; i2++) {
            var o2 = n2[i2], a2 = t2[o2];
            e2(a2) && (r2[o2] = a2);
          }
          return r2;
        }
        function d(t2, e2) {
          return !!g(t2) && t2.hasOwnProperty(e2);
        }
        function O(t2, e2) {
          return void 0 !== m(t2, function(t3) {
            return t3 === e2;
          });
        }
        function N(t2) {
          for (var e2 = [], n2 = 0; n2 < t2.length; n2++)
            e2.push(t2[n2]);
          return e2;
        }
        function A(t2) {
          var e2 = {};
          for (var n2 in t2)
            Object.prototype.hasOwnProperty.call(t2, n2) && (e2[n2] = t2[n2]);
          return e2;
        }
        function m(t2, e2) {
          for (var n2 = 0; n2 < t2.length; n2++) {
            var r2 = t2[n2];
            if (e2.call(null, r2))
              return r2;
          }
        }
        function C(t2, e2) {
          for (var n2 = [], r2 = 0; r2 < t2.length; r2++) {
            var i2 = t2[r2];
            e2.call(null, i2) && n2.push(i2);
          }
          return n2;
        }
        function I(t2, e2, n2) {
          for (var r2 = Array.isArray(t2), a2 = r2 ? t2 : o(t2), u2 = r2 ? [] : i(t2), s2 = n2, c2 = 0; c2 < a2.length; c2++)
            s2 = e2.call(null, s2, a2[c2], r2 ? c2 : u2[c2]);
          return s2;
        }
        function y(t2) {
          return U(t2, function(t3) {
            return null == t3;
          });
        }
        function _(t2, e2) {
          void 0 === e2 && (e2 = function(t3) {
            return t3;
          });
          var n2 = [];
          return I(t2, function(t3, r2) {
            var i2 = e2(r2);
            return O(n2, i2) ? t3 : (n2.push(i2), t3.concat(r2));
          }, []);
        }
        function P(t2) {
          for (var e2 = [], n2 = 1; n2 < arguments.length; n2++)
            e2[n2 - 1] = arguments[n2];
          var r2 = [null].concat(e2);
          return Function.bind.apply(t2, r2);
        }
        function v(t2) {
          return Array.isArray(t2);
        }
        function M(t2) {
          return t2 instanceof RegExp;
        }
        function g(t2) {
          return t2 instanceof Object;
        }
        function B(t2, e2) {
          for (var n2 = 0; n2 < t2.length; n2++)
            if (!e2(t2[n2], n2))
              return false;
          return true;
        }
        function k(t2, e2) {
          return U(t2, function(t3) {
            return O(e2, t3);
          });
        }
        function D(t2, e2) {
          for (var n2 = 0; n2 < t2.length; n2++)
            if (e2(t2[n2]))
              return true;
          return false;
        }
        function b(t2, e2) {
          for (var n2 = 0; n2 < t2.length; n2++)
            if (t2[n2] === e2)
              return n2;
          return -1;
        }
        function x(t2, e2) {
          var n2 = N(t2);
          return n2.sort(function(t3, n3) {
            return e2(t3) - e2(n3);
          }), n2;
        }
        function F(t2, e2) {
          if (t2.length !== e2.length)
            throw Error("can't zipObject with different number of keys and values!");
          for (var n2 = {}, r2 = 0; r2 < t2.length; r2++)
            n2[t2[r2]] = e2[r2];
          return n2;
        }
        function G(t2) {
          for (var e2 = [], n2 = 1; n2 < arguments.length; n2++)
            e2[n2 - 1] = arguments[n2];
          for (var r2 = 0; r2 < e2.length; r2++)
            for (var o2 = e2[r2], a2 = i(o2), u2 = 0; u2 < a2.length; u2++) {
              var s2 = a2[u2];
              t2[s2] = o2[s2];
            }
          return t2;
        }
        function w(t2) {
          for (var e2 = [], n2 = 1; n2 < arguments.length; n2++)
            e2[n2 - 1] = arguments[n2];
          for (var r2 = 0; r2 < e2.length; r2++) {
            var o2 = e2[r2];
            if (!f(o2))
              for (var a2 = i(o2), u2 = 0; u2 < a2.length; u2++) {
                var s2 = a2[u2];
                d(t2, s2) || (t2[s2] = o2[s2]);
              }
          }
          return t2;
        }
        function j() {
          for (var t2 = [], e2 = 0; e2 < arguments.length; e2++)
            t2[e2] = arguments[e2];
          return w.apply(null, [{}].concat(t2));
        }
        function V(t2, e2) {
          var n2 = {};
          return E(t2, function(t3) {
            var r2 = e2(t3), i2 = n2[r2];
            i2 ? i2.push(t3) : n2[r2] = [t3];
          }), n2;
        }
        function H(t2, e2) {
          for (var n2 = A(t2), r2 = i(e2), o2 = 0; o2 < r2.length; o2++) {
            var a2 = r2[o2], u2 = e2[a2];
            n2[a2] = u2;
          }
          return n2;
        }
        function W() {
        }
        function Y(t2) {
          return t2;
        }
        function K(t2) {
          for (var e2 = [], n2 = 0; n2 < t2.length; n2++) {
            var r2 = t2[n2];
            e2.push(void 0 !== r2 ? r2 : void 0);
          }
          return e2;
        }
        function X(t2) {
          console && console.error && console.error("Error: " + t2);
        }
        function q(t2) {
          console && console.warn && console.warn("Warning: " + t2);
        }
        function z() {
          return "function" == typeof Map;
        }
        function Q(t2, e2) {
          e2.forEach(function(e3) {
            var n2 = e3.prototype;
            Object.getOwnPropertyNames(n2).forEach(function(r2) {
              if ("constructor" !== r2) {
                var i2 = Object.getOwnPropertyDescriptor(n2, r2);
                i2 && (i2.get || i2.set) ? Object.defineProperty(t2.prototype, r2, i2) : t2.prototype[r2] = e3.prototype[r2];
              }
            });
          });
        }
        function $(t2) {
          function e2() {
          }
          e2.prototype = t2;
          var n2 = new e2();
          function r2() {
            return typeof n2.bar;
          }
          return r2(), r2(), t2;
        }
        Object.defineProperty(e, "__esModule", { value: true }), e.isEmpty = r, e.keys = i, e.values = o, e.mapValues = a, e.map = u, e.flatten = s, e.first = c, e.last = l, e.forEach = E, e.isString = p, e.isUndefined = f, e.isFunction = L, e.drop = S, e.dropRight = h, e.filter = T, e.reject = U, e.pick = R, e.has = d, e.contains = O, e.cloneArr = N, e.cloneObj = A, e.find = m, e.findAll = C, e.reduce = I, e.compact = y, e.uniq = _, e.partial = P, e.isArray = v, e.isRegExp = M, e.isObject = g, e.every = B, e.difference = k, e.some = D, e.indexOf = b, e.sortBy = x, e.zipObject = F, e.assign = G, e.assignNoOverwrite = w, e.defaults = j, e.groupBy = V, e.merge = H, e.NOOP = W, e.IDENTITY = Y, e.packArray = K, e.PRINT_ERROR = X, e.PRINT_WARNING = q, e.isES2015MapSupported = z, e.applyMixins = Q, e.toFastProperties = $;
      }, function(t, e, n) {
        "use strict";
        n.r(e), n.d(e, "terminals", function() {
          return s;
        });
        var r = n(1), i = n(3), o = Object(r.createToken)({ name: "STRING_LITERAL_LONG1", pattern: i.STRING_LITERAL_LONG1 }), a = Object(r.createToken)({ name: "STRING_LITERAL_LONG2", pattern: i.STRING_LITERAL_LONG2 }), u = Object(r.createToken)({ name: "PNAME_LN", pattern: i.PNAME_LN }), s = { IRIREF: Object(r.createToken)({ name: "IRIREF", pattern: i.IRIREF, label: "<http://example.com>" }), LANGTAG: Object(r.createToken)({ name: "LANGTAG", pattern: i.LANGTAG }), INTEGER: Object(r.createToken)({ name: "INTEGER", pattern: i.INTEGER }), DECIMAL: Object(r.createToken)({ name: "DECIMAL", pattern: i.DECIMAL }), DOUBLE: Object(r.createToken)({ name: "DOUBLE", pattern: i.DOUBLE }), INTEGER_POSITIVE: Object(r.createToken)({ name: "INTEGER_POSITIVE", pattern: i.INTEGER_POSITIVE }), DECIMAL_POSITIVE: Object(r.createToken)({ name: "DECIMAL_POSITIVE", pattern: i.DECIMAL_POSITIVE }), DOUBLE_POSITIVE: Object(r.createToken)({ name: "DOUBLE_POSITIVE", pattern: i.DOUBLE_POSITIVE }), INTEGER_NEGATIVE: Object(r.createToken)({ name: "INTEGER_NEGATIVE", pattern: i.INTEGER_NEGATIVE }), DECIMAL_NEGATIVE: Object(r.createToken)({ name: "DECIMAL_NEGATIVE", pattern: i.DECIMAL_NEGATIVE }), DOUBLE_NEGATIVE: Object(r.createToken)({ name: "DOUBLE_NEGATIVE", pattern: i.DOUBLE_NEGATIVE }), STRING_LITERAL_LONG1: o, STRING_LITERAL_LONG2: a, STRING_LITERAL1: Object(r.createToken)({ name: "STRING_LITERAL1", pattern: i.STRING_LITERAL1, longer_alt: o }), STRING_LITERAL2: Object(r.createToken)({ name: "STRING_LITERAL2", pattern: i.STRING_LITERAL2, longer_alt: a }), NIL: Object(r.createToken)({ name: "NIL", pattern: i.NIL, label: "()" }), ANON: Object(r.createToken)({ name: "ANON", pattern: i.ANON, label: "[]" }), PNAME_LN: u, PNAME_NS: Object(r.createToken)({ name: "PNAME_NS", pattern: i.PNAME_NS, longer_alt: u }), BLANK_NODE_LABEL: Object(r.createToken)({ name: "BLANK_NODE_LABEL", pattern: i.BLANK_NODE_LABEL }), VAR1: Object(r.createToken)({ name: "VAR1", pattern: i.VAR1, label: "?foo" }), VAR2: Object(r.createToken)({ name: "VAR2", pattern: i.VAR2, label: "?bar" }), PERCENT: Object(r.createToken)({ name: "PERCENT", pattern: i.PERCENT }) };
      }, function(t, e, n) {
        "use strict";
        var r, i = this && this.__extends || (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        });
        Object.defineProperty(e, "__esModule", { value: true });
        var o = n(4), a = n(7), u = function() {
          function t2(t3) {
            this.definition = t3;
          }
          return t2.prototype.accept = function(t3) {
            t3.visit(this), o.forEach(this.definition, function(e2) {
              e2.accept(t3);
            });
          }, t2;
        }();
        e.AbstractProduction = u;
        var s = function(t2) {
          function e2(e3) {
            var n2 = t2.call(this, []) || this;
            return n2.idx = 1, o.assign(n2, o.pick(e3, function(t3) {
              return void 0 !== t3;
            })), n2;
          }
          return i(e2, t2), Object.defineProperty(e2.prototype, "definition", { get: function() {
            return void 0 !== this.referencedRule ? this.referencedRule.definition : [];
          }, set: function(t3) {
          }, enumerable: true, configurable: true }), e2.prototype.accept = function(t3) {
            t3.visit(this);
          }, e2;
        }(u);
        e.NonTerminal = s;
        var c = function(t2) {
          function e2(e3) {
            var n2 = t2.call(this, e3.definition) || this;
            return n2.orgText = "", o.assign(n2, o.pick(e3, function(t3) {
              return void 0 !== t3;
            })), n2;
          }
          return i(e2, t2), e2;
        }(u);
        e.Rule = c;
        var l = function(t2) {
          function e2(e3) {
            var n2 = t2.call(this, e3.definition) || this;
            return o.assign(n2, o.pick(e3, function(t3) {
              return void 0 !== t3;
            })), n2;
          }
          return i(e2, t2), e2;
        }(u);
        e.Flat = l;
        var E = function(t2) {
          function e2(e3) {
            var n2 = t2.call(this, e3.definition) || this;
            return n2.idx = 1, o.assign(n2, o.pick(e3, function(t3) {
              return void 0 !== t3;
            })), n2;
          }
          return i(e2, t2), e2;
        }(u);
        e.Option = E;
        var p = function(t2) {
          function e2(e3) {
            var n2 = t2.call(this, e3.definition) || this;
            return n2.idx = 1, o.assign(n2, o.pick(e3, function(t3) {
              return void 0 !== t3;
            })), n2;
          }
          return i(e2, t2), e2;
        }(u);
        e.RepetitionMandatory = p;
        var f = function(t2) {
          function e2(e3) {
            var n2 = t2.call(this, e3.definition) || this;
            return n2.idx = 1, o.assign(n2, o.pick(e3, function(t3) {
              return void 0 !== t3;
            })), n2;
          }
          return i(e2, t2), e2;
        }(u);
        e.RepetitionMandatoryWithSeparator = f;
        var L = function(t2) {
          function e2(e3) {
            var n2 = t2.call(this, e3.definition) || this;
            return n2.idx = 1, o.assign(n2, o.pick(e3, function(t3) {
              return void 0 !== t3;
            })), n2;
          }
          return i(e2, t2), e2;
        }(u);
        e.Repetition = L;
        var S = function(t2) {
          function e2(e3) {
            var n2 = t2.call(this, e3.definition) || this;
            return n2.idx = 1, o.assign(n2, o.pick(e3, function(t3) {
              return void 0 !== t3;
            })), n2;
          }
          return i(e2, t2), e2;
        }(u);
        e.RepetitionWithSeparator = S;
        var h = function(t2) {
          function e2(e3) {
            var n2 = t2.call(this, e3.definition) || this;
            return n2.idx = 1, o.assign(n2, o.pick(e3, function(t3) {
              return void 0 !== t3;
            })), n2;
          }
          return i(e2, t2), e2;
        }(u);
        e.Alternation = h;
        var T = function() {
          function t2(t3) {
            this.idx = 1, o.assign(this, o.pick(t3, function(t4) {
              return void 0 !== t4;
            }));
          }
          return t2.prototype.accept = function(t3) {
            t3.visit(this);
          }, t2;
        }();
        function U(t2) {
          function e2(t3) {
            return o.map(t3, U);
          }
          if (t2 instanceof s)
            return { type: "NonTerminal", name: t2.nonTerminalName, idx: t2.idx };
          if (t2 instanceof l)
            return { type: "Flat", definition: e2(t2.definition) };
          if (t2 instanceof E)
            return { type: "Option", idx: t2.idx, definition: e2(t2.definition) };
          if (t2 instanceof p)
            return { type: "RepetitionMandatory", name: t2.name, idx: t2.idx, definition: e2(t2.definition) };
          if (t2 instanceof f)
            return { type: "RepetitionMandatoryWithSeparator", name: t2.name, idx: t2.idx, separator: U(new T({ terminalType: t2.separator })), definition: e2(t2.definition) };
          if (t2 instanceof S)
            return { type: "RepetitionWithSeparator", name: t2.name, idx: t2.idx, separator: U(new T({ terminalType: t2.separator })), definition: e2(t2.definition) };
          if (t2 instanceof L)
            return { type: "Repetition", name: t2.name, idx: t2.idx, definition: e2(t2.definition) };
          if (t2 instanceof h)
            return { type: "Alternation", name: t2.name, idx: t2.idx, definition: e2(t2.definition) };
          if (t2 instanceof T) {
            var n2 = { type: "Terminal", name: a.tokenName(t2.terminalType), label: a.tokenLabel(t2.terminalType), idx: t2.idx }, r2 = t2.terminalType.PATTERN;
            return t2.terminalType.PATTERN && (n2.pattern = o.isRegExp(r2) ? r2.source : r2), n2;
          }
          if (t2 instanceof c)
            return { type: "Rule", name: t2.name, orgText: t2.orgText, definition: e2(t2.definition) };
          throw Error("non exhaustive match");
        }
        e.Terminal = T, e.serializeGrammar = function(t2) {
          return o.map(t2, U);
        }, e.serializeProduction = U;
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(4), i = n(10), o = n(23), a = n(14);
        function u(t2) {
          return r.isString(t2.LABEL) && "" !== t2.LABEL;
        }
        function s(t2) {
          return r.isObject(t2) && t2.hasOwnProperty("tokenName") && r.isString(t2.tokenName) ? t2.tokenName : i.functionName(t2);
        }
        e.tokenLabel = function(t2) {
          return u(t2) ? t2.LABEL : s(t2);
        }, e.hasTokenLabel = u, e.tokenName = s;
        var c = "parent", l = "categories", E = "label", p = "group", f = "push_mode", L = "pop_mode", S = "longer_alt", h = "line_breaks", T = "start_chars_hint";
        function U(t2) {
          return function(t3) {
            var e2 = t3.name, n2 = t3.pattern, o2 = {};
            i.defineNameProp(o2, e2) || (o2.tokenName = e2);
            r.isUndefined(n2) || (o2.PATTERN = n2);
            if (r.has(t3, c))
              throw "The parent property is no longer supported.\nSee: https://github.com/SAP/chevrotain/issues/564#issuecomment-349062346 for details.";
            r.has(t3, l) && (o2.CATEGORIES = t3[l]);
            a.augmentTokenTypes([o2]), r.has(t3, E) && (o2.LABEL = t3[E]);
            r.has(t3, p) && (o2.GROUP = t3[p]);
            r.has(t3, L) && (o2.POP_MODE = t3[L]);
            r.has(t3, f) && (o2.PUSH_MODE = t3[f]);
            r.has(t3, S) && (o2.LONGER_ALT = t3[S]);
            r.has(t3, h) && (o2.LINE_BREAKS = t3[h]);
            r.has(t3, T) && (o2.START_CHARS_HINT = t3[T]);
            return o2;
          }(t2);
        }
        e.createToken = U, e.EOF = U({ name: "EOF", pattern: o.Lexer.NA }), a.augmentTokenTypes([e.EOF]), e.createTokenInstance = function(t2, e2, n2, r2, i2, o2, a2, u2) {
          return { image: e2, startOffset: n2, endOffset: r2, startLine: i2, endLine: o2, startColumn: a2, endColumn: u2, tokenTypeIdx: t2.tokenTypeIdx, tokenType: t2 };
        }, e.tokenMatcher = function(t2, e2) {
          return a.tokenStructuredMatcher(t2, e2);
        };
      }, function(t, e, n) {
        "use strict";
        var r, i = this && this.__extends || (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        });
        Object.defineProperty(e, "__esModule", { value: true });
        var o = n(10), a = n(4), u = n(37), s = n(7), c = n(32), l = n(24), E = n(17), p = n(33), f = n(34), L = n(42), S = n(43), h = n(45), T = n(46), U = n(47), R = n(48), d = n(49);
        e.END_OF_FILE = s.createTokenInstance(s.EOF, "", NaN, NaN, NaN, NaN, NaN, NaN), Object.freeze(e.END_OF_FILE), e.DEFAULT_PARSER_CONFIG = Object.freeze({ recoveryEnabled: false, maxLookahead: 4, ignoredIssues: {}, dynamicTokensEnabled: false, outputCst: true, errorMessageProvider: E.defaultParserErrorProvider, serializedGrammar: null, nodeLocationTracking: "none" }), e.DEFAULT_RULE_CONFIG = Object.freeze({ recoveryValueFunc: function() {
        }, resyncEnabled: true }), function(t2) {
          t2[t2.INVALID_RULE_NAME = 0] = "INVALID_RULE_NAME", t2[t2.DUPLICATE_RULE_NAME = 1] = "DUPLICATE_RULE_NAME", t2[t2.INVALID_RULE_OVERRIDE = 2] = "INVALID_RULE_OVERRIDE", t2[t2.DUPLICATE_PRODUCTIONS = 3] = "DUPLICATE_PRODUCTIONS", t2[t2.UNRESOLVED_SUBRULE_REF = 4] = "UNRESOLVED_SUBRULE_REF", t2[t2.LEFT_RECURSION = 5] = "LEFT_RECURSION", t2[t2.NONE_LAST_EMPTY_ALT = 6] = "NONE_LAST_EMPTY_ALT", t2[t2.AMBIGUOUS_ALTS = 7] = "AMBIGUOUS_ALTS", t2[t2.CONFLICT_TOKENS_RULES_NAMESPACE = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE", t2[t2.INVALID_TOKEN_NAME = 9] = "INVALID_TOKEN_NAME", t2[t2.INVALID_NESTED_RULE_NAME = 10] = "INVALID_NESTED_RULE_NAME", t2[t2.DUPLICATE_NESTED_NAME = 11] = "DUPLICATE_NESTED_NAME", t2[t2.NO_NON_EMPTY_LOOKAHEAD = 12] = "NO_NON_EMPTY_LOOKAHEAD", t2[t2.AMBIGUOUS_PREFIX_ALTS = 13] = "AMBIGUOUS_PREFIX_ALTS", t2[t2.TOO_MANY_ALTS = 14] = "TOO_MANY_ALTS";
        }(e.ParserDefinitionErrorType || (e.ParserDefinitionErrorType = {})), e.EMPTY_ALT = function(t2) {
          return void 0 === t2 && (t2 = void 0), function() {
            return t2;
          };
        };
        var Parser = function() {
          function Parser2(t2, n2) {
            void 0 === n2 && (n2 = e.DEFAULT_PARSER_CONFIG), this.ignoredIssues = e.DEFAULT_PARSER_CONFIG.ignoredIssues, this.definitionErrors = [], this.selfAnalysisDone = false;
            this.initErrorHandler(n2), this.initLexerAdapter(), this.initLooksAhead(n2), this.initRecognizerEngine(t2, n2), this.initRecoverable(n2), this.initTreeBuilder(n2), this.initContentAssist(), this.ignoredIssues = a.has(n2, "ignoredIssues") ? n2.ignoredIssues : e.DEFAULT_PARSER_CONFIG.ignoredIssues, a.toFastProperties(this);
          }
          return Parser2.performSelfAnalysis = function(t2) {
            t2.performSelfAnalysis();
          }, Parser2.prototype.performSelfAnalysis = function() {
            var t2, e2 = this;
            this.selfAnalysisDone = true;
            var n2 = o.classNameFromInstance(this), r2 = this.gastProductionsCache;
            if (this.serializedGrammar) {
              var i2 = c.deserializeGrammar(this.serializedGrammar, this.tokensMap);
              a.forEach(i2, function(t3) {
                e2.gastProductionsCache.put(t3.name, t3);
              });
            }
            var s2 = p.resolveGrammar({ rules: r2.values() });
            if (this.definitionErrors.push.apply(this.definitionErrors, s2), a.isEmpty(s2)) {
              var f2 = p.validateGrammar({ rules: r2.values(), maxLookahead: this.maxLookahead, tokenTypes: a.values(this.tokensMap), ignoredIssues: this.ignoredIssues, errMsgProvider: E.defaultGrammarValidatorErrorProvider, grammarName: n2 });
              this.definitionErrors.push.apply(this.definitionErrors, f2);
            }
            if (a.isEmpty(this.definitionErrors)) {
              var L2 = u.computeAllProdsFollows(r2.values());
              this.resyncFollows = L2;
            }
            var S2 = l.analyzeCst(r2.values(), this.fullRuleNameToShort);
            if (this.allRuleNames = S2.allRuleNames, !Parser2.DEFER_DEFINITION_ERRORS_HANDLING && !a.isEmpty(this.definitionErrors))
              throw t2 = a.map(this.definitionErrors, function(t3) {
                return t3.message;
              }), new Error("Parser Definition Errors detected:\n " + t2.join("\n-------------------------------\n"));
          }, Parser2.DEFER_DEFINITION_ERRORS_HANDLING = false, Parser2;
        }();
        e.Parser = Parser, a.applyMixins(Parser, [f.Recoverable, L.LooksAhead, S.TreeBuilder, h.LexerAdapter, U.RecognizerEngine, T.RecognizerApi, R.ErrorHandler, d.ContentAssist]);
        var O = function(t2) {
          function n2(n3, r2) {
            void 0 === r2 && (r2 = e.DEFAULT_PARSER_CONFIG);
            var i2 = a.cloneObj(r2);
            return i2.outputCst = true, t2.call(this, n3, i2) || this;
          }
          return i(n2, t2), n2;
        }(Parser);
        e.CstParser = O;
        var N = function(t2) {
          function n2(n3, r2) {
            void 0 === r2 && (r2 = e.DEFAULT_PARSER_CONFIG);
            var i2 = a.cloneObj(r2);
            return i2.outputCst = false, t2.call(this, n3, i2) || this;
          }
          return i(n2, t2), n2;
        }(Parser);
        e.EmbeddedActionsParser = N;
      }, function(t, e, n) {
        "use strict";
        n.r(e), n.d(e, "sparqlTokenMap", function() {
          return a;
        }), n.d(e, "baseTokens", function() {
          return u;
        }), n.d(e, "pathsTokens", function() {
          return s;
        }), n.d(e, "nonStandardTokens", function() {
          return c;
        }), n.d(e, "stardogSparqlTokens", function() {
          return E;
        }), n.d(e, "sparqlTokenTypes", function() {
          return p;
        });
        var r = n(1), i = n(5), o = n(0), a = { IRIREF: i.terminals.IRIREF, LANGTAG: i.terminals.LANGTAG, INTEGER: i.terminals.INTEGER, DECIMAL: i.terminals.DECIMAL, DOUBLE: i.terminals.DOUBLE, INTEGER_POSITIVE: i.terminals.INTEGER_POSITIVE, DECIMAL_POSITIVE: i.terminals.DECIMAL_POSITIVE, DOUBLE_POSITIVE: i.terminals.DOUBLE_POSITIVE, INTEGER_NEGATIVE: i.terminals.INTEGER_NEGATIVE, DECIMAL_NEGATIVE: i.terminals.DECIMAL_NEGATIVE, DOUBLE_NEGATIVE: i.terminals.DOUBLE_NEGATIVE, STRING_LITERAL1: i.terminals.STRING_LITERAL1, STRING_LITERAL2: i.terminals.STRING_LITERAL2, STRING_LITERAL_LONG1: i.terminals.STRING_LITERAL_LONG1, STRING_LITERAL_LONG2: i.terminals.STRING_LITERAL_LONG2, NIL: i.terminals.NIL, ANON: i.terminals.ANON, PNAME_NS: i.terminals.PNAME_NS, PNAME_LN: i.terminals.PNAME_LN, BLANK_NODE_LABEL: i.terminals.BLANK_NODE_LABEL, VAR1: i.terminals.VAR1, VAR2: i.terminals.VAR2, PERCENT: i.terminals.PERCENT, Comment: Object(r.createToken)({ name: "Comment", pattern: /#[^\n]*/, group: "comments" }), LCurly: Object(r.createToken)({ name: "LCurly", pattern: "{" }), RCurly: Object(r.createToken)({ name: "RCurly", pattern: "}" }), LParen: Object(r.createToken)({ name: "LParen", pattern: "(" }), RParen: Object(r.createToken)({ name: "RParen", pattern: ")" }), WhiteSpace: Object(r.createToken)({ name: "WhiteSpace", pattern: /\s+/, group: r.Lexer.SKIPPED, line_breaks: true }), Star: Object(r.createToken)({ name: "Star", pattern: "*" }), UNKNOWN: o.keywords.UNKNOWN, Period: Object(r.createToken)({ name: "Period", pattern: "." }), QuestionMark: Object(r.createToken)({ name: "QuestionMark", pattern: "?" }), Plus: Object(r.createToken)({ name: "Plus", pattern: "+" }), Minus: Object(r.createToken)({ name: "Minus", pattern: "-" }), LBracket: Object(r.createToken)({ name: "LBracket", pattern: "[" }), RBracket: Object(r.createToken)({ name: "RBracket", pattern: "]" }), Semicolon: Object(r.createToken)({ name: "Semicolon", pattern: ";" }), Comma: Object(r.createToken)({ name: "Comma", pattern: "," }), Pipe: Object(r.createToken)({ name: "Pipe", pattern: "|" }), ForwardSlash: Object(r.createToken)({ name: "ForwardSlash", pattern: "/" }), Caret: Object(r.createToken)({ name: "Caret", pattern: "^" }), DoubleCaret: Object(r.createToken)({ name: "DoubleCaret", pattern: "^^" }), Bang: Object(r.createToken)({ name: "Bang", pattern: "!" }), LogicalOr: Object(r.createToken)({ name: "LogicalOr", pattern: "||" }), LogicalAnd: Object(r.createToken)({ name: "LogicalAnd", pattern: "&&" }), Equals: Object(r.createToken)({ name: "Equals", pattern: "=" }), NotEquals: Object(r.createToken)({ name: "NotEquals", pattern: "!=" }), LessThan: Object(r.createToken)({ name: "LessThan", pattern: "<" }), GreaterThan: Object(r.createToken)({ name: "GreaterThan", pattern: ">" }), LessThanEquals: Object(r.createToken)({ name: "LessThanEquals", pattern: "<=" }), GreaterThanEquals: Object(r.createToken)({ name: "GreaterThanEquals", pattern: ">=" }), LEmbed: Object(r.createToken)({ name: "LEmbed", pattern: "<<" }), REmbed: Object(r.createToken)({ name: "REmbed", pattern: ">>" }), SELECT: o.keywords.SELECT, CONSTRUCT: o.keywords.CONSTRUCT, DISTINCT: o.keywords.DISTINCT, START: o.keywords.START, END: o.keywords.END, VIA: o.keywords.VIA, CYCLIC: o.keywords.CYCLIC, PATHS_SHORTEST: o.keywords.PATHS_SHORTEST, PATHS_ALL: o.keywords.PATHS_ALL, PATHS: o.keywords.PATHS, AS: o.keywords.AS, WHERE: o.keywords.WHERE, A: o.keywords.A, GROUP_BY: o.keywords.GROUP_BY, ORDER_BY: o.keywords.ORDER_BY, BY: o.keywords.BY, BASE: o.keywords.BASE, PREFIX: o.keywords.PREFIX, DESCRIBE: o.keywords.DESCRIBE, ASK: o.keywords.ASK, FROM: o.keywords.FROM, REDUCED: o.keywords.REDUCED, NAMED: o.keywords.NAMED, HAVING: o.keywords.HAVING, ASC: o.keywords.ASC, DESC: o.keywords.DESC, OFFSET: o.keywords.OFFSET, LIMIT: o.keywords.LIMIT, VALUES: o.keywords.VALUES, LOAD: o.keywords.LOAD, SILENT: o.keywords.SILENT, INTO: o.keywords.INTO, CLEAR: o.keywords.CLEAR, DROP: o.keywords.DROP, CREATE: o.keywords.CREATE, ADD: o.keywords.ADD, TO: o.keywords.TO, MOVE: o.keywords.MOVE, COPY: o.keywords.COPY, INSERT_DATA: o.keywords.INSERT_DATA, DELETE_DATA: o.keywords.DELETE_DATA, DELETE_WHERE: o.keywords.DELETE_WHERE, WITH: o.keywords.WITH, DELETE: o.keywords.DELETE, INSERT: o.keywords.INSERT, USING: o.keywords.USING, DEFAULT: o.keywords.DEFAULT, GRAPH: o.keywords.GRAPH, ALL: o.keywords.ALL, OPTIONAL: o.keywords.OPTIONAL, SERVICE: o.keywords.SERVICE, BIND: o.keywords.BIND, UNNEST: o.keywords.UNNEST, UNDEF: o.keywords.UNDEF, MINUS: o.keywords.MINUS, UNION: o.keywords.UNION, FILTER: o.keywords.FILTER, STR: o.keywords.STR, LANG: o.keywords.LANG, LANGMATCHES: o.keywords.LANGMATCHES, DATATYPE: o.keywords.DATATYPE, BOUND: o.keywords.BOUND, IRI: o.keywords.IRI, URI: o.keywords.URI, BNODE: o.keywords.BNODE, RAND: o.keywords.RAND, ABS: o.keywords.ABS, CEIL: o.keywords.CEIL, FLOOR: o.keywords.FLOOR, ROUND: o.keywords.ROUND, CONCAT: o.keywords.CONCAT, STRLEN: o.keywords.STRLEN, UCASE: o.keywords.UCASE, LCASE: o.keywords.LCASE, ENCODE_FOR_URI: o.keywords.ENCODE_FOR_URI, CONTAINS: o.keywords.CONTAINS, STRSTARTS: o.keywords.STRSTARTS, STRENDS: o.keywords.STRENDS, STRBEFORE: o.keywords.STRBEFORE, STRAFTER: o.keywords.STRAFTER, YEAR: o.keywords.YEAR, MONTH: o.keywords.MONTH, DAY: o.keywords.DAY, HOURS: o.keywords.HOURS, MINUTES: o.keywords.MINUTES, SECONDS: o.keywords.SECONDS, TIMEZONE: o.keywords.TIMEZONE, TZ: o.keywords.TZ, NOW: o.keywords.NOW, UUID: o.keywords.UUID, STRUUID: o.keywords.STRUUID, MD5: o.keywords.MD5, SHA1: o.keywords.SHA1, SHA256: o.keywords.SHA256, SHA384: o.keywords.SHA384, SHA512: o.keywords.SHA512, COALESCE: o.keywords.COALESCE, IF: o.keywords.IF, STRLANG: o.keywords.STRLANG, STRDT: o.keywords.STRDT, sameTerm: o.keywords.sameTerm, isIRI: o.keywords.isIRI, isURI: o.keywords.isURI, isBLANK: o.keywords.isBLANK, isLITERAL: o.keywords.isLITERAL, isNUMERIC: o.keywords.isNUMERIC, REGEX: o.keywords.REGEX, SUBSTR: o.keywords.SUBSTR, REPLACE: o.keywords.REPLACE, EXISTS: o.keywords.EXISTS, NOT_EXISTS: o.keywords.NOT_EXISTS, COUNT: o.keywords.COUNT, SUM: o.keywords.SUM, MIN: o.keywords.MIN, AVG: o.keywords.AVG, SAMPLE: o.keywords.SAMPLE, GROUP_CONCAT: o.keywords.GROUP_CONCAT, SEPARATOR: o.keywords.SEPARATOR, TRUE: o.keywords.TRUE, FALSE: o.keywords.FALSE, IN: o.keywords.IN, NOT_IN: o.keywords.NOT_IN, MAX_LENGTH: o.keywords.MAX_LENGTH, MAX: o.keywords.MAX, VALIDATE: o.keywords.VALIDATE, SHAPES: o.keywords.SHAPES, SHAPE: o.keywords.SHAPE, PER: o.keywords.PER }, u = [a.NIL, a.ANON, a.LCurly, a.RCurly, a.LParen, a.RParen, a.WhiteSpace, a.IRIREF, a.LANGTAG, a.DOUBLE, a.DECIMAL, a.INTEGER, a.DOUBLE_POSITIVE, a.DECIMAL_POSITIVE, a.INTEGER_POSITIVE, a.DOUBLE_NEGATIVE, a.DECIMAL_NEGATIVE, a.INTEGER_NEGATIVE, a.STRING_LITERAL1, a.STRING_LITERAL2, a.STRING_LITERAL_LONG1, a.STRING_LITERAL_LONG2, a.PNAME_NS, a.PNAME_LN, a.BLANK_NODE_LABEL, a.VAR1, a.VAR2, a.Comment, a.SELECT, a.CONSTRUCT, a.DISTINCT, a.Star, a.WHERE, a.GROUP_BY, a.ORDER_BY, a.BY, a.Period, a.QuestionMark, a.Plus, a.Minus, a.LBracket, a.RBracket, a.PERCENT, a.BASE, a.PREFIX, a.DESCRIBE, a.ASK, a.FROM, a.REDUCED, a.NAMED, a.HAVING, a.ASC, a.DESC, a.OFFSET, a.LIMIT, a.VALUES, a.LOAD, a.SILENT, a.INTO, a.AS, a.CLEAR, a.DROP, a.CREATE, a.ADD, a.TO, a.MOVE, a.COPY, a.INSERT_DATA, a.DELETE_DATA, a.DELETE_WHERE, a.WITH, a.DELETE, a.INSERT, a.USING, a.DEFAULT, a.GRAPH, a.ALL, a.OPTIONAL, a.SERVICE, a.BIND, a.UNDEF, a.MINUS, a.UNION, a.FILTER, a.LANGMATCHES, a.LANG, a.DATATYPE, a.BOUND, a.IRI, a.URI, a.BNODE, a.RAND, a.ABS, a.CEIL, a.FLOOR, a.ROUND, a.CONCAT, a.STRLEN, a.UCASE, a.LCASE, a.ENCODE_FOR_URI, a.CONTAINS, a.STRSTARTS, a.STRENDS, a.STRBEFORE, a.STRAFTER, a.YEAR, a.MONTH, a.DAY, a.HOURS, a.MINUTES, a.SECONDS, a.TIMEZONE, a.TZ, a.NOW, a.UUID, a.STRUUID, a.MD5, a.SHA1, a.SHA256, a.SHA384, a.SHA512, a.COALESCE, a.IF, a.STRLANG, a.STRDT, a.STR, a.sameTerm, a.isIRI, a.isURI, a.isBLANK, a.isLITERAL, a.isNUMERIC, a.REGEX, a.SUBSTR, a.REPLACE, a.EXISTS, a.NOT_EXISTS, a.COUNT, a.SUM, a.MIN, a.MAX_LENGTH, a.MAX, a.AVG, a.SAMPLE, a.GROUP_CONCAT, a.SEPARATOR, a.TRUE, a.FALSE, a.Semicolon, a.Comma, a.ForwardSlash, a.DoubleCaret, a.Caret, a.LogicalOr, a.Pipe, a.LogicalAnd, a.NotEquals, a.Bang, a.Equals, a.LessThanEquals, a.GreaterThanEquals, a.LEmbed, a.REmbed, a.LessThan, a.GreaterThan, a.IN, a.NOT_IN, a.A, a.UNKNOWN], s = [a.START, a.END, a.VIA, a.CYCLIC, a.PATHS_SHORTEST, a.PATHS_ALL, a.PATHS], c = s.concat([a.UNNEST, a.VALIDATE, a.SHAPES, a.SHAPE, a.PER]), l = u.indexOf(a.SELECT), E = u.slice(0, l).concat(c, u.slice(l)), p = u.concat(c);
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(4);
        e.classNameFromInstance = function(t2) {
          return a(t2.constructor);
        };
        var i = /^\s*function\s*(\S*)\s*\(/, o = "name";
        function a(t2) {
          var e2 = t2.name;
          return e2 || t2.toString().match(i)[1];
        }
        e.functionName = a, e.defineNameProp = function(t2, e2) {
          var n2 = Object.getOwnPropertyDescriptor(t2, o);
          return !(!r.isUndefined(n2) && !n2.configurable || (Object.defineProperty(t2, o, { enumerable: false, configurable: true, writable: false, value: e2 }), 0));
        };
        var u = function() {
          function t2() {
            this._state = {};
          }
          return t2.prototype.keys = function() {
            return r.keys(this._state);
          }, t2.prototype.values = function() {
            return r.values(this._state);
          }, t2.prototype.put = function(t3, e2) {
            this._state[t3] = e2;
          }, t2.prototype.putAll = function(t3) {
            this._state = r.assign(this._state, t3._state);
          }, t2.prototype.get = function(t3) {
            return this._state[t3];
          }, t2.prototype.containsKey = function(t3) {
            return r.has(this._state, t3);
          }, t2.prototype.clear = function() {
            this._state = {};
          }, t2;
        }();
        e.HashTable = u;
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(6), i = function() {
          function t2() {
          }
          return t2.prototype.visit = function(t3) {
            if (t3 instanceof r.NonTerminal)
              return this.visitNonTerminal(t3);
            if (t3 instanceof r.Flat)
              return this.visitFlat(t3);
            if (t3 instanceof r.Option)
              return this.visitOption(t3);
            if (t3 instanceof r.RepetitionMandatory)
              return this.visitRepetitionMandatory(t3);
            if (t3 instanceof r.RepetitionMandatoryWithSeparator)
              return this.visitRepetitionMandatoryWithSeparator(t3);
            if (t3 instanceof r.RepetitionWithSeparator)
              return this.visitRepetitionWithSeparator(t3);
            if (t3 instanceof r.Repetition)
              return this.visitRepetition(t3);
            if (t3 instanceof r.Alternation)
              return this.visitAlternation(t3);
            if (t3 instanceof r.Terminal)
              return this.visitTerminal(t3);
            if (t3 instanceof r.Rule)
              return this.visitRule(t3);
            throw Error("non exhaustive match");
          }, t2.prototype.visitNonTerminal = function(t3) {
          }, t2.prototype.visitFlat = function(t3) {
          }, t2.prototype.visitOption = function(t3) {
          }, t2.prototype.visitRepetition = function(t3) {
          }, t2.prototype.visitRepetitionMandatory = function(t3) {
          }, t2.prototype.visitRepetitionMandatoryWithSeparator = function(t3) {
          }, t2.prototype.visitRepetitionWithSeparator = function(t3) {
          }, t2.prototype.visitAlternation = function(t3) {
          }, t2.prototype.visitTerminal = function(t3) {
          }, t2.prototype.visitRule = function(t3) {
          }, t2;
        }();
        e.GAstVisitor = i;
      }, function(t, e, n) {
        "use strict";
        n.d(e, "d", function() {
          return i;
        }), n.d(e, "e", function() {
          return o;
        }), n.d(e, "b", function() {
          return a;
        }), n.d(e, "c", function() {
          return u;
        }), n.d(e, "a", function() {
          return s;
        });
        var r = function() {
          return (r = Object.assign || function(t2) {
            for (var e2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
              for (var i2 in e2 = arguments[n2])
                Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
            return t2;
          }).apply(this, arguments);
        }, i = function(t2, e2) {
          l(t2, null, e2);
        }, o = function(t2, e2) {
          l(t2, null, e2, false);
        };
        function a(t2) {
          return Boolean(t2 && "name" in t2);
        }
        function u(t2) {
          return Boolean(t2 && "tokenType" in t2);
        }
        function s(t2, e2) {
          if (!t2 || !t2.length)
            return e2;
          for (var n2 = e2, r2 = 0, i2 = t2; r2 < i2.length; r2++) {
            var o2 = i2[r2];
            if (!a(n2) || !n2.children[o2])
              return;
            n2 = n2.children[o2][0];
          }
          return n2;
        }
        var c = function() {
          return function(t2) {
            var e2 = t2.node, n2 = t2.parentCtx;
            this.node = r({}, e2), this.parentCtx = r({}, n2);
          };
        }(), l = function(t2, e2, n2, i2) {
          if (void 0 === e2 && (e2 = new c({ node: t2 })), void 0 === i2 && (i2 = true), !a(t2))
            return n2(i2 ? r({}, e2) : e2);
          var o2 = t2.children;
          Object.keys(o2).forEach(function(t3) {
            var r2 = o2[t3];
            r2.length && r2.forEach(function(t4) {
              var r3 = i2 ? new c({ node: t4, parentCtx: e2 }) : { node: t4, parentCtx: e2 };
              n2(r3, function(e3) {
                var o3 = r3;
                e3 && (o3 = i2 ? new c({ node: e3.node, parentCtx: e3.parentCtx }) : { node: e3.node, parentCtx: e3.parentCtx }), l(t4, o3, n2, i2);
              });
            });
          });
        };
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(4), i = "MismatchedTokenException", o = "NoViableAltException", a = "EarlyExitException", u = "NotAllInputParsedException", s = [i, o, a, u];
        function c(t2, e2, n2) {
          this.name = i, this.message = t2, this.token = e2, this.previousToken = n2, this.resyncedTokens = [];
        }
        function l(t2, e2, n2) {
          this.name = o, this.message = t2, this.token = e2, this.previousToken = n2, this.resyncedTokens = [];
        }
        function E(t2, e2) {
          this.name = u, this.message = t2, this.token = e2, this.resyncedTokens = [];
        }
        function p(t2, e2, n2) {
          this.name = a, this.message = t2, this.token = e2, this.previousToken = n2, this.resyncedTokens = [];
        }
        Object.freeze(s), e.isRecognitionException = function(t2) {
          return r.contains(s, t2.name);
        }, e.MismatchedTokenException = c, c.prototype = Error.prototype, e.NoViableAltException = l, l.prototype = Error.prototype, e.NotAllInputParsedException = E, E.prototype = Error.prototype, e.EarlyExitException = p, p.prototype = Error.prototype;
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(4), i = n(10), o = n(7);
        function a(t2) {
          for (var e2 = r.cloneArr(t2), n2 = t2, i2 = true; i2; ) {
            n2 = r.compact(r.flatten(r.map(n2, function(t3) {
              return t3.CATEGORIES;
            })));
            var o2 = r.difference(n2, e2);
            e2 = e2.concat(o2), r.isEmpty(o2) ? i2 = false : n2 = o2;
          }
          return e2;
        }
        function u(t2) {
          r.forEach(t2, function(t3) {
            E(t3) || (e.tokenIdxToClass.put(e.tokenShortNameIdx, t3), t3.tokenTypeIdx = e.tokenShortNameIdx++), p(t3) && !r.isArray(t3.CATEGORIES) && (t3.CATEGORIES = [t3.CATEGORIES]), p(t3) || (t3.CATEGORIES = []), f(t3) || (t3.categoryMatches = []), L(t3) || (t3.categoryMatchesMap = {}), S(t3) || (t3.tokenName = o.tokenName(t3));
          });
        }
        function s(t2) {
          r.forEach(t2, function(t3) {
            t3.categoryMatches = [], r.forEach(t3.categoryMatchesMap, function(n2, r2) {
              t3.categoryMatches.push(e.tokenIdxToClass.get(r2).tokenTypeIdx);
            });
          });
        }
        function c(t2) {
          r.forEach(t2, function(t3) {
            l([], t3);
          });
        }
        function l(t2, e2) {
          r.forEach(t2, function(t3) {
            e2.categoryMatchesMap[t3.tokenTypeIdx] = true;
          }), r.forEach(e2.CATEGORIES, function(n2) {
            var i2 = t2.concat(e2);
            r.contains(i2, n2) || l(i2, n2);
          });
        }
        function E(t2) {
          return r.has(t2, "tokenTypeIdx");
        }
        function p(t2) {
          return r.has(t2, "CATEGORIES");
        }
        function f(t2) {
          return r.has(t2, "categoryMatches");
        }
        function L(t2) {
          return r.has(t2, "categoryMatchesMap");
        }
        function S(t2) {
          return r.has(t2, "tokenName");
        }
        e.tokenStructuredMatcher = function(t2, e2) {
          var n2 = t2.tokenTypeIdx;
          return n2 === e2.tokenTypeIdx || true === e2.isParent && true === e2.categoryMatchesMap[n2];
        }, e.tokenStructuredMatcherNoCategories = function(t2, e2) {
          return t2.tokenTypeIdx === e2.tokenTypeIdx;
        }, e.tokenShortNameIdx = 1, e.tokenIdxToClass = new i.HashTable(), e.augmentTokenTypes = function(t2) {
          var e2 = a(t2);
          u(e2), c(e2), s(e2), r.forEach(e2, function(t3) {
            t3.isParent = t3.categoryMatches.length > 0;
          });
        }, e.expandCategories = a, e.assignTokenDefaultProps = u, e.assignCategoriesTokensProp = s, e.assignCategoriesMapProp = c, e.singleAssignCategoriesToksMap = l, e.hasShortKeyProperty = E, e.hasCategoriesProperty = p, e.hasExtendingTokensTypesProperty = f, e.hasExtendingTokensTypesMapProperty = L, e.hasTokenNameProperty = S, e.isTokenType = function(t2) {
          return r.has(t2, "tokenTypeIdx");
        };
      }, function(t, e, n) {
        "use strict";
        var r, i = this && this.__extends || (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        });
        Object.defineProperty(e, "__esModule", { value: true });
        var o = n(4), a = n(6), u = n(11), s = n(7);
        e.isSequenceProd = function(t2) {
          return t2 instanceof a.Flat || t2 instanceof a.Option || t2 instanceof a.Repetition || t2 instanceof a.RepetitionMandatory || t2 instanceof a.RepetitionMandatoryWithSeparator || t2 instanceof a.RepetitionWithSeparator || t2 instanceof a.Terminal || t2 instanceof a.Rule;
        }, e.isOptionalProd = function t2(e2, n2) {
          return void 0 === n2 && (n2 = []), !!(e2 instanceof a.Option || e2 instanceof a.Repetition || e2 instanceof a.RepetitionWithSeparator) || (e2 instanceof a.Alternation ? o.some(e2.definition, function(e3) {
            return t2(e3, n2);
          }) : !(e2 instanceof a.NonTerminal && o.contains(n2, e2)) && e2 instanceof a.AbstractProduction && (e2 instanceof a.NonTerminal && n2.push(e2), o.every(e2.definition, function(e3) {
            return t2(e3, n2);
          })));
        }, e.isBranchingProd = function(t2) {
          return t2 instanceof a.Alternation;
        }, e.getProductionDslName = function(t2) {
          if (t2 instanceof a.NonTerminal)
            return "SUBRULE";
          if (t2 instanceof a.Option)
            return "OPTION";
          if (t2 instanceof a.Alternation)
            return "OR";
          if (t2 instanceof a.RepetitionMandatory)
            return "AT_LEAST_ONE";
          if (t2 instanceof a.RepetitionMandatoryWithSeparator)
            return "AT_LEAST_ONE_SEP";
          if (t2 instanceof a.RepetitionWithSeparator)
            return "MANY_SEP";
          if (t2 instanceof a.Repetition)
            return "MANY";
          if (t2 instanceof a.Terminal)
            return "CONSUME";
          throw Error("non exhaustive match");
        };
        var c = function(t2) {
          function e2() {
            var e3 = null !== t2 && t2.apply(this, arguments) || this;
            return e3.separator = "-", e3.dslMethods = { option: [], alternation: [], repetition: [], repetitionWithSeparator: [], repetitionMandatory: [], repetitionMandatoryWithSeparator: [] }, e3;
          }
          return i(e2, t2), e2.prototype.visitTerminal = function(t3) {
            var e3 = s.tokenName(t3.terminalType) + this.separator + "Terminal";
            o.has(this.dslMethods, e3) || (this.dslMethods[e3] = []), this.dslMethods[e3].push(t3);
          }, e2.prototype.visitNonTerminal = function(t3) {
            var e3 = t3.nonTerminalName + this.separator + "Terminal";
            o.has(this.dslMethods, e3) || (this.dslMethods[e3] = []), this.dslMethods[e3].push(t3);
          }, e2.prototype.visitOption = function(t3) {
            this.dslMethods.option.push(t3);
          }, e2.prototype.visitRepetitionWithSeparator = function(t3) {
            this.dslMethods.repetitionWithSeparator.push(t3);
          }, e2.prototype.visitRepetitionMandatory = function(t3) {
            this.dslMethods.repetitionMandatory.push(t3);
          }, e2.prototype.visitRepetitionMandatoryWithSeparator = function(t3) {
            this.dslMethods.repetitionMandatoryWithSeparator.push(t3);
          }, e2.prototype.visitRepetition = function(t3) {
            this.dslMethods.repetition.push(t3);
          }, e2.prototype.visitAlternation = function(t3) {
            this.dslMethods.alternation.push(t3);
          }, e2;
        }(u.GAstVisitor);
        e.DslMethodsCollectorVisitor = c;
      }, function(t, e, n) {
        "use strict";
        function r(t2, e2, n2) {
          return n2 | e2 | t2;
        }
        Object.defineProperty(e, "__esModule", { value: true }), e.BITS_FOR_METHOD_IDX = 4, e.BITS_FOR_OCCURRENCE_IDX = 4, e.BITS_FOR_RULE_IDX = 24, e.BITS_FOR_ALT_IDX = 8, e.OR_IDX = 1 << e.BITS_FOR_METHOD_IDX, e.OPTION_IDX = 2 << e.BITS_FOR_METHOD_IDX, e.MANY_IDX = 3 << e.BITS_FOR_METHOD_IDX, e.AT_LEAST_ONE_IDX = 4 << e.BITS_FOR_METHOD_IDX, e.MANY_SEP_IDX = 5 << e.BITS_FOR_METHOD_IDX, e.AT_LEAST_ONE_SEP_IDX = 6 << e.BITS_FOR_METHOD_IDX, e.getKeyForAutomaticLookahead = r;
        var i = 32 - e.BITS_FOR_ALT_IDX;
        e.getKeyForAltIndex = function(t2, e2, n2, o) {
          var a = o + 1 << i;
          return r(t2, e2, n2) | a;
        };
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(7), i = n(4), o = n(4), a = n(6), u = n(15), s = n(18), c = n(25), l = n(8);
        e.defaultParserErrorProvider = { buildMismatchTokenMessage: function(t2) {
          var e2 = t2.expected, n2 = t2.actual;
          t2.previous, t2.ruleName;
          return "Expecting " + (r.hasTokenLabel(e2) ? "--> " + r.tokenLabel(e2) + " <--" : "token of type --> " + r.tokenName(e2) + " <--") + " but found --> '" + n2.image + "' <--";
        }, buildNotAllInputParsedMessage: function(t2) {
          var e2 = t2.firstRedundant;
          t2.ruleName;
          return "Redundant input, expecting EOF but found: " + e2.image;
        }, buildNoViableAltMessage: function(t2) {
          var e2 = t2.expectedPathsPerAlt, n2 = t2.actual, i2 = (t2.previous, t2.customUserDescription), a2 = (t2.ruleName, "\nbut found: '" + o.first(n2).image + "'");
          if (i2)
            return "Expecting: " + i2 + a2;
          var u2 = o.reduce(e2, function(t3, e3) {
            return t3.concat(e3);
          }, []), s2 = o.map(u2, function(t3) {
            return "[" + o.map(t3, function(t4) {
              return r.tokenLabel(t4);
            }).join(", ") + "]";
          });
          return "Expecting: " + ("one of these possible Token sequences:\n" + o.map(s2, function(t3, e3) {
            return "  " + (e3 + 1) + ". " + t3;
          }).join("\n")) + a2;
        }, buildEarlyExitMessage: function(t2) {
          var e2 = t2.expectedIterationPaths, n2 = t2.actual, i2 = t2.customUserDescription, a2 = (t2.ruleName, "\nbut found: '" + o.first(n2).image + "'");
          return i2 ? "Expecting: " + i2 + a2 : "Expecting: " + ("expecting at least one iteration which starts with one of these possible Token sequences::\n  <" + o.map(e2, function(t3) {
            return "[" + o.map(t3, function(t4) {
              return r.tokenLabel(t4);
            }).join(",") + "]";
          }).join(" ,") + ">") + a2;
        } }, Object.freeze(e.defaultParserErrorProvider), e.defaultGrammarResolverErrorProvider = { buildRuleNotFoundError: function(t2, e2) {
          return "Invalid grammar, reference to a rule which is not defined: ->" + e2.nonTerminalName + "<-\ninside top level rule: ->" + t2.name + "<-";
        } }, e.defaultGrammarValidatorErrorProvider = { buildDuplicateFoundError: function(t2, e2) {
          var n2, i2 = t2.name, s2 = o.first(e2), c2 = s2.idx, l2 = u.getProductionDslName(s2), E = (n2 = s2) instanceof a.Terminal ? r.tokenName(n2.terminalType) : n2 instanceof a.NonTerminal ? n2.nonTerminalName : "", p = "->" + l2 + "<- with numerical suffix: ->" + c2 + "<-\n                  " + (E ? "and argument: ->" + E + "<-" : "") + "\n                  appears more than once (" + e2.length + " times) in the top level rule: ->" + i2 + "<-.\n                  " + (0 === c2 ? "Also note that numerical suffix 0 means " + l2 + " without any suffix." : "") + "\n                  To fix this make sure each usage of " + l2 + " " + (E ? "with the argument: ->" + E + "<-" : "") + "\n                  in the rule ->" + i2 + "<- has a different occurrence index (0-5), as that combination acts as a unique\n                  position key in the grammar, which is needed by the parsing engine.\n                  \n                  For further details see: https://sap.github.io/chevrotain/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  ";
          return p = (p = p.replace(/[ \t]+/g, " ")).replace(/\s\s+/g, "\n");
        }, buildInvalidNestedRuleNameError: function(t2, e2) {
          return "Invalid nested rule name: ->" + e2.name + "<- inside rule: ->" + t2.name + "<-\nit must match the pattern: ->" + s.validNestedRuleName.toString() + "<-.\nNote that this means a nested rule name must start with the '$'(dollar) sign.";
        }, buildDuplicateNestedRuleNameError: function(t2, e2) {
          return "Duplicate nested rule name: ->" + o.first(e2).name + "<- inside rule: ->" + t2.name + "<-\nA nested name must be unique in the scope of a top level grammar rule.";
        }, buildNamespaceConflictError: function(t2) {
          return "Namespace conflict found in grammar.\nThe grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <" + t2.name + ">.\nTo resolve this make sure each Terminal and Non-Terminal names are unique\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\nand Non-Terminal names start with a lower case letter.";
        }, buildAlternationPrefixAmbiguityError: function(t2) {
          var e2 = o.map(t2.prefixPath, function(t3) {
            return r.tokenLabel(t3);
          }).join(", "), n2 = 0 === t2.alternation.idx ? "" : t2.alternation.idx;
          return "Ambiguous alternatives: <" + t2.ambiguityIndices.join(" ,") + "> due to common lookahead prefix\nin <OR" + n2 + "> inside <" + t2.topLevelRule.name + "> Rule,\n<" + e2 + "> may appears as a prefix path in all these alternatives.\nhttps://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\nFor Further details.";
        }, buildAlternationAmbiguityError: function(t2) {
          var e2 = o.map(t2.prefixPath, function(t3) {
            return r.tokenLabel(t3);
          }).join(", "), n2 = 0 === t2.alternation.idx ? "" : t2.alternation.idx, i2 = "Ambiguous alternatives: <" + t2.ambiguityIndices.join(" ,") + "> in <OR" + n2 + "> inside <" + t2.topLevelRule.name + "> Rule,\n<" + e2 + "> may appears as a prefix path in all these alternatives.\n", a2 = c.VERSION.replace(/\./g, "_");
          return i2 = i2 + "To Resolve this, try one of of the following: \n1. Refactor your grammar to be LL(K) for the current value of k (by default k=" + l.DEFAULT_PARSER_CONFIG.maxLookahead + "})\n2. Increase the value of K for your grammar by providing a larger 'maxLookahead' value in the parser's config\n3. This issue can be ignored (if you know what you are doing...), see https://sap.github.io/chevrotain/documentation/" + a2 + "/interfaces/iparserconfig.html#ignoredissues for more details\n";
        }, buildEmptyRepetitionError: function(t2) {
          var e2 = u.getProductionDslName(t2.repetition);
          return 0 !== t2.repetition.idx && (e2 += t2.repetition.idx), "The repetition <" + e2 + "> within Rule <" + t2.topLevelRule.name + "> can never consume any tokens.\nThis could lead to an infinite loop.";
        }, buildTokenNameError: function(t2) {
          return "Invalid Grammar Token name: ->" + r.tokenName(t2.tokenType) + "<- it must match the pattern: ->" + t2.expectedPattern.toString() + "<-";
        }, buildEmptyAlternationError: function(t2) {
          return "Ambiguous empty alternative: <" + (t2.emptyChoiceIdx + 1) + "> in <OR" + t2.alternation.idx + "> inside <" + t2.topLevelRule.name + "> Rule.\nOnly the last alternative may be an empty alternative.";
        }, buildTooManyAlternativesError: function(t2) {
          return "An Alternation cannot have more than 256 alternatives:\n<OR" + t2.alternation.idx + "> inside <" + t2.topLevelRule.name + "> Rule.\n has " + (t2.alternation.definition.length + 1) + " alternatives.";
        }, buildLeftRecursionError: function(t2) {
          var e2 = t2.topLevelRule.name;
          return "Left Recursion found in grammar.\nrule: <" + e2 + "> can be invoked from itself (directly or indirectly)\nwithout consuming any Tokens. The grammar path that causes this is: \n " + (e2 + " --> " + i.map(t2.leftRecursionPath, function(t3) {
            return t3.name;
          }).concat([e2]).join(" --> ")) + "\n To fix this refactor your grammar to remove the left recursion.\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.";
        }, buildInvalidRuleNameError: function(t2) {
          return "Invalid grammar rule name: ->" + t2.topLevelRule.name + "<- it must match the pattern: ->" + t2.expectedPattern.toString() + "<-";
        }, buildDuplicateRuleNameError: function(t2) {
          return "Duplicate definition, rule: ->" + (t2.topLevelRule instanceof a.Rule ? t2.topLevelRule.name : t2.topLevelRule) + "<- is already defined in the grammar: ->" + t2.grammarName + "<-";
        } };
      }, function(t, e, n) {
        "use strict";
        var r, i = this && this.__extends || (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        });
        Object.defineProperty(e, "__esModule", { value: true });
        var o = n(4), a = n(4), u = n(8), s = n(15), c = n(7), l = n(19), E = n(24), p = n(20), f = n(6), L = n(11);
        function S(t2) {
          return s.getProductionDslName(t2) + "_#_" + t2.idx + "_#_" + h(t2);
        }
        function h(t2) {
          return t2 instanceof f.Terminal ? c.tokenName(t2.terminalType) : t2 instanceof f.NonTerminal ? t2.nonTerminalName : "";
        }
        e.validateGrammar = function(t2, e2, n2, r2, i2, l2) {
          var p2 = o.map(t2, function(t3) {
            return function(t4, e3) {
              var n3 = new T();
              t4.accept(n3);
              var r3 = n3.allProductions, i3 = o.groupBy(r3, S), a2 = o.pick(i3, function(t5) {
                return t5.length > 1;
              });
              return o.map(o.values(a2), function(n4) {
                var r4 = o.first(n4), i4 = e3.buildDuplicateFoundError(t4, n4), a3 = s.getProductionDslName(r4), c2 = { message: i4, type: u.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS, ruleName: t4.name, dslName: a3, occurrence: r4.idx }, l3 = h(r4);
                return l3 && (c2.parameter = l3), c2;
              });
            }(t3, i2);
          }), f2 = o.map(t2, function(t3) {
            return N(t3, t3, i2);
          }), L2 = [], A2 = [], m2 = [];
          a.every(f2, a.isEmpty) && (L2 = a.map(t2, function(t3) {
            return C(t3, i2);
          }), A2 = a.map(t2, function(t3) {
            return I(t3, e2, r2, i2);
          }), m2 = P(t2, e2, i2));
          var y2 = function(t3, e3, n3) {
            var r3 = [], i3 = a.map(e3, function(t4) {
              return c.tokenName(t4);
            });
            return a.forEach(t3, function(t4) {
              var e4 = t4.name;
              if (a.contains(i3, e4)) {
                var o2 = n3.buildNamespaceConflictError(t4);
                r3.push({ message: o2, type: u.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE, ruleName: e4 });
              }
            }), r3;
          }(t2, n2, i2), v2 = o.map(n2, function(t3) {
            return d(t3, i2);
          }), M = function(t3, e3) {
            var n3 = [];
            return a.forEach(t3, function(t4) {
              var r3 = new E.NamedDSLMethodsCollectorVisitor("");
              t4.accept(r3);
              var i3 = a.map(r3.result, function(t5) {
                return t5.orgProd;
              });
              n3.push(a.map(i3, function(n4) {
                return R(t4, n4, e3);
              }));
            }), a.flatten(n3);
          }(t2, i2), g = function(t3, e3) {
            var n3 = [];
            return a.forEach(t3, function(t4) {
              var r3 = new E.NamedDSLMethodsCollectorVisitor("");
              t4.accept(r3);
              var i3 = a.groupBy(r3.result, function(t5) {
                return t5.name;
              }), o2 = a.pick(i3, function(t5) {
                return t5.length > 1;
              });
              a.forEach(a.values(o2), function(r4) {
                var i4 = a.map(r4, function(t5) {
                  return t5.orgProd;
                }), o3 = e3.buildDuplicateNestedRuleNameError(t4, i4);
                n3.push({ message: o3, type: u.ParserDefinitionErrorType.DUPLICATE_NESTED_NAME, ruleName: t4.name });
              });
            }), n3;
          }(t2, i2), B = a.map(t2, function(t3) {
            return _(t3, i2);
          }), k = a.map(t2, function(t3) {
            return U(t3, i2);
          }), D = a.map(t2, function(e3) {
            return O(e3, t2, l2, i2);
          });
          return o.flatten(p2.concat(v2, M, g, m2, f2, L2, A2, y2, B, k, D));
        }, e.identifyProductionForDuplicates = S;
        var T = function(t2) {
          function e2() {
            var e3 = null !== t2 && t2.apply(this, arguments) || this;
            return e3.allProductions = [], e3;
          }
          return i(e2, t2), e2.prototype.visitNonTerminal = function(t3) {
            this.allProductions.push(t3);
          }, e2.prototype.visitOption = function(t3) {
            this.allProductions.push(t3);
          }, e2.prototype.visitRepetitionWithSeparator = function(t3) {
            this.allProductions.push(t3);
          }, e2.prototype.visitRepetitionMandatory = function(t3) {
            this.allProductions.push(t3);
          }, e2.prototype.visitRepetitionMandatoryWithSeparator = function(t3) {
            this.allProductions.push(t3);
          }, e2.prototype.visitRepetition = function(t3) {
            this.allProductions.push(t3);
          }, e2.prototype.visitAlternation = function(t3) {
            this.allProductions.push(t3);
          }, e2.prototype.visitTerminal = function(t3) {
            this.allProductions.push(t3);
          }, e2;
        }(L.GAstVisitor);
        function U(t2, n2) {
          var r2 = [], i2 = t2.name;
          return i2.match(e.validTermsPattern) || r2.push({ message: n2.buildInvalidRuleNameError({ topLevelRule: t2, expectedPattern: e.validTermsPattern }), type: u.ParserDefinitionErrorType.INVALID_RULE_NAME, ruleName: i2 }), r2;
        }
        function R(t2, n2, r2) {
          var i2, o2 = [];
          return n2.name.match(e.validNestedRuleName) || (i2 = r2.buildInvalidNestedRuleNameError(t2, n2), o2.push({ message: i2, type: u.ParserDefinitionErrorType.INVALID_NESTED_RULE_NAME, ruleName: t2.name })), o2;
        }
        function d(t2, n2) {
          var r2 = [];
          return c.tokenName(t2).match(e.validTermsPattern) || r2.push({ message: n2.buildTokenNameError({ tokenType: t2, expectedPattern: e.validTermsPattern }), type: u.ParserDefinitionErrorType.INVALID_TOKEN_NAME }), r2;
        }
        function O(t2, e2, n2, r2) {
          var i2 = [];
          if (a.reduce(e2, function(e3, n3) {
            return n3.name === t2.name ? e3 + 1 : e3;
          }, 0) > 1) {
            var o2 = r2.buildDuplicateRuleNameError({ topLevelRule: t2, grammarName: n2 });
            i2.push({ message: o2, type: u.ParserDefinitionErrorType.DUPLICATE_RULE_NAME, ruleName: t2.name });
          }
          return i2;
        }
        function N(t2, e2, n2, r2) {
          void 0 === r2 && (r2 = []);
          var i2 = [], a2 = A(e2.definition);
          if (o.isEmpty(a2))
            return [];
          var s2 = t2.name;
          o.contains(a2, t2) && i2.push({ message: n2.buildLeftRecursionError({ topLevelRule: t2, leftRecursionPath: r2 }), type: u.ParserDefinitionErrorType.LEFT_RECURSION, ruleName: s2 });
          var c2 = o.difference(a2, r2.concat([t2])), l2 = o.map(c2, function(e3) {
            var i3 = o.cloneArr(r2);
            return i3.push(e3), N(t2, e3, n2, i3);
          });
          return i2.concat(o.flatten(l2));
        }
        function A(t2) {
          var e2 = [];
          if (o.isEmpty(t2))
            return e2;
          var n2 = o.first(t2);
          if (n2 instanceof f.NonTerminal)
            e2.push(n2.referencedRule);
          else if (n2 instanceof f.Flat || n2 instanceof f.Option || n2 instanceof f.RepetitionMandatory || n2 instanceof f.RepetitionMandatoryWithSeparator || n2 instanceof f.RepetitionWithSeparator || n2 instanceof f.Repetition)
            e2 = e2.concat(A(n2.definition));
          else if (n2 instanceof f.Alternation)
            e2 = o.flatten(o.map(n2.definition, function(t3) {
              return A(t3.definition);
            }));
          else if (!(n2 instanceof f.Terminal))
            throw Error("non exhaustive match");
          var r2 = s.isOptionalProd(n2), i2 = t2.length > 1;
          if (r2 && i2) {
            var a2 = o.drop(t2);
            return e2.concat(A(a2));
          }
          return e2;
        }
        e.OccurrenceValidationCollector = T, e.validTermsPattern = /^[a-zA-Z_]\w*$/, e.validNestedRuleName = new RegExp(e.validTermsPattern.source.replace("^", "^\\$")), e.validateRuleName = U, e.validateNestedRuleName = R, e.validateTokenName = d, e.validateRuleDoesNotAlreadyExist = O, e.validateRuleIsOverridden = function(t2, e2, n2) {
          var r2, i2 = [];
          return o.contains(e2, t2) || (r2 = "Invalid rule override, rule: ->" + t2 + "<- cannot be overridden in the grammar: ->" + n2 + "<-as it is not defined in any of the super grammars ", i2.push({ message: r2, type: u.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE, ruleName: t2 })), i2;
        }, e.validateNoLeftRecursion = N, e.getFirstNoneTerminal = A;
        var m = function(t2) {
          function e2() {
            var e3 = null !== t2 && t2.apply(this, arguments) || this;
            return e3.alternations = [], e3;
          }
          return i(e2, t2), e2.prototype.visitAlternation = function(t3) {
            this.alternations.push(t3);
          }, e2;
        }(L.GAstVisitor);
        function C(t2, e2) {
          var n2 = new m();
          t2.accept(n2);
          var r2 = n2.alternations;
          return o.reduce(r2, function(n3, r3) {
            var i2 = o.dropRight(r3.definition), a2 = o.map(i2, function(n4, i3) {
              var a3 = p.nextPossibleTokensAfter([n4], [], null, 1);
              return o.isEmpty(a3) ? { message: e2.buildEmptyAlternationError({ topLevelRule: t2, alternation: r3, emptyChoiceIdx: i3 }), type: u.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT, ruleName: t2.name, occurrence: r3.idx, alternative: i3 + 1 } : null;
            });
            return n3.concat(o.compact(a2));
          }, []);
        }
        function I(t2, e2, n2, r2) {
          var i2 = new m();
          t2.accept(i2);
          var c2 = i2.alternations, E2 = n2[t2.name];
          return E2 && (c2 = a.reject(c2, function(t3) {
            return E2[s.getProductionDslName(t3) + (0 === t3.idx ? "" : t3.idx)];
          })), o.reduce(c2, function(n3, i3) {
            var s2 = i3.idx, c3 = l.getLookaheadPathsForOr(s2, t2, e2), E3 = function(t3, e3, n4, r3) {
              var i4 = [], s3 = a.reduce(t3, function(e4, n5, r4) {
                return a.forEach(n5, function(n6) {
                  var o2 = [r4];
                  a.forEach(t3, function(t4, e5) {
                    r4 !== e5 && l.containsPath(t4, n6) && o2.push(e5);
                  }), o2.length > 1 && !l.containsPath(i4, n6) && (i4.push(n6), e4.push({ alts: o2, path: n6 }));
                }), e4;
              }, []);
              return o.map(s3, function(t4) {
                var i5 = a.map(t4.alts, function(t5) {
                  return t5 + 1;
                }), o2 = r3.buildAlternationAmbiguityError({ topLevelRule: n4, alternation: e3, ambiguityIndices: i5, prefixPath: t4.path });
                return { message: o2, type: u.ParserDefinitionErrorType.AMBIGUOUS_ALTS, ruleName: n4.name, occurrence: e3.idx, alternatives: [t4.alts] };
              });
            }(c3, i3, t2, r2), p2 = v(c3, i3, t2, r2);
            return n3.concat(E3, p2);
          }, []);
        }
        e.validateEmptyOrAlternative = C, e.validateAmbiguousAlternationAlternatives = I;
        var y = function(t2) {
          function e2() {
            var e3 = null !== t2 && t2.apply(this, arguments) || this;
            return e3.allProductions = [], e3;
          }
          return i(e2, t2), e2.prototype.visitRepetitionWithSeparator = function(t3) {
            this.allProductions.push(t3);
          }, e2.prototype.visitRepetitionMandatory = function(t3) {
            this.allProductions.push(t3);
          }, e2.prototype.visitRepetitionMandatoryWithSeparator = function(t3) {
            this.allProductions.push(t3);
          }, e2.prototype.visitRepetition = function(t3) {
            this.allProductions.push(t3);
          }, e2;
        }(L.GAstVisitor);
        function _(t2, e2) {
          var n2 = new m();
          t2.accept(n2);
          var r2 = n2.alternations;
          return o.reduce(r2, function(n3, r3) {
            return r3.definition.length > 255 && n3.push({ message: e2.buildTooManyAlternativesError({ topLevelRule: t2, alternation: r3 }), type: u.ParserDefinitionErrorType.TOO_MANY_ALTS, ruleName: t2.name, occurrence: r3.idx }), n3;
          }, []);
        }
        function P(t2, e2, n2) {
          var r2 = [];
          return a.forEach(t2, function(t3) {
            var i2 = new y();
            t3.accept(i2);
            var o2 = i2.allProductions;
            a.forEach(o2, function(i3) {
              var o3 = l.getProdType(i3), s2 = i3.idx, c2 = l.getLookaheadPathsForOptionalProd(s2, t3, o3, e2)[0];
              if (a.isEmpty(a.flatten(c2))) {
                var E2 = n2.buildEmptyRepetitionError({ topLevelRule: t3, repetition: i3 });
                r2.push({ message: E2, type: u.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD, ruleName: t3.name });
              }
            });
          }), r2;
        }
        function v(t2, e2, n2, r2) {
          var i2 = [], o2 = a.reduce(t2, function(t3, e3, n3) {
            var r3 = a.map(e3, function(t4) {
              return { idx: n3, path: t4 };
            });
            return t3.concat(r3);
          }, []);
          return a.forEach(o2, function(t3) {
            var s2 = t3.idx, c2 = t3.path, E2 = a.findAll(o2, function(t4) {
              return t4.idx < s2 && l.isStrictPrefixOfPath(t4.path, c2);
            }), p2 = a.map(E2, function(t4) {
              var i3 = [t4.idx + 1, s2 + 1], o3 = 0 === e2.idx ? "" : e2.idx;
              return { message: r2.buildAlternationPrefixAmbiguityError({ topLevelRule: n2, alternation: e2, ambiguityIndices: i3, prefixPath: t4.path }), type: u.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS, ruleName: n2.name, occurrence: o3, alternatives: i3 };
            });
            i2 = i2.concat(p2);
          }), i2;
        }
        e.RepetionCollector = y, e.validateTooManyAlts = _, e.validateSomeNonEmptyLookaheadPath = P, e.checkPrefixAlternativesAmbiguities = v;
      }, function(t, e, n) {
        "use strict";
        var r, i = this && this.__extends || (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        });
        Object.defineProperty(e, "__esModule", { value: true });
        var o, a = n(4), u = n(20), s = n(22), c = n(14), l = n(6), E = n(11);
        !function(t2) {
          t2[t2.OPTION = 0] = "OPTION", t2[t2.REPETITION = 1] = "REPETITION", t2[t2.REPETITION_MANDATORY = 2] = "REPETITION_MANDATORY", t2[t2.REPETITION_MANDATORY_WITH_SEPARATOR = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR", t2[t2.REPETITION_WITH_SEPARATOR = 4] = "REPETITION_WITH_SEPARATOR", t2[t2.ALTERNATION = 5] = "ALTERNATION";
        }(o = e.PROD_TYPE || (e.PROD_TYPE = {})), e.getProdType = function(t2) {
          if (t2 instanceof l.Option)
            return o.OPTION;
          if (t2 instanceof l.Repetition)
            return o.REPETITION;
          if (t2 instanceof l.RepetitionMandatory)
            return o.REPETITION_MANDATORY;
          if (t2 instanceof l.RepetitionMandatoryWithSeparator)
            return o.REPETITION_MANDATORY_WITH_SEPARATOR;
          if (t2 instanceof l.RepetitionWithSeparator)
            return o.REPETITION_WITH_SEPARATOR;
          if (t2 instanceof l.Alternation)
            return o.ALTERNATION;
          throw Error("non exhaustive match");
        }, e.buildLookaheadFuncForOr = function(t2, e2, n2, r2, i2, o2) {
          var a2 = S(t2, e2, n2);
          return o2(a2, r2, U(a2) ? c.tokenStructuredMatcherNoCategories : c.tokenStructuredMatcher, i2);
        }, e.buildLookaheadFuncForOptionalProd = function(t2, e2, n2, r2, i2, o2) {
          var a2 = h(t2, e2, i2, n2), u2 = U(a2) ? c.tokenStructuredMatcherNoCategories : c.tokenStructuredMatcher;
          return o2(a2[0], u2, r2);
        }, e.buildAlternativesLookAheadFunc = function(t2, e2, n2, r2) {
          var i2 = t2.length, o2 = a.every(t2, function(t3) {
            return a.every(t3, function(t4) {
              return 1 === t4.length;
            });
          });
          if (e2)
            return function(e3) {
              for (var r3 = a.map(e3, function(t3) {
                return t3.GATE;
              }), o3 = 0; o3 < i2; o3++) {
                var u3 = t2[o3], s3 = u3.length, c2 = r3[o3];
                if (void 0 === c2 || false !== c2.call(this))
                  t:
                    for (var l2 = 0; l2 < s3; l2++) {
                      for (var E2 = u3[l2], p2 = E2.length, f2 = 0; f2 < p2; f2++) {
                        var L2 = this.LA(f2 + 1);
                        if (false === n2(L2, E2[f2]))
                          continue t;
                      }
                      return o3;
                    }
              }
            };
          if (o2 && !r2) {
            var u2 = a.map(t2, function(t3) {
              return a.flatten(t3);
            }), s2 = a.reduce(u2, function(t3, e3, n3) {
              return a.forEach(e3, function(e4) {
                a.has(t3, e4.tokenTypeIdx) || (t3[e4.tokenTypeIdx] = n3), a.forEach(e4.categoryMatches, function(e5) {
                  a.has(t3, e5) || (t3[e5] = n3);
                });
              }), t3;
            }, []);
            return function() {
              var t3 = this.LA(1);
              return s2[t3.tokenTypeIdx];
            };
          }
          return function() {
            for (var e3 = 0; e3 < i2; e3++) {
              var r3 = t2[e3], o3 = r3.length;
              t:
                for (var a2 = 0; a2 < o3; a2++) {
                  for (var u3 = r3[a2], s3 = u3.length, c2 = 0; c2 < s3; c2++) {
                    var l2 = this.LA(c2 + 1);
                    if (false === n2(l2, u3[c2]))
                      continue t;
                  }
                  return e3;
                }
            }
          };
        }, e.buildSingleAlternativeLookaheadFunction = function(t2, e2, n2) {
          var r2 = a.every(t2, function(t3) {
            return 1 === t3.length;
          }), i2 = t2.length;
          if (r2 && !n2) {
            var o2 = a.flatten(t2);
            if (1 === o2.length && a.isEmpty(o2[0].categoryMatches)) {
              var u2 = o2[0].tokenTypeIdx;
              return function() {
                return this.LA(1).tokenTypeIdx === u2;
              };
            }
            var s2 = a.reduce(o2, function(t3, e3, n3) {
              return t3[e3.tokenTypeIdx] = true, a.forEach(e3.categoryMatches, function(e4) {
                t3[e4] = true;
              }), t3;
            }, []);
            return function() {
              var t3 = this.LA(1);
              return true === s2[t3.tokenTypeIdx];
            };
          }
          return function() {
            t:
              for (var n3 = 0; n3 < i2; n3++) {
                for (var r3 = t2[n3], o3 = r3.length, a2 = 0; a2 < o3; a2++) {
                  var u3 = this.LA(a2 + 1);
                  if (false === e2(u3, r3[a2]))
                    continue t;
                }
                return true;
              }
            return false;
          };
        };
        var p = function(t2) {
          function e2(e3, n2, r2) {
            var i2 = t2.call(this) || this;
            return i2.topProd = e3, i2.targetOccurrence = n2, i2.targetProdType = r2, i2;
          }
          return i(e2, t2), e2.prototype.startWalking = function() {
            return this.walk(this.topProd), this.restDef;
          }, e2.prototype.checkIsTarget = function(t3, e3, n2, r2) {
            return t3.idx === this.targetOccurrence && this.targetProdType === e3 && (this.restDef = n2.concat(r2), true);
          }, e2.prototype.walkOption = function(e3, n2, r2) {
            this.checkIsTarget(e3, o.OPTION, n2, r2) || t2.prototype.walkOption.call(this, e3, n2, r2);
          }, e2.prototype.walkAtLeastOne = function(e3, n2, r2) {
            this.checkIsTarget(e3, o.REPETITION_MANDATORY, n2, r2) || t2.prototype.walkOption.call(this, e3, n2, r2);
          }, e2.prototype.walkAtLeastOneSep = function(e3, n2, r2) {
            this.checkIsTarget(e3, o.REPETITION_MANDATORY_WITH_SEPARATOR, n2, r2) || t2.prototype.walkOption.call(this, e3, n2, r2);
          }, e2.prototype.walkMany = function(e3, n2, r2) {
            this.checkIsTarget(e3, o.REPETITION, n2, r2) || t2.prototype.walkOption.call(this, e3, n2, r2);
          }, e2.prototype.walkManySep = function(e3, n2, r2) {
            this.checkIsTarget(e3, o.REPETITION_WITH_SEPARATOR, n2, r2) || t2.prototype.walkOption.call(this, e3, n2, r2);
          }, e2;
        }(s.RestWalker), f = function(t2) {
          function e2(e3, n2) {
            var r2 = t2.call(this) || this;
            return r2.targetOccurrence = e3, r2.targetProdType = n2, r2.result = [], r2;
          }
          return i(e2, t2), e2.prototype.checkIsTarget = function(t3, e3) {
            t3.idx === this.targetOccurrence && this.targetProdType === e3 && (this.result = t3.definition);
          }, e2.prototype.visitOption = function(t3) {
            this.checkIsTarget(t3, o.OPTION);
          }, e2.prototype.visitRepetition = function(t3) {
            this.checkIsTarget(t3, o.REPETITION);
          }, e2.prototype.visitRepetitionMandatory = function(t3) {
            this.checkIsTarget(t3, o.REPETITION_MANDATORY);
          }, e2.prototype.visitRepetitionMandatoryWithSeparator = function(t3) {
            this.checkIsTarget(t3, o.REPETITION_MANDATORY_WITH_SEPARATOR);
          }, e2.prototype.visitRepetitionWithSeparator = function(t3) {
            this.checkIsTarget(t3, o.REPETITION_WITH_SEPARATOR);
          }, e2.prototype.visitAlternation = function(t3) {
            this.checkIsTarget(t3, o.ALTERNATION);
          }, e2;
        }(E.GAstVisitor);
        function L(t2, e2) {
          function n2(t3, e3) {
            return a.reduce(t3, function(t4, n3, r3) {
              if (r3 !== e3) {
                var i3 = a.map(n3, function(t5) {
                  return t5.partialPath;
                });
                return t4.concat(i3);
              }
              return t4;
            }, []);
          }
          function r2(t3, e3) {
            return void 0 === a.find(t3, function(t4) {
              return a.every(e3, function(e4, n3) {
                return r3 = e4, i3 = t4[n3], r3 === i3 || r3 && i3 && (r3.categoryMatchesMap[i3.tokenTypeIdx] || i3.categoryMatchesMap[r3.tokenTypeIdx]);
                var r3, i3;
              });
            });
          }
          function i2(t3) {
            for (var e3 = [], n3 = 0; n3 < t3; n3++)
              e3.push([]);
            return e3;
          }
          for (var o2 = a.map(t2, function(t3) {
            return u.possiblePathsFrom([t3], 1);
          }), s2 = i2(o2.length), c2 = o2, l2 = 1; l2 <= e2; l2++) {
            var E2 = c2;
            c2 = i2(E2.length);
            for (var p2 = 0; p2 < E2.length; p2++)
              for (var f2 = E2[p2], L2 = n2(E2, p2), S2 = 0; S2 < f2.length; S2++) {
                var h2 = f2[S2].partialPath, U2 = f2[S2].suffixDef;
                if (r2(L2, h2) || a.isEmpty(U2) || h2.length === e2) {
                  var R = s2[p2];
                  T(R, h2) || R.push(h2);
                } else {
                  var d = u.possiblePathsFrom(U2, l2 + 1, h2);
                  c2[p2] = c2[p2].concat(d);
                }
              }
          }
          return s2;
        }
        function S(t2, e2, n2) {
          var r2 = new f(t2, o.ALTERNATION);
          return e2.accept(r2), L(r2.result, n2);
        }
        function h(t2, e2, n2, r2) {
          var i2 = new f(t2, n2);
          e2.accept(i2);
          var o2 = i2.result, a2 = new p(e2, t2, n2).startWalking();
          return L([new l.Flat({ definition: o2 }), new l.Flat({ definition: a2 })], r2);
        }
        function T(t2, e2) {
          return void 0 !== a.find(t2, function(t3) {
            return e2.length === t3.length && a.every(e2, function(e3, n2) {
              return e3 === t3[n2] || t3[n2].categoryMatchesMap[e3.tokenTypeIdx];
            });
          });
        }
        function U(t2) {
          return a.every(t2, function(t3) {
            return a.every(t3, function(t4) {
              return a.every(t4, function(t5) {
                return a.isEmpty(t5.categoryMatches);
              });
            });
          });
        }
        e.lookAheadSequenceFromAlternatives = L, e.getLookaheadPathsForOr = S, e.getLookaheadPathsForOptionalProd = h, e.containsPath = T, e.isStrictPrefixOfPath = function(t2, e2) {
          return t2.length < e2.length && a.every(t2, function(t3, n2) {
            var r2 = e2[n2];
            return t3 === r2 || r2.categoryMatchesMap[t3.tokenTypeIdx];
          });
        }, e.areTokenCategoriesNotUsed = U;
      }, function(t, e, n) {
        "use strict";
        var r, i = this && this.__extends || (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        });
        Object.defineProperty(e, "__esModule", { value: true });
        var o = n(22), a = n(4), u = n(7), s = n(30), c = n(6), l = function(t2) {
          function e2(e3, n2) {
            var r2 = t2.call(this) || this;
            return r2.topProd = e3, r2.path = n2, r2.possibleTokTypes = [], r2.nextProductionName = "", r2.nextProductionOccurrence = 0, r2.found = false, r2.isAtEndOfPath = false, r2;
          }
          return i(e2, t2), e2.prototype.startWalking = function() {
            if (this.found = false, this.path.ruleStack[0] !== this.topProd.name)
              throw Error("The path does not start with the walker's top Rule!");
            return this.ruleStack = a.cloneArr(this.path.ruleStack).reverse(), this.occurrenceStack = a.cloneArr(this.path.occurrenceStack).reverse(), this.ruleStack.pop(), this.occurrenceStack.pop(), this.updateExpectedNext(), this.walk(this.topProd), this.possibleTokTypes;
          }, e2.prototype.walk = function(e3, n2) {
            void 0 === n2 && (n2 = []), this.found || t2.prototype.walk.call(this, e3, n2);
          }, e2.prototype.walkProdRef = function(t3, e3, n2) {
            if (t3.referencedRule.name === this.nextProductionName && t3.idx === this.nextProductionOccurrence) {
              var r2 = e3.concat(n2);
              this.updateExpectedNext(), this.walk(t3.referencedRule, r2);
            }
          }, e2.prototype.updateExpectedNext = function() {
            a.isEmpty(this.ruleStack) ? (this.nextProductionName = "", this.nextProductionOccurrence = 0, this.isAtEndOfPath = true) : (this.nextProductionName = this.ruleStack.pop(), this.nextProductionOccurrence = this.occurrenceStack.pop());
          }, e2;
        }(o.RestWalker);
        e.AbstractNextPossibleTokensWalker = l;
        var E = function(t2) {
          function e2(e3, n2) {
            var r2 = t2.call(this, e3, n2) || this;
            return r2.path = n2, r2.nextTerminalName = "", r2.nextTerminalOccurrence = 0, r2.nextTerminalName = u.tokenName(r2.path.lastTok), r2.nextTerminalOccurrence = r2.path.lastTokOccurrence, r2;
          }
          return i(e2, t2), e2.prototype.walkTerminal = function(t3, e3, n2) {
            if (this.isAtEndOfPath && u.tokenName(t3.terminalType) === this.nextTerminalName && t3.idx === this.nextTerminalOccurrence && !this.found) {
              var r2 = e3.concat(n2), i2 = new c.Flat({ definition: r2 });
              this.possibleTokTypes = s.first(i2), this.found = true;
            }
          }, e2;
        }(l);
        e.NextAfterTokenWalker = E;
        var p = function(t2) {
          function e2(e3, n2) {
            var r2 = t2.call(this) || this;
            return r2.topRule = e3, r2.occurrence = n2, r2.result = { token: void 0, occurrence: void 0, isEndOfRule: void 0 }, r2;
          }
          return i(e2, t2), e2.prototype.startWalking = function() {
            return this.walk(this.topRule), this.result;
          }, e2;
        }(o.RestWalker);
        e.AbstractNextTerminalAfterProductionWalker = p;
        var f = function(t2) {
          function e2() {
            return null !== t2 && t2.apply(this, arguments) || this;
          }
          return i(e2, t2), e2.prototype.walkMany = function(e3, n2, r2) {
            if (e3.idx === this.occurrence) {
              var i2 = a.first(n2.concat(r2));
              this.result.isEndOfRule = void 0 === i2, i2 instanceof c.Terminal && (this.result.token = i2.terminalType, this.result.occurrence = i2.idx);
            } else
              t2.prototype.walkMany.call(this, e3, n2, r2);
          }, e2;
        }(p);
        e.NextTerminalAfterManyWalker = f;
        var L = function(t2) {
          function e2() {
            return null !== t2 && t2.apply(this, arguments) || this;
          }
          return i(e2, t2), e2.prototype.walkManySep = function(e3, n2, r2) {
            if (e3.idx === this.occurrence) {
              var i2 = a.first(n2.concat(r2));
              this.result.isEndOfRule = void 0 === i2, i2 instanceof c.Terminal && (this.result.token = i2.terminalType, this.result.occurrence = i2.idx);
            } else
              t2.prototype.walkManySep.call(this, e3, n2, r2);
          }, e2;
        }(p);
        e.NextTerminalAfterManySepWalker = L;
        var S = function(t2) {
          function e2() {
            return null !== t2 && t2.apply(this, arguments) || this;
          }
          return i(e2, t2), e2.prototype.walkAtLeastOne = function(e3, n2, r2) {
            if (e3.idx === this.occurrence) {
              var i2 = a.first(n2.concat(r2));
              this.result.isEndOfRule = void 0 === i2, i2 instanceof c.Terminal && (this.result.token = i2.terminalType, this.result.occurrence = i2.idx);
            } else
              t2.prototype.walkAtLeastOne.call(this, e3, n2, r2);
          }, e2;
        }(p);
        e.NextTerminalAfterAtLeastOneWalker = S;
        var h = function(t2) {
          function e2() {
            return null !== t2 && t2.apply(this, arguments) || this;
          }
          return i(e2, t2), e2.prototype.walkAtLeastOneSep = function(e3, n2, r2) {
            if (e3.idx === this.occurrence) {
              var i2 = a.first(n2.concat(r2));
              this.result.isEndOfRule = void 0 === i2, i2 instanceof c.Terminal && (this.result.token = i2.terminalType, this.result.occurrence = i2.idx);
            } else
              t2.prototype.walkAtLeastOneSep.call(this, e3, n2, r2);
          }, e2;
        }(p);
        function T(t2, e2, n2, r2) {
          var i2 = a.cloneArr(n2);
          i2.push(t2.name);
          var o2 = a.cloneArr(r2);
          return o2.push(1), { idx: e2, def: t2.definition, ruleStack: i2, occurrenceStack: o2 };
        }
        e.NextTerminalAfterAtLeastOneSepWalker = h, e.possiblePathsFrom = function t2(e2, n2, r2) {
          void 0 === r2 && (r2 = []), r2 = a.cloneArr(r2);
          var i2 = [], o2 = 0;
          function u2(u3) {
            var s3 = t2(u3.concat(a.drop(e2, o2 + 1)), n2, r2);
            return i2.concat(s3);
          }
          for (; r2.length < n2 && o2 < e2.length; ) {
            var s2 = e2[o2];
            if (s2 instanceof c.Flat)
              return u2(s2.definition);
            if (s2 instanceof c.NonTerminal)
              return u2(s2.definition);
            if (s2 instanceof c.Option)
              i2 = u2(s2.definition);
            else {
              if (s2 instanceof c.RepetitionMandatory)
                return u2(l2 = s2.definition.concat([new c.Repetition({ definition: s2.definition })]));
              if (s2 instanceof c.RepetitionMandatoryWithSeparator)
                return u2(l2 = [new c.Flat({ definition: s2.definition }), new c.Repetition({ definition: [new c.Terminal({ terminalType: s2.separator })].concat(s2.definition) })]);
              if (s2 instanceof c.RepetitionWithSeparator) {
                var l2 = s2.definition.concat([new c.Repetition({ definition: [new c.Terminal({ terminalType: s2.separator })].concat(s2.definition) })]);
                i2 = u2(l2);
              } else if (s2 instanceof c.Repetition)
                l2 = s2.definition.concat([new c.Repetition({ definition: s2.definition })]), i2 = u2(l2);
              else {
                if (s2 instanceof c.Alternation)
                  return a.forEach(s2.definition, function(t3) {
                    i2 = u2(t3.definition);
                  }), i2;
                if (!(s2 instanceof c.Terminal))
                  throw Error("non exhaustive match");
                r2.push(s2.terminalType);
              }
            }
            o2++;
          }
          return i2.push({ partialPath: r2, suffixDef: a.drop(e2, o2) }), i2;
        }, e.nextPossibleTokensAfter = function(t2, e2, n2, r2) {
          var i2 = ["EXIT_NONE_TERMINAL"], o2 = false, u2 = e2.length, s2 = u2 - r2 - 1, l2 = [], E2 = [];
          for (E2.push({ idx: -1, def: t2, ruleStack: [], occurrenceStack: [] }); !a.isEmpty(E2); ) {
            var p2 = E2.pop();
            if ("EXIT_ALTERNATIVE" !== p2) {
              var f2 = p2.def, L2 = p2.idx, S2 = p2.ruleStack, h2 = p2.occurrenceStack;
              if (!a.isEmpty(f2)) {
                var U = f2[0];
                if ("EXIT_NONE_TERMINAL" === U) {
                  var R = { idx: L2, def: a.drop(f2), ruleStack: a.dropRight(S2), occurrenceStack: a.dropRight(h2) };
                  E2.push(R);
                } else if (U instanceof c.Terminal)
                  if (L2 < u2 - 1) {
                    var d = L2 + 1;
                    n2(e2[d], U.terminalType) && (R = { idx: d, def: a.drop(f2), ruleStack: S2, occurrenceStack: h2 }, E2.push(R));
                  } else {
                    if (L2 !== u2 - 1)
                      throw Error("non exhaustive match");
                    l2.push({ nextTokenType: U.terminalType, nextTokenOccurrence: U.idx, ruleStack: S2, occurrenceStack: h2 }), o2 = true;
                  }
                else if (U instanceof c.NonTerminal) {
                  var O = a.cloneArr(S2);
                  O.push(U.nonTerminalName);
                  var N = a.cloneArr(h2);
                  N.push(U.idx), R = { idx: L2, def: U.definition.concat(i2, a.drop(f2)), ruleStack: O, occurrenceStack: N }, E2.push(R);
                } else if (U instanceof c.Option) {
                  var A = { idx: L2, def: a.drop(f2), ruleStack: S2, occurrenceStack: h2 };
                  E2.push(A), E2.push("EXIT_ALTERNATIVE");
                  var m = { idx: L2, def: U.definition.concat(a.drop(f2)), ruleStack: S2, occurrenceStack: h2 };
                  E2.push(m);
                } else if (U instanceof c.RepetitionMandatory) {
                  var C = new c.Repetition({ definition: U.definition, idx: U.idx });
                  R = { idx: L2, def: U.definition.concat([C], a.drop(f2)), ruleStack: S2, occurrenceStack: h2 }, E2.push(R);
                } else if (U instanceof c.RepetitionMandatoryWithSeparator) {
                  var I = new c.Terminal({ terminalType: U.separator });
                  C = new c.Repetition({ definition: [I].concat(U.definition), idx: U.idx }), R = { idx: L2, def: U.definition.concat([C], a.drop(f2)), ruleStack: S2, occurrenceStack: h2 }, E2.push(R);
                } else if (U instanceof c.RepetitionWithSeparator) {
                  A = { idx: L2, def: a.drop(f2), ruleStack: S2, occurrenceStack: h2 }, E2.push(A), E2.push("EXIT_ALTERNATIVE"), I = new c.Terminal({ terminalType: U.separator });
                  var y = new c.Repetition({ definition: [I].concat(U.definition), idx: U.idx });
                  m = { idx: L2, def: U.definition.concat([y], a.drop(f2)), ruleStack: S2, occurrenceStack: h2 }, E2.push(m);
                } else if (U instanceof c.Repetition)
                  A = { idx: L2, def: a.drop(f2), ruleStack: S2, occurrenceStack: h2 }, E2.push(A), E2.push("EXIT_ALTERNATIVE"), y = new c.Repetition({ definition: U.definition, idx: U.idx }), m = { idx: L2, def: U.definition.concat([y], a.drop(f2)), ruleStack: S2, occurrenceStack: h2 }, E2.push(m);
                else if (U instanceof c.Alternation)
                  for (var _ = U.definition.length - 1; _ >= 0; _--) {
                    var P = { idx: L2, def: U.definition[_].definition.concat(a.drop(f2)), ruleStack: S2, occurrenceStack: h2 };
                    E2.push(P), E2.push("EXIT_ALTERNATIVE");
                  }
                else if (U instanceof c.Flat)
                  E2.push({ idx: L2, def: U.definition.concat(a.drop(f2)), ruleStack: S2, occurrenceStack: h2 });
                else {
                  if (!(U instanceof c.Rule))
                    throw Error("non exhaustive match");
                  E2.push(T(U, L2, S2, h2));
                }
              }
            } else
              o2 && a.last(E2).idx <= s2 && E2.pop();
          }
          return l2;
        };
      }, function(t, e, n) {
        "use strict";
        n.d(e, "a", function() {
          return BaseSparqlParser;
        });
        var r, i = n(1), o = (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        }), a = function() {
          return (a = Object.assign || function(t2) {
            for (var e2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
              for (var i2 in e2 = arguments[n2])
                Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
            return t2;
          }).apply(this, arguments);
        }, u = n(9).sparqlTokenMap;
        function s() {
          for (var t2 = [], e2 = 0; e2 < arguments.length; e2++)
            t2[e2] = arguments[e2];
        }
        var BaseSparqlParser = function(t2) {
          function BaseSparqlParser2(e2, n2) {
            void 0 === e2 && (e2 = {});
            var r2 = t2.call(this, n2, a({ recoveryEnabled: true, outputCst: true }, e2.config)) || this;
            return r2.tokenize = function(t3) {
              return r2.lexer.tokenize(t3).tokens;
            }, r2.parse = function(t3, e3) {
              void 0 === e3 && (e3 = r2.SparqlDoc);
              var n3 = r2.lexer.tokenize(t3);
              r2.input = n3.tokens;
              var i2 = n3.groups.comments || [], o2 = e3.call(r2);
              return { errors: r2.errors, comments: i2, cst: o2 };
            }, r2.parseGroupGraphPattern = function(t3) {
              return r2.parse(t3, r2.GroupGraphPattern);
            }, r2.parseTriplesBlock = function(t3) {
              return r2.parse(t3, r2.TriplesBlock);
            }, r2.SparqlDoc = r2.RULE("SparqlDoc", function() {
              s("SparqlDoc"), r2.MANY(function() {
                return r2.OR([{ ALT: function() {
                  return r2.SUBRULE(r2.Prologue);
                } }, { ALT: function() {
                  return r2.SUBRULE(r2.QueryUnit);
                } }, { ALT: function() {
                  return r2.SUBRULE(r2.UpdateUnit);
                } }]);
              });
            }), r2.QueryUnit = r2.RULE("QueryUnit", function() {
              s("QueryUnit"), r2.SUBRULE(r2.Query);
            }), r2.Query = r2.RULE("Query", function() {
              s("Query"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.SelectQuery);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.ConstructQuery);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.DescribeQuery);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.AskQuery);
              } }]), r2.SUBRULE(r2.ValuesClause);
            }), r2.Constant = r2.RULE("Constant", function() {
              r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.iri);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.RDFLiteral);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.NumericLiteral);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BooleanLiteral);
              } }]);
            }), r2.MaxLength = r2.RULE("MaxLength", function() {
              r2.CONSUME(u.MAX_LENGTH), r2.CONSUME(u.INTEGER);
            }), r2.UpdateUnit = r2.RULE("UpdateUnit", function() {
              s("UpdateUnit"), r2.SUBRULE(r2.Update);
            }), r2.Prologue = r2.RULE("Prologue", function() {
              s("Prologue"), r2.AT_LEAST_ONE(function() {
                return r2.OR([{ ALT: function() {
                  return r2.SUBRULE(r2.BaseDecl);
                } }, { ALT: function() {
                  return r2.SUBRULE(r2.PrefixDecl);
                } }]);
              });
            }), r2.BaseDecl = r2.RULE("BaseDecl", function() {
              s("BaseDecl"), r2.CONSUME(u.BASE), r2.CONSUME(u.IRIREF);
            }), r2.PrefixDecl = r2.RULE("PrefixDecl", function() {
              s("PrefixDecl"), r2.CONSUME(u.PREFIX), r2.CONSUME(u.PNAME_NS), r2.CONSUME(u.IRIREF);
            }), r2.SelectQuery = r2.RULE("SelectQuery", function() {
              s("SelectQuery"), r2.SUBRULE(r2.SelectClause), r2.MANY(function() {
                return r2.SUBRULE(r2.DatasetClause);
              }), r2.SUBRULE(r2.WhereClause), r2.SUBRULE(r2.SolutionModifier);
            }), r2.SubSelect = r2.RULE("SubSelect", function() {
              s("SubSelect"), r2.SUBRULE(r2.SelectClause), r2.SUBRULE(r2.WhereClause), r2.SUBRULE(r2.SolutionModifier), r2.SUBRULE(r2.ValuesClause);
            }), r2.SelectClause = r2.RULE("SelectClause", function() {
              s("SelectClause"), r2.CONSUME(u.SELECT), r2.OPTION(function() {
                return r2.OR([{ ALT: function() {
                  return r2.CONSUME(u.DISTINCT);
                } }, { ALT: function() {
                  return r2.CONSUME(u.REDUCED);
                } }]);
              }), r2.OR1([{ ALT: function() {
                r2.AT_LEAST_ONE(function() {
                  return r2.OR2([{ ALT: function() {
                    return r2.SUBRULE(r2.Var);
                  } }, { ALT: function() {
                    r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.AS), r2.SUBRULE1(r2.Var), r2.CONSUME(u.RParen);
                  } }]);
                });
              } }, { ALT: function() {
                return r2.CONSUME(u.Star);
              } }]);
            }), r2.ConstructQuery = r2.RULE("ConstructQuery", function() {
              r2.CONSUME(u.CONSTRUCT), r2.OR([{ ALT: function() {
                r2.SUBRULE(r2.ConstructTemplate), r2.MANY(function() {
                  return r2.SUBRULE(r2.DatasetClause);
                }), r2.SUBRULE(r2.WhereClause);
              } }, { ALT: function() {
                r2.MANY1(function() {
                  return r2.SUBRULE1(r2.DatasetClause);
                }), r2.CONSUME(u.WHERE), r2.CONSUME(u.LCurly), r2.OPTION(function() {
                  return r2.SUBRULE(r2.TriplesTemplate);
                }), r2.CONSUME(u.RCurly);
              } }]), r2.SUBRULE(r2.SolutionModifier);
            }), r2.DescribeQuery = r2.RULE("DescribeQuery", function() {
              s("DescribeQuery"), r2.CONSUME(u.DESCRIBE), r2.OR([{ ALT: function() {
                r2.AT_LEAST_ONE(function() {
                  return r2.SUBRULE(r2.VarOrIri);
                });
              } }, { ALT: function() {
                return r2.CONSUME(u.Star);
              } }]), r2.MANY(function() {
                return r2.SUBRULE(r2.DatasetClause);
              }), r2.OPTION(function() {
                return r2.SUBRULE(r2.WhereClause);
              }), r2.SUBRULE(r2.SolutionModifier);
            }), r2.AskQuery = r2.RULE("AskQuery", function() {
              s("AskQuery"), r2.CONSUME(u.ASK), r2.MANY(function() {
                return r2.SUBRULE(r2.DatasetClause);
              }), r2.SUBRULE(r2.WhereClause), r2.SUBRULE(r2.SolutionModifier);
            }), r2.DatasetClause = r2.RULE("DatasetClause", function() {
              s("DatasetClause"), r2.CONSUME(u.FROM), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.DefaultGraphClause);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.NamedGraphClause);
              } }]);
            }), r2.DefaultGraphClause = r2.RULE("DefaultGraphClause", function() {
              s("DefaultGraphClause"), r2.SUBRULE(r2.SourceSelector);
            }), r2.NamedGraphClause = r2.RULE("NamedGraphClause", function() {
              s("NamedGraphClause"), r2.CONSUME(u.NAMED), r2.SUBRULE(r2.SourceSelector);
            }), r2.SourceSelector = r2.RULE("SourceSelector", function() {
              s("SourceSelector"), r2.SUBRULE(r2.iri);
            }), r2.WhereClause = r2.RULE("WhereClause", function() {
              s("WhereClause"), r2.OPTION(function() {
                return r2.CONSUME(u.WHERE);
              }), r2.SUBRULE(r2.GroupGraphPattern);
            }), r2.SolutionModifier = r2.RULE("SolutionModifier", function() {
              s("SolutionModifier"), r2.OPTION(function() {
                return r2.SUBRULE(r2.GroupClause);
              }), r2.OPTION1(function() {
                return r2.SUBRULE(r2.HavingClause);
              }), r2.OPTION2(function() {
                return r2.SUBRULE(r2.OrderClause);
              }), r2.OPTION3(function() {
                return r2.SUBRULE(r2.LimitOffsetClause);
              });
            }), r2.GroupClause = r2.RULE("GroupClause", function() {
              s("GroupClause"), r2.CONSUME(u.GROUP_BY), r2.AT_LEAST_ONE(function() {
                return r2.SUBRULE(r2.GroupCondition);
              });
            }), r2.GroupCondition = r2.RULE("GroupCondition", function() {
              s("GroupCondition"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.FunctionCall);
              } }, { ALT: function() {
                r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.OPTION(function() {
                  r2.CONSUME(u.AS), r2.SUBRULE(r2.Var);
                }), r2.CONSUME(u.RParen);
              } }, { ALT: function() {
                return r2.SUBRULE1(r2.Var);
              } }]);
            }), r2.HavingClause = r2.RULE("HavingClause", function() {
              s("HavingClause"), r2.CONSUME(u.HAVING), r2.SUBRULE(r2.HavingCondition);
            }), r2.HavingCondition = r2.RULE("HavingCondition", function() {
              s("HavingCondition"), r2.SUBRULE(r2.Constraint);
            }), r2.OrderClause = r2.RULE("OrderClause", function() {
              s("OrderClause"), r2.CONSUME(u.ORDER_BY), r2.AT_LEAST_ONE(function() {
                return r2.SUBRULE(r2.OrderCondition);
              });
            }), r2.OrderCondition = r2.RULE("OrderCondition", function() {
              s("OrderCondition"), r2.OR([{ ALT: function() {
                r2.OR1([{ ALT: function() {
                  return r2.CONSUME(u.ASC);
                } }, { ALT: function() {
                  return r2.CONSUME(u.DESC);
                } }]), r2.SUBRULE(r2.BrackettedExpression);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.Constraint);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.Var);
              } }]);
            }), r2.LimitOffsetClause = r2.RULE("LimitOffsetClause", function() {
              s("LimitOffsetClause"), r2.OR([{ ALT: function() {
                r2.SUBRULE(r2.LimitClause), r2.OPTION(function() {
                  return r2.SUBRULE(r2.OffsetClause);
                });
              } }, { ALT: function() {
                r2.SUBRULE1(r2.OffsetClause), r2.OPTION1(function() {
                  return r2.SUBRULE1(r2.LimitClause);
                });
              } }]);
            }), r2.OffsetClause = r2.RULE("OffsetClause", function() {
              s("OffsetClause"), r2.CONSUME(u.OFFSET), r2.CONSUME(u.INTEGER);
            }), r2.LimitClause = r2.RULE("LimitClause", function() {
              s("LimitClause"), r2.CONSUME(u.LIMIT), r2.CONSUME(u.INTEGER);
            }), r2.ValuesClause = r2.RULE("ValuesClause", function() {
              s("ValuesClause"), r2.OPTION(function() {
                r2.CONSUME(u.VALUES), r2.SUBRULE(r2.DataBlock);
              });
            }), r2.Update = r2.RULE("Update", function() {
              s("Update"), r2.SUBRULE(r2.Update1), r2.OPTION(function() {
                r2.CONSUME(u.Semicolon), r2.SUBRULE(r2.Update);
              });
            }), r2.Update1 = r2.RULE("Update1", function() {
              s("Update1"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.Load);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.Clear);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.Drop);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.Add);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.Move);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.Copy);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.Create);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.InsertData);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.DeleteData);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.DeleteWhere);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.Modify);
              } }]);
            }), r2.Load = r2.RULE("Load", function() {
              s("Load"), r2.CONSUME(u.LOAD), r2.OPTION(function() {
                return r2.CONSUME(u.SILENT);
              }), r2.SUBRULE(r2.iri), r2.OPTION1(function() {
                r2.CONSUME(u.INTO), r2.SUBRULE(r2.GraphRef);
              });
            }), r2.Clear = r2.RULE("Clear", function() {
              s("Clear"), r2.CONSUME(u.CLEAR), r2.OPTION(function() {
                return r2.CONSUME(u.SILENT);
              }), r2.SUBRULE(r2.GraphRefAll);
            }), r2.Drop = r2.RULE("Drop", function() {
              s("Drop"), r2.CONSUME(u.DROP), r2.OPTION(function() {
                return r2.CONSUME(u.SILENT);
              }), r2.SUBRULE(r2.GraphRefAll);
            }), r2.Create = r2.RULE("Create", function() {
              s("Create"), r2.CONSUME(u.CREATE), r2.OPTION(function() {
                return r2.CONSUME(u.SILENT);
              }), r2.SUBRULE(r2.GraphRefAll);
            }), r2.Add = r2.RULE("Add", function() {
              s("Add"), r2.CONSUME(u.ADD), r2.OPTION(function() {
                return r2.CONSUME(u.SILENT);
              }), r2.SUBRULE(r2.GraphOrDefault), r2.CONSUME(u.TO), r2.SUBRULE1(r2.GraphOrDefault);
            }), r2.Move = r2.RULE("Move", function() {
              s("Move"), r2.CONSUME(u.MOVE), r2.OPTION(function() {
                return r2.CONSUME(u.SILENT);
              }), r2.SUBRULE(r2.GraphOrDefault), r2.CONSUME(u.TO), r2.SUBRULE1(r2.GraphOrDefault);
            }), r2.Copy = r2.RULE("Copy", function() {
              s("Copy"), r2.CONSUME(u.COPY), r2.OPTION(function() {
                return r2.CONSUME(u.SILENT);
              }), r2.SUBRULE(r2.GraphOrDefault), r2.CONSUME(u.TO), r2.SUBRULE1(r2.GraphOrDefault);
            }), r2.InsertData = r2.RULE("InsertData", function() {
              s("InsertData"), r2.CONSUME(u.INSERT_DATA), r2.SUBRULE(r2.QuadData);
            }), r2.DeleteData = r2.RULE("DeleteData", function() {
              s("DeleteData"), r2.CONSUME(u.DELETE_DATA), r2.SUBRULE(r2.QuadData);
            }), r2.DeleteWhere = r2.RULE("DeleteWhere", function() {
              s("DeleteWhere"), r2.CONSUME(u.DELETE_WHERE), r2.SUBRULE(r2.QuadPattern);
            }), r2.Modify = r2.RULE("Modify", function() {
              s("Modify"), r2.OPTION(function() {
                r2.CONSUME(u.WITH), r2.SUBRULE(r2.iri);
              }), r2.OR([{ ALT: function() {
                r2.SUBRULE(r2.DeleteClause), r2.OPTION1(function() {
                  return r2.SUBRULE(r2.InsertClause);
                });
              } }, { ALT: function() {
                return r2.SUBRULE1(r2.InsertClause);
              } }]), r2.MANY(function() {
                return r2.SUBRULE(r2.UsingClause);
              }), r2.CONSUME(u.WHERE), r2.SUBRULE(r2.GroupGraphPattern);
            }), r2.DeleteClause = r2.RULE("DeleteClause", function() {
              s("DeleteClause"), r2.CONSUME(u.DELETE), r2.SUBRULE(r2.QuadPattern);
            }), r2.InsertClause = r2.RULE("InsertClause", function() {
              s("InsertClause"), r2.CONSUME(u.INSERT), r2.SUBRULE(r2.QuadPattern);
            }), r2.UsingClause = r2.RULE("UsingClause", function() {
              s("UsingClause"), r2.CONSUME(u.USING), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.iri);
              } }, { ALT: function() {
                r2.CONSUME(u.NAMED), r2.SUBRULE1(r2.iri);
              } }]);
            }), r2.GraphOrDefault = r2.RULE("GraphOrDefault", function() {
              s("GraphOrDefault"), r2.OR([{ ALT: function() {
                return r2.CONSUME(u.DEFAULT);
              } }, { ALT: function() {
                r2.OPTION(function() {
                  return r2.CONSUME(u.GRAPH);
                }), r2.SUBRULE(r2.iri);
              } }]);
            }), r2.GraphRef = r2.RULE("GraphRef", function() {
              s("GraphRef"), r2.CONSUME(u.GRAPH), r2.SUBRULE(r2.iri);
            }), r2.GraphRefAll = r2.RULE("GraphRefAll", function() {
              s("GraphRefAll"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.GraphRef);
              } }, { ALT: function() {
                return r2.CONSUME(u.DEFAULT);
              } }, { ALT: function() {
                return r2.CONSUME(u.NAMED);
              } }, { ALT: function() {
                return r2.CONSUME(u.ALL);
              } }]);
            }), r2.QuadPattern = r2.RULE("QuadPattern", function() {
              s("QuadPattern"), r2.CONSUME(u.LCurly), r2.SUBRULE(r2.Quads), r2.CONSUME(u.RCurly);
            }), r2.QuadData = r2.RULE("QuadData", function() {
              s("QuadData"), r2.CONSUME(u.LCurly), r2.SUBRULE(r2.Quads), r2.CONSUME(u.RCurly);
            }), r2.Quads = r2.RULE("Quads", function() {
              s("Quads"), r2.OPTION(function() {
                return r2.SUBRULE(r2.TriplesTemplate);
              }), r2.MANY(function() {
                r2.SUBRULE(r2.QuadsNotTriples), r2.OPTION1(function() {
                  return r2.CONSUME(u.Period);
                }), r2.OPTION2(function() {
                  return r2.SUBRULE1(r2.TriplesTemplate);
                });
              });
            }), r2.QuadsNotTriples = r2.RULE("QuadsNotTriples", function() {
              s("QuadsNotTriples"), r2.CONSUME(u.GRAPH), r2.SUBRULE(r2.VarOrIri), r2.CONSUME(u.LCurly), r2.OPTION(function() {
                return r2.SUBRULE(r2.TriplesTemplate);
              }), r2.CONSUME(u.RCurly);
            }), r2.TriplesTemplate = r2.RULE("TriplesTemplate", function() {
              s("TriplesTemplate"), r2.SUBRULE(r2.TriplesSameSubject), r2.OPTION(function() {
                r2.CONSUME(u.Period), r2.OPTION1(function() {
                  return r2.SUBRULE(r2.TriplesTemplate);
                });
              });
            }), r2.GroupGraphPattern = r2.RULE("GroupGraphPattern", function() {
              s("GroupGraphPattern"), r2.CONSUME(u.LCurly), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.SubSelect);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.GroupGraphPatternSub);
              } }]), r2.CONSUME(u.RCurly);
            }), r2.GroupGraphPatternSub = r2.RULE("GroupGraphPatternSub", function() {
              s("GroupGraphPatternSub"), r2.OPTION(function() {
                return r2.SUBRULE(r2.TriplesBlock);
              }), r2.MANY(function() {
                r2.SUBRULE(r2.GraphPatternNotTriples), r2.OPTION1(function() {
                  return r2.CONSUME(u.Period);
                }), r2.OPTION2(function() {
                  return r2.SUBRULE1(r2.TriplesBlock);
                });
              });
            }), r2.TriplesBlock = r2.RULE("TriplesBlock", function() {
              s("TriplesBlock"), r2.SUBRULE(r2.TriplesSameSubjectPath), r2.OPTION(function() {
                r2.CONSUME(u.Period), r2.OPTION1(function() {
                  return r2.SUBRULE(r2.TriplesBlock);
                });
              });
            }), r2.GraphPatternNotTriples = r2.RULE("GraphPatternNotTriples", function() {
              s("GraphPatternNotTriples"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.GroupOrUnionGraphPattern);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.OptionalGraphPattern);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.MinusGraphPattern);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.GraphGraphPattern);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.ServiceGraphPattern);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.Filter);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.Bind);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.InlineData);
              } }]);
            }), r2.OptionalGraphPattern = r2.RULE("OptionalGraphPattern", function() {
              s("OptionalGraphPattern"), r2.CONSUME(u.OPTIONAL), r2.SUBRULE(r2.GroupGraphPattern);
            }), r2.GraphGraphPattern = r2.RULE("GraphGraphPattern", function() {
              s("GraphGraphPattern"), r2.CONSUME(u.GRAPH), r2.SUBRULE(r2.VarOrIri), r2.SUBRULE(r2.GroupGraphPattern);
            }), r2.ServiceGraphPattern = r2.RULE("ServiceGraphPattern", function() {
              s("ServiceGraphPattern"), r2.CONSUME(u.SERVICE), r2.OPTION(function() {
                return r2.CONSUME(u.SILENT);
              }), r2.SUBRULE(r2.VarOrIri), r2.SUBRULE(r2.GroupGraphPattern);
            }), r2.Bind = r2.RULE("Bind", function() {
              s("Bind"), r2.CONSUME(u.BIND), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.AS), r2.SUBRULE(r2.Var), r2.CONSUME(u.RParen);
            }), r2.InlineData = r2.RULE("InlineData", function() {
              s("InlineData"), r2.CONSUME(u.VALUES), r2.SUBRULE(r2.DataBlock);
            }), r2.DataBlock = r2.RULE("DataBlock", function() {
              s("DataBlock"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.InlineDataOneVar);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.InlineDataFull);
              } }]);
            }), r2.InlineDataOneVar = r2.RULE("InlineDataOneVar", function() {
              s("InlineDataOneVar"), r2.SUBRULE(r2.Var), r2.CONSUME(u.LCurly), r2.MANY(function() {
                return r2.SUBRULE(r2.DataBlockValue);
              }), r2.CONSUME(u.RCurly);
            }), r2.InlineDataFull = r2.RULE("InlineDataFull", function() {
              s("InlineDataFull"), r2.OR([{ ALT: function() {
                return r2.CONSUME(u.NIL);
              } }, { ALT: function() {
                r2.CONSUME(u.LParen), r2.MANY(function() {
                  return r2.SUBRULE(r2.Var);
                }), r2.CONSUME(u.RParen);
              } }]), r2.CONSUME(u.LCurly), r2.MANY1(function() {
                return r2.OR1([{ ALT: function() {
                  r2.CONSUME1(u.LParen), r2.MANY2(function() {
                    return r2.SUBRULE(r2.DataBlockValue);
                  }), r2.CONSUME1(u.RParen);
                } }, { ALT: function() {
                  return r2.CONSUME1(u.NIL);
                } }]);
              }), r2.CONSUME(u.RCurly);
            }), r2.DataBlockValue = r2.RULE("DataBlockValue", function() {
              s("DataBlockValue"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.iri);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.RDFLiteral);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.NumericLiteral);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BooleanLiteral);
              } }, { ALT: function() {
                return r2.CONSUME(u.UNDEF);
              } }]);
            }), r2.MinusGraphPattern = r2.RULE("MinusGraphPattern", function() {
              s("MinusGraphPattern"), r2.CONSUME(u.MINUS), r2.SUBRULE(r2.GroupGraphPattern);
            }), r2.GroupOrUnionGraphPattern = r2.RULE("GroupOrUnionGraphPattern", function() {
              s("GroupOrUnionGraphPattern"), r2.SUBRULE(r2.GroupGraphPattern), r2.MANY(function() {
                r2.CONSUME(u.UNION), r2.SUBRULE1(r2.GroupGraphPattern);
              });
            }), r2.Filter = r2.RULE("Filter", function() {
              s("Filter"), r2.CONSUME(u.FILTER), r2.SUBRULE(r2.Constraint);
            }), r2.Constraint = r2.RULE("Constraint", function() {
              s("Constraint"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.BrackettedExpression);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.FunctionCall);
              } }]);
            }), r2.FunctionCall = r2.RULE("FunctionCall", function() {
              s("FunctionCall"), r2.SUBRULE(r2.iri), r2.SUBRULE(r2.ArgList);
            }), r2.ArgList = r2.RULE("ArgList", function() {
              s("ArgList"), r2.OR([{ ALT: function() {
                return r2.CONSUME(u.NIL);
              } }, { ALT: function() {
                r2.CONSUME(u.LParen), r2.OPTION(function() {
                  return r2.CONSUME(u.DISTINCT);
                }), r2.SUBRULE(r2.Expression), r2.MANY(function() {
                  r2.CONSUME(u.Comma), r2.SUBRULE1(r2.Expression);
                }), r2.CONSUME(u.RParen);
              } }]);
            }), r2.ExpressionList = r2.RULE("ExpressionList", function() {
              s("ExpressionList"), r2.OR([{ ALT: function() {
                return r2.CONSUME(u.NIL);
              } }, { ALT: function() {
                r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.MANY(function() {
                  r2.CONSUME(u.Comma), r2.SUBRULE1(r2.Expression);
                }), r2.CONSUME(u.RParen);
              } }]);
            }), r2.ConstructTemplate = r2.RULE("ConstructTemplate", function() {
              s("ConstructTemplate"), r2.CONSUME(u.LCurly), r2.OPTION(function() {
                return r2.SUBRULE(r2.ConstructTriples);
              }), r2.CONSUME(u.RCurly);
            }), r2.ConstructTriples = r2.RULE("ConstructTriples", function() {
              s("ConstructTriples"), r2.SUBRULE(r2.TriplesSameSubject), r2.OPTION(function() {
                r2.CONSUME(u.Period), r2.OPTION1(function() {
                  return r2.SUBRULE(r2.ConstructTriples);
                });
              });
            }), r2.TriplesSameSubject = r2.RULE("TriplesSameSubject", function() {
              s("TriplesSameSubject"), r2.OR([{ ALT: function() {
                r2.SUBRULE(r2.VarOrTerm), r2.SUBRULE(r2.PropertyListNotEmpty);
              } }, { ALT: function() {
                r2.SUBRULE(r2.TriplesNode), r2.SUBRULE(r2.PropertyList);
              } }]);
            }), r2.PropertyList = r2.RULE("PropertyList", function() {
              s("PropertyList"), r2.OPTION(function() {
                return r2.SUBRULE(r2.PropertyListNotEmpty);
              });
            }), r2.PropertyListNotEmpty = r2.RULE("PropertyListNotEmpty", function() {
              s("PropertyListNotEmpty"), r2.SUBRULE(r2.Verb), r2.SUBRULE(r2.ObjectList), r2.MANY(function() {
                r2.CONSUME(u.Semicolon), r2.OPTION(function() {
                  r2.SUBRULE1(r2.Verb), r2.SUBRULE1(r2.ObjectList);
                });
              });
            }), r2.Verb = r2.RULE("Verb", function() {
              s("Verb"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.VarOrIri);
              } }, { ALT: function() {
                return r2.CONSUME(u.A);
              } }]);
            }), r2.ObjectList = r2.RULE("ObjectList", function() {
              s("ObjectList"), r2.AT_LEAST_ONE_SEP({ SEP: u.Comma, DEF: function() {
                return r2.SUBRULE(r2.Object);
              } });
            }), r2.Object = r2.RULE("Object", function() {
              s("Object"), r2.SUBRULE(r2.GraphNode);
            }), r2.TriplesSameSubjectPath = r2.RULE("TriplesSameSubjectPath", function() {
              s("TriplesSameSubjectPath"), r2.OR([{ ALT: function() {
                r2.SUBRULE(r2.VarOrTerm), r2.SUBRULE(r2.PropertyListPathNotEmpty);
              } }, { ALT: function() {
                r2.SUBRULE(r2.TriplesNodePath), r2.SUBRULE(r2.PropertyListPath);
              } }]);
            }), r2.PropertyListPath = r2.RULE("PropertyListPath", function() {
              s("PropertyListPath"), r2.OPTION(function() {
                return r2.SUBRULE(r2.PropertyListPathNotEmpty);
              });
            }), r2.PropertyListPathNotEmpty = r2.RULE("PropertyListPathNotEmpty", function() {
              s("PropertyListPathNotEmpty"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.VerbPath);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.VerbSimple);
              } }]), r2.SUBRULE(r2.ObjectListPath), r2.MANY(function() {
                r2.CONSUME(u.Semicolon), r2.OPTION(function() {
                  r2.OR1([{ ALT: function() {
                    return r2.SUBRULE1(r2.VerbPath);
                  } }, { ALT: function() {
                    return r2.SUBRULE1(r2.VerbSimple);
                  } }]), r2.SUBRULE1(r2.ObjectListPath);
                });
              });
            }), r2.VerbPath = r2.RULE("VerbPath", function() {
              s("VerbPath"), r2.SUBRULE(r2.Path);
            }), r2.VerbSimple = r2.RULE("VerbSimple", function() {
              s("VerbSimple"), r2.SUBRULE(r2.Var);
            }), r2.ObjectListPath = r2.RULE("ObjectListPath", function() {
              s("ObjectListPath"), r2.AT_LEAST_ONE_SEP({ SEP: u.Comma, DEF: function() {
                return r2.SUBRULE(r2.ObjectPath);
              } });
            }), r2.ObjectPath = r2.RULE("ObjectPath", function() {
              s("ObjectPath"), r2.SUBRULE(r2.GraphNodePath);
            }), r2.Path = r2.RULE("Path", function() {
              s("Path"), r2.SUBRULE(r2.PathAlternative);
            }), r2.PathAlternative = r2.RULE("PathAlternative", function() {
              s("PathAlternative"), r2.AT_LEAST_ONE_SEP({ SEP: u.Pipe, DEF: function() {
                return r2.SUBRULE(r2.PathSequence);
              } });
            }), r2.PathSequence = r2.RULE("PathSequence", function() {
              s("PathSequence"), r2.AT_LEAST_ONE_SEP({ SEP: u.ForwardSlash, DEF: function() {
                return r2.SUBRULE(r2.PathEltOrInverse);
              } });
            }), r2.PathElt = r2.RULE("PathElt", function() {
              s("PathElt"), r2.SUBRULE(r2.PathPrimary), r2.OPTION(function() {
                return r2.SUBRULE(r2.PathMod);
              });
            }), r2.PathEltOrInverse = r2.RULE("PathEltOrInverse", function() {
              s("PathEltOrInverse"), r2.OPTION(function() {
                return r2.CONSUME(u.Caret);
              }), r2.SUBRULE(r2.PathElt);
            }), r2.PathMod = r2.RULE("PathMod", function() {
              s("PathMod"), r2.OR([{ ALT: function() {
                return r2.CONSUME(u.QuestionMark);
              } }, { ALT: function() {
                return r2.CONSUME(u.Star);
              } }, { ALT: function() {
                return r2.CONSUME(u.Plus);
              } }]);
            }), r2.PathPrimary = r2.RULE("PathPrimary", function() {
              s("PathPrimary"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.iri);
              } }, { ALT: function() {
                return r2.CONSUME(u.A);
              } }, { ALT: function() {
                r2.CONSUME(u.Bang), r2.SUBRULE(r2.PathNegatedPropertySet);
              } }, { ALT: function() {
                r2.CONSUME(u.LParen), r2.SUBRULE(r2.Path), r2.CONSUME(u.RParen);
              } }]);
            }), r2.PathNegatedPropertySet = r2.RULE("PathNegatedPropertySet", function() {
              s("PathNegatedPropertySet"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.PathOneInPropertySet);
              } }, { ALT: function() {
                r2.CONSUME(u.LParen), r2.MANY_SEP({ SEP: u.Pipe, DEF: function() {
                  return r2.SUBRULE1(r2.PathOneInPropertySet);
                } }), r2.CONSUME(u.RParen);
              } }]);
            }), r2.PathOneInPropertySet = r2.RULE("PathOneInPropertySet", function() {
              s("PathOneInPropertySet"), r2.OPTION(function() {
                return r2.CONSUME(u.Caret);
              }), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.iri);
              } }, { ALT: function() {
                return r2.CONSUME(u.A);
              } }]);
            }), r2.Integer = r2.RULE("Integer", function() {
              s("Integer"), r2.CONSUME(u.INTEGER);
            }), r2.TriplesNode = r2.RULE("TriplesNode", function() {
              s("TriplesNode"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.Collection);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BlankNodePropertyList);
              } }]);
            }), r2.BlankNodePropertyList = r2.RULE("BlankNodePropertyList", function() {
              s("BlankNodePropertyList"), r2.CONSUME(u.LBracket), r2.SUBRULE(r2.PropertyListNotEmpty), r2.CONSUME(u.RBracket);
            }), r2.TriplesNodePath = r2.RULE("TriplesNodePath", function() {
              s("TriplesNodePath"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.CollectionPath);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BlankNodePropertyListPath);
              } }]);
            }), r2.BlankNodePropertyListPath = r2.RULE("BlankNodePropertyListPath", function() {
              s("BlankNodePropertyListPath"), r2.CONSUME(u.LBracket), r2.SUBRULE(r2.PropertyListPathNotEmpty), r2.CONSUME(u.RBracket);
            }), r2.Collection = r2.RULE("Collection", function() {
              s("Collection"), r2.CONSUME(u.LParen), r2.AT_LEAST_ONE(function() {
                return r2.SUBRULE(r2.GraphNode);
              }), r2.CONSUME(u.RParen);
            }), r2.CollectionPath = r2.RULE("CollectionPath", function() {
              s("CollectionPath"), r2.CONSUME(u.LParen), r2.AT_LEAST_ONE(function() {
                return r2.SUBRULE(r2.GraphNodePath);
              }), r2.CONSUME(u.RParen);
            }), r2.GraphNode = r2.RULE("GraphNode", function() {
              s("GraphNode"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.VarOrTerm);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.TriplesNode);
              } }]);
            }), r2.GraphNodePath = r2.RULE("GraphNodePath", function() {
              s("GraphNodePath"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.VarOrTerm);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.TriplesNodePath);
              } }]);
            }), r2.VarOrTerm = r2.RULE("VarOrTerm", function() {
              s("VarOrTerm"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.Var);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.GraphTerm);
              } }]);
            }), r2.VarOrIri = r2.RULE("VarOrIri", function() {
              s("VarOrIri"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.Var);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.iri);
              } }]);
            }), r2.Var = r2.RULE("Var", function() {
              s("Var"), r2.OR([{ ALT: function() {
                return r2.CONSUME(u.VAR1);
              } }, { ALT: function() {
                return r2.CONSUME(u.VAR2);
              } }]);
            }), r2.GraphTerm = r2.RULE("GraphTerm", function() {
              s("GraphTerm"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.iri);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.RDFLiteral);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.NumericLiteral);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BooleanLiteral);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BlankNode);
              } }, { ALT: function() {
                return r2.CONSUME(u.NIL);
              } }]);
            }), r2.Expression = r2.RULE("Expression", function() {
              s("Expression"), r2.SUBRULE(r2.ConditionalOrExpression);
            }), r2.ConditionalOrExpression = r2.RULE("ConditionalOrExpression", function() {
              s("ConditionalOrExpression"), r2.AT_LEAST_ONE_SEP({ SEP: u.LogicalOr, DEF: function() {
                return r2.SUBRULE(r2.ConditionalAndExpression);
              } });
            }), r2.ConditionalAndExpression = r2.RULE("ConditionalAndExpression", function() {
              s("ConditionalAndExpression"), r2.AT_LEAST_ONE_SEP({ SEP: u.LogicalAnd, DEF: function() {
                return r2.SUBRULE(r2.ValueLogical);
              } });
            }), r2.ValueLogical = r2.RULE("ValueLogical", function() {
              s("ValueLogical"), r2.SUBRULE(r2.RelationalExpression);
            }), r2.RelationalExpression = r2.RULE("RelationalExpression", function() {
              s("RelationalExpression"), r2.SUBRULE(r2.NumericExpression), r2.OPTION(function() {
                return r2.OR([{ ALT: function() {
                  r2.OR1([{ ALT: function() {
                    return r2.CONSUME(u.Equals);
                  } }, { ALT: function() {
                    return r2.CONSUME(u.NotEquals);
                  } }, { ALT: function() {
                    return r2.CONSUME(u.LessThan);
                  } }, { ALT: function() {
                    return r2.CONSUME(u.GreaterThan);
                  } }, { ALT: function() {
                    return r2.CONSUME(u.LessThanEquals);
                  } }, { ALT: function() {
                    return r2.CONSUME(u.GreaterThanEquals);
                  } }]), r2.SUBRULE1(r2.NumericExpression);
                } }, { ALT: function() {
                  r2.CONSUME(u.IN), r2.SUBRULE(r2.ExpressionList);
                } }, { ALT: function() {
                  r2.CONSUME(u.NOT_IN), r2.SUBRULE1(r2.ExpressionList);
                } }]);
              });
            }), r2.NumericExpression = r2.RULE("NumericExpression", function() {
              s("NumericExpression"), r2.SUBRULE(r2.AdditiveExpression);
            }), r2.AdditiveExpression = r2.RULE("AdditiveExpression", function() {
              s("AdditiveExpression"), r2.SUBRULE(r2.MultiplicativeExpression), r2.MANY(function() {
                return r2.OR([{ ALT: function() {
                  r2.OR1([{ ALT: function() {
                    return r2.CONSUME(u.Plus);
                  } }, { ALT: function() {
                    return r2.CONSUME(u.Minus);
                  } }]), r2.SUBRULE1(r2.MultiplicativeExpression);
                } }, { ALT: function() {
                  r2.OR2([{ ALT: function() {
                    return r2.SUBRULE(r2.NumericLiteralPositive);
                  } }, { ALT: function() {
                    return r2.SUBRULE(r2.NumericLiteralNegative);
                  } }]), r2.MANY1(function() {
                    return r2.OR3([{ ALT: function() {
                      r2.OR4([{ ALT: function() {
                        return r2.CONSUME(u.Star);
                      } }, { ALT: function() {
                        return r2.CONSUME(u.ForwardSlash);
                      } }]), r2.SUBRULE1(r2.UnaryExpression);
                    } }]);
                  });
                } }]);
              });
            }), r2.MultiplicativeExpression = r2.RULE("MultiplicativeExpression", function() {
              s("MultiplicativeExpression"), r2.SUBRULE(r2.UnaryExpression), r2.MANY(function() {
                return r2.OR([{ ALT: function() {
                  r2.CONSUME(u.Star), r2.SUBRULE1(r2.UnaryExpression);
                } }, { ALT: function() {
                  r2.CONSUME(u.ForwardSlash), r2.SUBRULE2(r2.UnaryExpression);
                } }]);
              });
            }), r2.UnaryExpression = r2.RULE("UnaryExpression", function() {
              s("UnaryExpression"), r2.OR([{ ALT: function() {
                r2.CONSUME(u.Bang), r2.SUBRULE(r2.PrimaryExpression);
              } }, { ALT: function() {
                r2.CONSUME(u.Plus), r2.SUBRULE1(r2.PrimaryExpression);
              } }, { ALT: function() {
                r2.CONSUME(u.Minus), r2.SUBRULE2(r2.PrimaryExpression);
              } }, { ALT: function() {
                return r2.SUBRULE3(r2.PrimaryExpression);
              } }]);
            }), r2.PrimaryExpression = r2.RULE("PrimaryExpression", function() {
              s("PrimaryExpression"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.BrackettedExpression);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.iriOrFunction);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.RDFLiteral);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.NumericLiteral);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BooleanLiteral);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.Var);
              } }]);
            }), r2.BrackettedExpression = r2.RULE("BrackettedExpression", function() {
              s("BrackettedExpression"), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_STR = r2.RULE("BuiltInCall_STR", function() {
              s("BuiltInCall_STR"), r2.CONSUME(u.STR), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_LANG = r2.RULE("BuiltInCall_LANG", function() {
              s("BuiltInCall_LANG"), r2.CONSUME(u.LANG), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_LANGMATCHES = r2.RULE("BuiltInCall_LANGMATCHES", function() {
              s("BuiltInCall_LANGMATCHES"), r2.CONSUME(u.LANGMATCHES), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.Comma), r2.SUBRULE1(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_DATATYPE = r2.RULE("BuiltInCall_DATATYPE", function() {
              s("BuiltInCall_DATATYPE"), r2.CONSUME(u.DATATYPE), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_BOUND = r2.RULE("BuiltInCall_BOUND", function() {
              s("BuiltInCall_BOUND"), r2.CONSUME(u.BOUND), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Var), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_IRI = r2.RULE("BuiltInCall_IRI", function() {
              s("BuiltInCall_IRI"), r2.CONSUME(u.IRI), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_URI = r2.RULE("BuiltInCall_URI", function() {
              s("BuiltInCall_URI"), r2.CONSUME(u.URI), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_BNODE = r2.RULE("BuiltInCall_BNODE", function() {
              s("BuiltInCall_BNODE"), r2.CONSUME(u.BNODE), r2.OR([{ ALT: function() {
                r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
              } }, { ALT: function() {
                return r2.CONSUME(u.NIL);
              } }]);
            }), r2.BuiltInCall_RAND = r2.RULE("BuiltInCall_RAND", function() {
              s("BuiltInCall_RAND"), r2.CONSUME(u.RAND), r2.CONSUME(u.NIL);
            }), r2.BuiltInCall_ABS = r2.RULE("BuiltInCall_ABS", function() {
              s("BuiltInCall_ABS"), r2.CONSUME(u.ABS), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_CEIL = r2.RULE("BuiltInCall_CEIL", function() {
              s("BuiltInCall_CEIL"), r2.CONSUME(u.CEIL), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_FLOOR = r2.RULE("BuiltInCall_FLOOR", function() {
              s("BuiltInCall_FLOOR"), r2.CONSUME(u.FLOOR), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_ROUND = r2.RULE("BuiltInCall_ROUND", function() {
              s("BuiltInCall_ROUND"), r2.CONSUME(u.ROUND), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_CONCAT = r2.RULE("BuiltInCall_CONCAT", function() {
              s("BuiltInCall_CONCAT"), r2.CONSUME(u.CONCAT), r2.SUBRULE(r2.ExpressionList);
            }), r2.BuiltInCall_STRLEN = r2.RULE("BuiltInCall_STRLEN", function() {
              s("BuiltInCall_STRLEN"), r2.CONSUME(u.STRLEN), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_UCASE = r2.RULE("BuiltInCall_UCASE", function() {
              s("BuiltInCall_UCASE"), r2.CONSUME(u.UCASE), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_LCASE = r2.RULE("BuiltInCall_LCASE", function() {
              s("BuiltInCall_LCASE"), r2.CONSUME(u.LCASE), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_ENCODE_FOR_URI = r2.RULE("BuiltInCall_ENCODE_FOR_URI", function() {
              s("BuiltInCall_ENCODE_FOR_URI"), r2.CONSUME(u.ENCODE_FOR_URI), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_CONTAINS = r2.RULE("BuiltInCall_CONTAINS", function() {
              s("BuiltInCall_CONTAINS"), r2.CONSUME(u.CONTAINS), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.Comma), r2.SUBRULE1(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_STRSTARTS = r2.RULE("BuiltInCall_STRSTARTS", function() {
              s("BuiltInCall_STRSTARTS"), r2.CONSUME(u.STRSTARTS), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.Comma), r2.SUBRULE1(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_STRENDS = r2.RULE("BuiltInCall_STRENDS", function() {
              s("BuiltInCall_STRENDS"), r2.CONSUME(u.STRENDS), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.Comma), r2.SUBRULE1(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_STRBEFORE = r2.RULE("BuiltInCall_STRBEFORE", function() {
              s("BuiltInCall_STRBEFORE"), r2.CONSUME(u.STRBEFORE), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.Comma), r2.SUBRULE1(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_STRAFTER = r2.RULE("BuiltInCall_STRAFTER", function() {
              s("BuiltInCall_STRAFTER"), r2.CONSUME(u.STRAFTER), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.Comma), r2.SUBRULE1(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_YEAR = r2.RULE("BuiltInCall_YEAR", function() {
              s("BuiltInCall_YEAR"), r2.CONSUME(u.YEAR), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_MONTH = r2.RULE("BuiltInCall_MONTH", function() {
              s("BuiltInCall_MONTH"), r2.CONSUME(u.MONTH), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_DAY = r2.RULE("BuiltInCall_DAY", function() {
              s("BuiltInCall_DAY"), r2.CONSUME(u.DAY), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_HOURS = r2.RULE("BuiltInCall_HOURS", function() {
              s("BuiltInCall_HOURS"), r2.CONSUME(u.HOURS), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_MINUTES = r2.RULE("BuiltInCall_MINUTES", function() {
              s("BuiltInCall_MINUTES"), r2.CONSUME(u.MINUTES), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_SECONDS = r2.RULE("BuiltInCall_SECONDS", function() {
              s("BuiltInCall_SECONDS"), r2.CONSUME(u.SECONDS), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_TIMEZONE = r2.RULE("BuiltInCall_TIMEZONE", function() {
              s("BuiltInCall_TIMEZONE"), r2.CONSUME(u.TIMEZONE), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_TZ = r2.RULE("BuiltInCall_TZ", function() {
              s("BuiltInCall_TZ"), r2.CONSUME(u.TZ), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_NOW = r2.RULE("BuiltInCall_NOW", function() {
              s("BuiltInCall_NOW"), r2.CONSUME(u.NOW), r2.CONSUME(u.NIL);
            }), r2.BuiltInCall_UUID = r2.RULE("BuiltInCall_UUID", function() {
              s("BuiltInCall_UUID"), r2.CONSUME(u.UUID), r2.CONSUME(u.NIL);
            }), r2.BuiltInCall_STRUUID = r2.RULE("BuiltInCall_STRUUID", function() {
              s("BuiltInCall_STRUUID"), r2.CONSUME(u.STRUUID), r2.CONSUME(u.NIL);
            }), r2.BuiltInCall_MD5 = r2.RULE("BuiltInCall_MD5", function() {
              s("BuiltInCall_MD5"), r2.CONSUME(u.MD5), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_SHA1 = r2.RULE("BuiltInCall_SHA1", function() {
              s("BuiltInCall_SHA1"), r2.CONSUME(u.SHA1), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_SHA256 = r2.RULE("BuiltInCall_SHA256", function() {
              s("BuiltInCall_SHA256"), r2.CONSUME(u.SHA256), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_SHA384 = r2.RULE("BuiltInCall_SHA384", function() {
              s("BuiltInCall_SHA384"), r2.CONSUME(u.SHA384), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_SHA512 = r2.RULE("BuiltInCall_SHA512", function() {
              s("BuiltInCall_SHA512"), r2.CONSUME(u.SHA512), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_COALESCE = r2.RULE("BuiltInCall_COALESCE", function() {
              s("BuiltInCall_COALESCE"), r2.CONSUME(u.COALESCE), r2.SUBRULE(r2.ExpressionList);
            }), r2.BuiltInCall_IF = r2.RULE("BuiltInCall_IF", function() {
              s("BuiltInCall_IF"), r2.CONSUME(u.IF), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.Comma), r2.SUBRULE1(r2.Expression), r2.CONSUME1(u.Comma), r2.SUBRULE2(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_STRLANG = r2.RULE("BuiltInCall_STRLANG", function() {
              s("BuiltInCall_STRLANG"), r2.CONSUME(u.STRLANG), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.Comma), r2.SUBRULE1(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_STRDT = r2.RULE("BuiltInCall_STRDT", function() {
              s("BuiltInCall_STRDT"), r2.CONSUME(u.STRDT), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.Comma), r2.SUBRULE1(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_sameTerm = r2.RULE("BuiltInCall_sameTerm", function() {
              s("BuiltInCall_sameTerm"), r2.CONSUME(u.sameTerm), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.Comma), r2.SUBRULE1(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_isIRI = r2.RULE("BuiltInCall_isIRI", function() {
              s("BuiltInCall_isIRI"), r2.CONSUME(u.isIRI), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_isURI = r2.RULE("BuiltInCall_isURI", function() {
              s("BuiltInCall_isURI"), r2.CONSUME(u.isURI), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_isBLANK = r2.RULE("BuiltInCall_isBLANK", function() {
              s("BuiltInCall_isBLANK"), r2.CONSUME(u.isBLANK), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_isLITERAL = r2.RULE("BuiltInCall_isLITERAL", function() {
              s("BuiltInCall_isLITERAL"), r2.CONSUME(u.isLITERAL), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall_isNUMERIC = r2.RULE("BuiltInCall_isNUMERIC", function() {
              s("BuiltInCall_isNUMERIC"), r2.CONSUME(u.isNUMERIC), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.BuiltInCall = r2.RULE("BuiltInCall", function() {
              s("BuiltInCall"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.Aggregate);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_STR);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_LANG);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_LANGMATCHES);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_DATATYPE);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_BOUND);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_IRI);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_URI);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_BNODE);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_RAND);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_ABS);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_CEIL);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_FLOOR);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_ROUND);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_CONCAT);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.SubstringExpression);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_STRLEN);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.StrReplaceExpression);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_UCASE);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_LCASE);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_ENCODE_FOR_URI);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_CONTAINS);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_STRSTARTS);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_STRENDS);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_STRBEFORE);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_STRAFTER);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_YEAR);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_MONTH);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_DAY);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_HOURS);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_MINUTES);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_SECONDS);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_TIMEZONE);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_TZ);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_NOW);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_UUID);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_STRUUID);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_MD5);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_SHA1);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_SHA256);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_SHA384);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_SHA512);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_COALESCE);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_IF);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_STRLANG);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_STRDT);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_sameTerm);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_isIRI);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_isURI);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_isBLANK);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_isLITERAL);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BuiltInCall_isNUMERIC);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.RegexExpression);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.ExistsFunction);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.NotExistsFunction);
              } }]);
            }), r2.RegexExpression = r2.RULE("RegexExpression", function() {
              s("RegexExpression"), r2.CONSUME(u.REGEX), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.Comma), r2.SUBRULE1(r2.Expression), r2.OPTION(function() {
                r2.CONSUME1(u.Comma), r2.SUBRULE2(r2.Expression);
              }), r2.CONSUME(u.RParen);
            }), r2.SubstringExpression = r2.RULE("SubstringExpression", function() {
              s("SubstringExpression"), r2.CONSUME(u.SUBSTR), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.Comma), r2.SUBRULE1(r2.Expression), r2.OPTION(function() {
                r2.CONSUME1(u.Comma), r2.SUBRULE2(r2.Expression);
              }), r2.CONSUME(u.RParen);
            }), r2.StrReplaceExpression = r2.RULE("StrReplaceExpression", function() {
              s("StrReplaceExpression"), r2.CONSUME(u.REPLACE), r2.CONSUME(u.LParen), r2.SUBRULE(r2.Expression), r2.CONSUME(u.Comma), r2.SUBRULE1(r2.Expression), r2.CONSUME1(u.Comma), r2.SUBRULE2(r2.Expression), r2.OPTION(function() {
                r2.CONSUME2(u.Comma), r2.SUBRULE3(r2.Expression);
              }), r2.CONSUME(u.RParen);
            }), r2.ExistsFunction = r2.RULE("ExistsFunction", function() {
              s("ExistsFunction"), r2.CONSUME(u.EXISTS), r2.SUBRULE(r2.GroupGraphPattern);
            }), r2.NotExistsFunction = r2.RULE("NotExistsFunction", function() {
              s("NotExistsFunction"), r2.CONSUME(u.NOT_EXISTS), r2.SUBRULE(r2.GroupGraphPattern);
            }), r2.Count = r2.RULE("Count", function() {
              s("Count"), r2.CONSUME(u.COUNT), r2.CONSUME1(u.LParen), r2.OPTION(function() {
                return r2.CONSUME2(u.DISTINCT);
              }), r2.OR([{ ALT: function() {
                return r2.CONSUME3(u.Star);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.Expression);
              } }]), r2.CONSUME(u.RParen);
            }), r2.Sum = r2.RULE("Sum", function() {
              s("Sum"), r2.CONSUME(u.SUM), r2.CONSUME1(u.LParen), r2.OPTION(function() {
                return r2.CONSUME2(u.DISTINCT);
              }), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.Min = r2.RULE("Min", function() {
              s("Min"), r2.CONSUME(u.MIN), r2.CONSUME1(u.LParen), r2.OPTION(function() {
                return r2.CONSUME2(u.DISTINCT);
              }), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.Max = r2.RULE("Max", function() {
              s("Max"), r2.CONSUME(u.MAX), r2.CONSUME1(u.LParen), r2.OPTION(function() {
                return r2.CONSUME2(u.DISTINCT);
              }), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.Avg = r2.RULE("Avg", function() {
              s("Avg"), r2.CONSUME(u.AVG), r2.CONSUME1(u.LParen), r2.OPTION(function() {
                return r2.CONSUME2(u.DISTINCT);
              }), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.Sample = r2.RULE("Sample", function() {
              s("Sample"), r2.CONSUME(u.SAMPLE), r2.CONSUME1(u.LParen), r2.OPTION(function() {
                return r2.CONSUME2(u.DISTINCT);
              }), r2.SUBRULE(r2.Expression), r2.CONSUME(u.RParen);
            }), r2.GroupConcat = r2.RULE("GroupConcat", function() {
              s("GroupConcat"), r2.CONSUME(u.GROUP_CONCAT), r2.CONSUME1(u.LParen), r2.OPTION(function() {
                return r2.CONSUME2(u.DISTINCT);
              }), r2.SUBRULE(r2.Expression), r2.OPTION1(function() {
                r2.CONSUME(u.Semicolon), r2.CONSUME(u.SEPARATOR), r2.CONSUME(u.Equals), r2.SUBRULE(r2.String);
              }), r2.CONSUME(u.RParen);
            }), r2.Aggregate = r2.RULE("Aggregate", function() {
              s("Aggregate"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.Count);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.Sum);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.Min);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.Max);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.Avg);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.Sample);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.GroupConcat);
              } }]);
            }), r2.iriOrFunction = r2.RULE("iriOrFunction", function() {
              s("iriOrFunction"), r2.SUBRULE(r2.iri), r2.OPTION(function() {
                return r2.SUBRULE(r2.ArgList);
              });
            }), r2.RDFLiteral = r2.RULE("RDFLiteral", function() {
              s("RDFLiteral"), r2.SUBRULE(r2.String), r2.OPTION(function() {
                return r2.OR([{ ALT: function() {
                  return r2.CONSUME(u.LANGTAG);
                } }, { ALT: function() {
                  r2.CONSUME(u.DoubleCaret), r2.SUBRULE(r2.iri);
                } }]);
              });
            }), r2.NumericLiteral = r2.RULE("NumericLiteral", function() {
              s("NumericLiteral"), r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.NumericLiteralUnsigned);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.NumericLiteralPositive);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.NumericLiteralNegative);
              } }]);
            }), r2.NumericLiteralUnsigned = r2.RULE("NumericLiteralUnsigned", function() {
              s("NumericLiteralUnsigned"), r2.OR([{ ALT: function() {
                return r2.CONSUME(u.INTEGER);
              } }, { ALT: function() {
                return r2.CONSUME(u.DECIMAL);
              } }, { ALT: function() {
                return r2.CONSUME(u.DOUBLE);
              } }]);
            }), r2.NumericLiteralPositive = r2.RULE("NumericLiteralPositive", function() {
              s("NumericLiteralPositive"), r2.OR([{ ALT: function() {
                return r2.CONSUME(u.INTEGER_POSITIVE);
              } }, { ALT: function() {
                return r2.CONSUME(u.DECIMAL_POSITIVE);
              } }, { ALT: function() {
                return r2.CONSUME(u.DOUBLE_POSITIVE);
              } }]);
            }), r2.NumericLiteralNegative = r2.RULE("NumericLiteralNegative", function() {
              s("NumericLiteralNegative"), r2.OR([{ ALT: function() {
                return r2.CONSUME(u.INTEGER_NEGATIVE);
              } }, { ALT: function() {
                return r2.CONSUME(u.DECIMAL_NEGATIVE);
              } }, { ALT: function() {
                return r2.CONSUME(u.DOUBLE_NEGATIVE);
              } }]);
            }), r2.BooleanLiteral = r2.RULE("BooleanLiteral", function() {
              s("BooleanLiteral"), r2.OR([{ ALT: function() {
                return r2.CONSUME(u.TRUE);
              } }, { ALT: function() {
                return r2.CONSUME(u.FALSE);
              } }]);
            }), r2.String = r2.RULE("String", function() {
              s("String"), r2.OR([{ ALT: function() {
                return r2.CONSUME(u.STRING_LITERAL1);
              } }, { ALT: function() {
                return r2.CONSUME(u.STRING_LITERAL2);
              } }, { ALT: function() {
                return r2.CONSUME(u.STRING_LITERAL_LONG1);
              } }, { ALT: function() {
                return r2.CONSUME(u.STRING_LITERAL_LONG2);
              } }]);
            }), r2.iri = r2.RULE("iri", function() {
              s("iri"), r2.OR([{ ALT: function() {
                return r2.CONSUME(u.IRIREF);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.PrefixedName);
              } }]);
            }), r2.PrefixedName = r2.RULE("PrefixedName", function() {
              s("PrefixedName"), r2.OR([{ ALT: function() {
                return r2.CONSUME(u.PNAME_LN);
              } }, { ALT: function() {
                return r2.CONSUME(u.PNAME_NS);
              } }]);
            }), r2.BlankNode = r2.RULE("BlankNode", function() {
              s("BlankNode"), r2.OR([{ ALT: function() {
                return r2.CONSUME(u.BLANK_NODE_LABEL);
              } }, { ALT: function() {
                return r2.CONSUME(u.ANON);
              } }]);
            }), r2.lexer = new i.Lexer(n2), r2;
          }
          return o(BaseSparqlParser2, t2), BaseSparqlParser2;
        }(i.Parser);
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(4), i = n(6), o = function() {
          function t2() {
          }
          return t2.prototype.walk = function(t3, e2) {
            var n2 = this;
            void 0 === e2 && (e2 = []), r.forEach(t3.definition, function(o2, a2) {
              var u = r.drop(t3.definition, a2 + 1);
              if (o2 instanceof i.NonTerminal)
                n2.walkProdRef(o2, u, e2);
              else if (o2 instanceof i.Terminal)
                n2.walkTerminal(o2, u, e2);
              else if (o2 instanceof i.Flat)
                n2.walkFlat(o2, u, e2);
              else if (o2 instanceof i.Option)
                n2.walkOption(o2, u, e2);
              else if (o2 instanceof i.RepetitionMandatory)
                n2.walkAtLeastOne(o2, u, e2);
              else if (o2 instanceof i.RepetitionMandatoryWithSeparator)
                n2.walkAtLeastOneSep(o2, u, e2);
              else if (o2 instanceof i.RepetitionWithSeparator)
                n2.walkManySep(o2, u, e2);
              else if (o2 instanceof i.Repetition)
                n2.walkMany(o2, u, e2);
              else {
                if (!(o2 instanceof i.Alternation))
                  throw Error("non exhaustive match");
                n2.walkOr(o2, u, e2);
              }
            });
          }, t2.prototype.walkTerminal = function(t3, e2, n2) {
          }, t2.prototype.walkProdRef = function(t3, e2, n2) {
          }, t2.prototype.walkFlat = function(t3, e2, n2) {
            var r2 = e2.concat(n2);
            this.walk(t3, r2);
          }, t2.prototype.walkOption = function(t3, e2, n2) {
            var r2 = e2.concat(n2);
            this.walk(t3, r2);
          }, t2.prototype.walkAtLeastOne = function(t3, e2, n2) {
            var r2 = [new i.Option({ definition: t3.definition })].concat(e2, n2);
            this.walk(t3, r2);
          }, t2.prototype.walkAtLeastOneSep = function(t3, e2, n2) {
            var r2 = a(t3, e2, n2);
            this.walk(t3, r2);
          }, t2.prototype.walkMany = function(t3, e2, n2) {
            var r2 = [new i.Option({ definition: t3.definition })].concat(e2, n2);
            this.walk(t3, r2);
          }, t2.prototype.walkManySep = function(t3, e2, n2) {
            var r2 = a(t3, e2, n2);
            this.walk(t3, r2);
          }, t2.prototype.walkOr = function(t3, e2, n2) {
            var o2 = this, a2 = e2.concat(n2);
            r.forEach(t3.definition, function(t4) {
              var e3 = new i.Flat({ definition: [t4] });
              o2.walk(e3, a2);
            });
          }, t2;
        }();
        function a(t2, e2, n2) {
          return [new i.Option({ definition: [new i.Terminal({ terminalType: t2.separator })].concat(t2.definition) })].concat(e2, n2);
        }
        e.RestWalker = o;
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(38), i = n(4), o = n(14), a = n(29);
        !function(t2) {
          t2[t2.MISSING_PATTERN = 0] = "MISSING_PATTERN", t2[t2.INVALID_PATTERN = 1] = "INVALID_PATTERN", t2[t2.EOI_ANCHOR_FOUND = 2] = "EOI_ANCHOR_FOUND", t2[t2.UNSUPPORTED_FLAGS_FOUND = 3] = "UNSUPPORTED_FLAGS_FOUND", t2[t2.DUPLICATE_PATTERNS_FOUND = 4] = "DUPLICATE_PATTERNS_FOUND", t2[t2.INVALID_GROUP_TYPE_FOUND = 5] = "INVALID_GROUP_TYPE_FOUND", t2[t2.PUSH_MODE_DOES_NOT_EXIST = 6] = "PUSH_MODE_DOES_NOT_EXIST", t2[t2.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE", t2[t2.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY", t2[t2.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST", t2[t2.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED", t2[t2.SOI_ANCHOR_FOUND = 11] = "SOI_ANCHOR_FOUND", t2[t2.EMPTY_MATCH_PATTERN = 12] = "EMPTY_MATCH_PATTERN", t2[t2.NO_LINE_BREAKS_FLAGS = 13] = "NO_LINE_BREAKS_FLAGS", t2[t2.UNREACHABLE_PATTERN = 14] = "UNREACHABLE_PATTERN", t2[t2.IDENTIFY_TERMINATOR = 15] = "IDENTIFY_TERMINATOR", t2[t2.CUSTOM_LINE_BREAK = 16] = "CUSTOM_LINE_BREAK";
        }(e.LexerDefinitionErrorType || (e.LexerDefinitionErrorType = {}));
        var u = { deferDefinitionErrorsHandling: false, positionTracking: "full", lineTerminatorsPattern: /\n|\r\n?/g, lineTerminatorCharacters: ["\n", "\r"], ensureOptimizations: false, safeMode: false, errorMessageProvider: a.defaultLexerErrorProvider };
        Object.freeze(u);
        var s = function() {
          function t2(t3, e2) {
            var n2 = this;
            if (void 0 === e2 && (e2 = u), this.lexerDefinition = t3, this.lexerDefinitionErrors = [], this.lexerDefinitionWarning = [], this.patternIdxToConfig = {}, this.charCodeToPatternIdxToConfig = {}, this.modes = [], this.emptyGroups = {}, this.config = void 0, this.trackStartLines = true, this.trackEndLines = true, this.hasCustom = false, this.canModeBeOptimized = {}, "boolean" == typeof e2)
              throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\na boolean 2nd argument is no longer supported");
            if (this.config = i.merge(u, e2), this.config.lineTerminatorsPattern === u.lineTerminatorsPattern)
              this.config.lineTerminatorsPattern = r.LineTerminatorOptimizedTester;
            else if (this.config.lineTerminatorCharacters === u.lineTerminatorCharacters)
              throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n	For details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");
            if (e2.safeMode && e2.ensureOptimizations)
              throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
            this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking), this.trackEndLines = /full/i.test(this.config.positionTracking);
            var a2, s2 = true;
            i.isArray(t3) ? ((a2 = { modes: {} }).modes[r.DEFAULT_MODE] = i.cloneArr(t3), a2[r.DEFAULT_MODE] = r.DEFAULT_MODE) : (s2 = false, a2 = i.cloneObj(t3)), this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(r.performRuntimeChecks(a2, this.trackStartLines, this.config.lineTerminatorCharacters)), this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(r.performWarningRuntimeChecks(a2, this.trackStartLines, this.config.lineTerminatorCharacters)), a2.modes = a2.modes ? a2.modes : {}, i.forEach(a2.modes, function(t4, e3) {
              a2.modes[e3] = i.reject(t4, function(t5) {
                return i.isUndefined(t5);
              });
            });
            var c = i.keys(a2.modes);
            if (i.forEach(a2.modes, function(t4, a3) {
              if (n2.modes.push(a3), n2.lexerDefinitionErrors = n2.lexerDefinitionErrors.concat(r.validatePatterns(t4, c)), i.isEmpty(n2.lexerDefinitionErrors)) {
                o.augmentTokenTypes(t4);
                var u2 = r.analyzeTokenTypes(t4, { lineTerminatorCharacters: n2.config.lineTerminatorCharacters, positionTracking: e2.positionTracking, ensureOptimizations: e2.ensureOptimizations, safeMode: e2.safeMode });
                n2.patternIdxToConfig[a3] = u2.patternIdxToConfig, n2.charCodeToPatternIdxToConfig[a3] = u2.charCodeToPatternIdxToConfig, n2.emptyGroups = i.merge(n2.emptyGroups, u2.emptyGroups), n2.hasCustom = u2.hasCustom || n2.hasCustom, n2.canModeBeOptimized[a3] = u2.canBeOptimized;
              }
            }), this.defaultMode = a2.defaultMode, !i.isEmpty(this.lexerDefinitionErrors) && !this.config.deferDefinitionErrorsHandling) {
              var l = i.map(this.lexerDefinitionErrors, function(t4) {
                return t4.message;
              }).join("-----------------------\n");
              throw new Error("Errors detected in definition of Lexer:\n" + l);
            }
            if (i.forEach(this.lexerDefinitionWarning, function(t4) {
              i.PRINT_WARNING(t4.message);
            }), r.SUPPORT_STICKY ? (this.chopInput = i.IDENTITY, this.match = this.matchWithTest) : (this.updateLastIndex = i.NOOP, this.match = this.matchWithExec), s2 && (this.handleModes = i.NOOP), false === this.trackStartLines && (this.computeNewColumn = i.IDENTITY), false === this.trackEndLines && (this.updateTokenEndLineColumnLocation = i.NOOP), /full/i.test(this.config.positionTracking))
              this.createTokenInstance = this.createFullToken;
            else if (/onlyStart/i.test(this.config.positionTracking))
              this.createTokenInstance = this.createStartOnlyToken;
            else {
              if (!/onlyOffset/i.test(this.config.positionTracking))
                throw Error('Invalid <positionTracking> config option: "' + this.config.positionTracking + '"');
              this.createTokenInstance = this.createOffsetOnlyToken;
            }
            this.hasCustom ? this.addToken = this.addTokenUsingPush : this.addToken = this.addTokenUsingMemberAccess;
            var E = i.reduce(this.canModeBeOptimized, function(t4, e3, n3) {
              return false === e3 && t4.push(n3), t4;
            }, []);
            if (e2.ensureOptimizations && !i.isEmpty(E))
              throw Error("Lexer Modes: < " + E.join(", ") + ' > cannot be optimized.\n	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n	 Or inspect the console log for details on how to resolve these issues.');
          }
          return t2.prototype.tokenize = function(t3, e2) {
            if (void 0 === e2 && (e2 = this.defaultMode), !i.isEmpty(this.lexerDefinitionErrors)) {
              var n2 = i.map(this.lexerDefinitionErrors, function(t4) {
                return t4.message;
              }).join("-----------------------\n");
              throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n" + n2);
            }
            return this.tokenizeInternal(t3, e2);
          }, t2.prototype.tokenizeInternal = function(t3, e2) {
            var n2, o2, a2, u2, s2, c, l, E, p, f, L, S, h = this, T = t3, U = T.length, R = 0, d = 0, O = this.hasCustom ? 0 : Math.floor(t3.length / 10), N = new Array(O), A = [], m = this.trackStartLines ? 1 : void 0, C = this.trackStartLines ? 1 : void 0, I = r.cloneEmptyGroups(this.emptyGroups), y = this.trackStartLines, _ = this.config.lineTerminatorsPattern, P = 0, v = [], M = [], g = [], B = [];
            Object.freeze(B);
            var k, D = void 0, b = function(t4) {
              if (1 === g.length && void 0 === t4.tokenType.PUSH_MODE) {
                var e3 = h.config.errorMessageProvider.buildUnableToPopLexerModeMessage(t4);
                A.push({ offset: t4.startOffset, line: void 0 !== t4.startLine ? t4.startLine : void 0, column: void 0 !== t4.startColumn ? t4.startColumn : void 0, length: t4.image.length, message: e3 });
              } else {
                g.pop();
                var n3 = i.last(g);
                v = h.patternIdxToConfig[n3], M = h.charCodeToPatternIdxToConfig[n3], P = v.length;
                var r2 = h.canModeBeOptimized[n3] && false === h.config.safeMode;
                D = M && r2 ? function(t5) {
                  var e4 = M[t5];
                  return void 0 === e4 ? B : e4;
                } : function() {
                  return v;
                };
              }
            };
            function x(t4) {
              g.push(t4), M = this.charCodeToPatternIdxToConfig[t4], v = this.patternIdxToConfig[t4], P = v.length, P = v.length;
              var e3 = this.canModeBeOptimized[t4] && false === this.config.safeMode;
              D = M && e3 ? function(t5) {
                var e4 = M[t5];
                return void 0 === e4 ? B : e4;
              } : function() {
                return v;
              };
            }
            for (x.call(this, e2); R < U; ) {
              s2 = null;
              var F = T.charCodeAt(R), G = D(F), w = G.length;
              for (n2 = 0; n2 < w; n2++) {
                var j = (k = G[n2]).pattern;
                if (false !== ($ = k.short) ? F === $ && (s2 = j) : true === k.isCustom ? s2 = null !== (S = j.exec(T, R, N, I)) ? S[0] : S : (this.updateLastIndex(j, R), s2 = this.match(j, t3, R)), null !== s2) {
                  if (void 0 !== (u2 = k.longerAlt)) {
                    var V = v[u2], H = V.pattern;
                    true === V.isCustom ? a2 = null !== (S = H.exec(T, R, N, I)) ? S[0] : S : (this.updateLastIndex(H, R), a2 = this.match(H, t3, R)), a2 && a2.length > s2.length && (s2 = a2, k = V);
                  }
                  break;
                }
              }
              if (null !== s2) {
                if (c = s2.length, void 0 !== (l = k.group) && (E = k.tokenTypeIdx, p = this.createTokenInstance(s2, R, E, k.tokenType, m, C, c), false === l ? d = this.addToken(N, d, p) : I[l].push(p)), t3 = this.chopInput(t3, c), R += c, C = this.computeNewColumn(C, c), true === y && true === k.canLineTerminator) {
                  var W = 0, Y = void 0, K = void 0;
                  _.lastIndex = 0;
                  do {
                    true === (Y = _.test(s2)) && (K = _.lastIndex - 1, W++);
                  } while (Y);
                  0 !== W && (m += W, C = c - K, this.updateTokenEndLineColumnLocation(p, l, K, W, m, C, c));
                }
                this.handleModes(k, b, x, p);
              } else {
                for (var X = R, q = m, z = C, Q = false; !Q && R < U; )
                  for (T.charCodeAt(R), t3 = this.chopInput(t3, 1), R++, o2 = 0; o2 < P; o2++) {
                    var $, Z = v[o2];
                    j = Z.pattern;
                    if (false !== ($ = Z.short) ? T.charCodeAt(R) === $ && (Q = true) : true === Z.isCustom ? Q = null !== j.exec(T, R, N, I) : (this.updateLastIndex(j, R), Q = null !== j.exec(t3)), true === Q)
                      break;
                  }
                f = R - X, L = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(T, X, f, q, z), A.push({ offset: X, line: q, column: z, length: f, message: L });
              }
            }
            return this.hasCustom || (N.length = d), { tokens: N, groups: I, errors: A };
          }, t2.prototype.handleModes = function(t3, e2, n2, r2) {
            if (true === t3.pop) {
              var i2 = t3.push;
              e2(r2), void 0 !== i2 && n2.call(this, i2);
            } else
              void 0 !== t3.push && n2.call(this, t3.push);
          }, t2.prototype.chopInput = function(t3, e2) {
            return t3.substring(e2);
          }, t2.prototype.updateLastIndex = function(t3, e2) {
            t3.lastIndex = e2;
          }, t2.prototype.updateTokenEndLineColumnLocation = function(t3, e2, n2, r2, i2, o2, a2) {
            var u2, s2;
            void 0 !== e2 && (s2 = (u2 = n2 === a2 - 1) ? -1 : 0, 1 === r2 && true === u2 || (t3.endLine = i2 + s2, t3.endColumn = o2 - 1 - s2));
          }, t2.prototype.computeNewColumn = function(t3, e2) {
            return t3 + e2;
          }, t2.prototype.createTokenInstance = function() {
            for (var t3 = [], e2 = 0; e2 < arguments.length; e2++)
              t3[e2] = arguments[e2];
            return null;
          }, t2.prototype.createOffsetOnlyToken = function(t3, e2, n2, r2) {
            return { image: t3, startOffset: e2, tokenTypeIdx: n2, tokenType: r2 };
          }, t2.prototype.createStartOnlyToken = function(t3, e2, n2, r2, i2, o2) {
            return { image: t3, startOffset: e2, startLine: i2, startColumn: o2, tokenTypeIdx: n2, tokenType: r2 };
          }, t2.prototype.createFullToken = function(t3, e2, n2, r2, i2, o2, a2) {
            return { image: t3, startOffset: e2, endOffset: e2 + a2 - 1, startLine: i2, endLine: i2, startColumn: o2, endColumn: o2 + a2 - 1, tokenTypeIdx: n2, tokenType: r2 };
          }, t2.prototype.addToken = function(t3, e2, n2) {
            return 666;
          }, t2.prototype.addTokenUsingPush = function(t3, e2, n2) {
            return t3.push(n2), e2;
          }, t2.prototype.addTokenUsingMemberAccess = function(t3, e2, n2) {
            return t3[e2] = n2, ++e2;
          }, t2.prototype.match = function(t3, e2, n2) {
            return null;
          }, t2.prototype.matchWithTest = function(t3, e2, n2) {
            return true === t3.test(e2) ? e2.substring(n2, t3.lastIndex) : null;
          }, t2.prototype.matchWithExec = function(t3, e2) {
            var n2 = t3.exec(e2);
            return null !== n2 ? n2[0] : n2;
          }, t2.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.", t2.NA = /NOT_APPLICABLE/, t2;
        }();
        e.Lexer = s;
      }, function(t, e, n) {
        "use strict";
        var r, i = this && this.__extends || (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        });
        Object.defineProperty(e, "__esModule", { value: true });
        var o = n(4), a = n(10), u = n(16), s = n(6), c = n(11);
        e.setNodeLocationOnlyOffset = function(t2, e2) {
          true === isNaN(t2.startOffset) ? (t2.startOffset = e2.startOffset, t2.endOffset = e2.endOffset) : t2.endOffset < e2.endOffset == 1 && (t2.endOffset = e2.endOffset);
        }, e.setNodeLocationFull = function(t2, e2) {
          true === isNaN(t2.startOffset) ? (t2.startOffset = e2.startOffset, t2.startColumn = e2.startColumn, t2.startLine = e2.startLine, t2.endOffset = e2.endOffset, t2.endColumn = e2.endColumn, t2.endLine = e2.endLine) : t2.endOffset < e2.endOffset == 1 && (t2.endOffset = e2.endOffset, t2.endColumn = e2.endColumn, t2.endLine = e2.endLine);
        }, e.addTerminalToCst = function(t2, e2, n2) {
          void 0 === t2.children[n2] ? t2.children[n2] = [e2] : t2.children[n2].push(e2);
        }, e.addNoneTerminalToCst = function(t2, e2, n2) {
          void 0 === t2.children[e2] ? t2.children[e2] = [n2] : t2.children[e2].push(n2);
        };
        var l = function(t2) {
          function e2(e3) {
            var n2 = t2.call(this) || this;
            return n2.result = [], n2.ruleIdx = e3, n2;
          }
          return i(e2, t2), e2.prototype.collectNamedDSLMethod = function(t3, e3, n2) {
            if (!o.isUndefined(t3.name)) {
              var r2 = void 0;
              if (t3 instanceof s.Option || t3 instanceof s.Repetition || t3 instanceof s.RepetitionMandatory || t3 instanceof s.Alternation)
                r2 = new e3({ definition: t3.definition, idx: t3.idx });
              else {
                if (!(t3 instanceof s.RepetitionMandatoryWithSeparator || t3 instanceof s.RepetitionWithSeparator))
                  throw Error("non exhaustive match");
                r2 = new e3({ definition: t3.definition, idx: t3.idx, separator: t3.separator });
              }
              var i2 = [r2], a2 = u.getKeyForAutomaticLookahead(this.ruleIdx, n2, t3.idx);
              this.result.push({ def: i2, key: a2, name: t3.name, orgProd: t3 });
            }
          }, e2.prototype.visitOption = function(t3) {
            this.collectNamedDSLMethod(t3, s.Option, u.OPTION_IDX);
          }, e2.prototype.visitRepetition = function(t3) {
            this.collectNamedDSLMethod(t3, s.Repetition, u.MANY_IDX);
          }, e2.prototype.visitRepetitionMandatory = function(t3) {
            this.collectNamedDSLMethod(t3, s.RepetitionMandatory, u.AT_LEAST_ONE_IDX);
          }, e2.prototype.visitRepetitionMandatoryWithSeparator = function(t3) {
            this.collectNamedDSLMethod(t3, s.RepetitionMandatoryWithSeparator, u.AT_LEAST_ONE_SEP_IDX);
          }, e2.prototype.visitRepetitionWithSeparator = function(t3) {
            this.collectNamedDSLMethod(t3, s.RepetitionWithSeparator, u.MANY_SEP_IDX);
          }, e2.prototype.visitAlternation = function(t3) {
            var e3 = this;
            this.collectNamedDSLMethod(t3, s.Alternation, u.OR_IDX);
            var n2 = t3.definition.length > 1;
            o.forEach(t3.definition, function(r2, i2) {
              if (!o.isUndefined(r2.name)) {
                var a2 = r2.definition;
                a2 = n2 ? [new s.Option({ definition: r2.definition })] : r2.definition;
                var c2 = u.getKeyForAltIndex(e3.ruleIdx, u.OR_IDX, t3.idx, i2);
                e3.result.push({ def: a2, key: c2, name: r2.name, orgProd: r2 });
              }
            });
          }, e2;
        }(c.GAstVisitor);
        e.NamedDSLMethodsCollectorVisitor = l, e.analyzeCst = function(t2, e2) {
          var n2 = { dictDef: new a.HashTable(), allRuleNames: [] };
          return o.forEach(t2, function(t3) {
            var r2 = e2.get(t3.name);
            n2.allRuleNames.push(t3.name);
            var i2 = new l(r2);
            t3.accept(i2), o.forEach(i2.result, function(e3) {
              e3.def, e3.key;
              var r3 = e3.name;
              n2.allRuleNames.push(t3.name + r3);
            });
          }), n2;
        };
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.VERSION = "4.7.0";
      }, function(t, e, n) {
        "use strict";
        n.d(e, "d", function() {
          return i;
        });
        var r = n(1);
        n.d(e, "b", function() {
          return r.IToken;
        }), n.d(e, "a", function() {
          return r.CstNode;
        }), n.d(e, "c", function() {
          return r.TokenType;
        });
        var i = function() {
          for (var t2 = [], e2 = 0; e2 < arguments.length; e2++)
            t2[e2] = arguments[e2];
          return t2;
        };
      }, function(t, e, n) {
        "use strict";
        n.r(e);
        var r = n(1), i = n(2), o = n(3), a = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{8})|\\[uU]|\\(.)/g, u = { "\\": "\\", "'": "'", '"': '"', n: "\n", r: "\r", t: "	", f: "\f", b: "\b", _: "_", "~": "~", ".": ".", "-": "-", "!": "!", $: "$", "&": "&", "(": "(", ")": ")", "*": "*", "+": "+", ",": ",", ";": ";", "=": "=", "/": "/", "?": "?", "#": "#", "@": "@", "%": "%" }, s = /^"([^"\\\r\n]+)"/, c = /^'([^'\\\r\n]+)'/, l = /^"((?:[^"\\\r\n]|\\.)*)"(?=[^"])/, E = /^'((?:[^'\\\r\n]|\\.)*)'(?=[^'])/, p = /^"""([^"\\]*(?:(?:\\.|"(?!""))[^"\\]*)*)"""/, f = /^'''([^'\\]*(?:(?:\\.|'(?!''))[^'\\]*)*)'''/, L = /[\x00-\x20<>\\"\{\}\|\^\`]/, S = /^<((?:[^ <>{}\\]|\\[uU])+)>[ \t]*/, h = /^<([^\x00-\x20<>\\"\{\}\|\^\`]*)>[ \t]*/, T = function(t2) {
          try {
            return t2.replace(a, function(t3, e2, n2, r2) {
              if (e2)
                return String.fromCharCode(parseInt(e2, 16));
              if (n2) {
                var i2 = parseInt(n2, 16);
                return i2 <= 65535 ? String.fromCharCode(i2) : String.fromCharCode(55296 + (i2 -= 65536) / 1024, 56320 + (1023 & i2));
              }
              var o2 = u[r2];
              if (!o2)
                throw new Error();
              return o2;
            });
          } catch (t3) {
            return null;
          }
        };
        n.d(e, "turtleTokenMap", function() {
          return d;
        }), n.d(e, "turtleTokenTypes", function() {
          return O;
        });
        var U = n(9).sparqlTokenMap, R = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, d = { Comment: Object(r.createToken)({ name: "Comment", pattern: /#[^\n]*/, group: "comments" }), LBracket: U.LBracket, RBracket: U.RBracket, LCurly: U.LCurly, RCurly: U.RCurly, LParen: U.LParen, RParen: U.RParen, Period: U.Period, WhiteSpace: U.WhiteSpace, TRUE: Object(r.createToken)({ name: "TRUE", pattern: /true/ }), FALSE: Object(r.createToken)({ name: "FALSE", pattern: /false/ }), DoubleCaret: U.DoubleCaret, LEmbed: U.LEmbed, REmbed: U.REmbed, Comma: U.Comma, Semicolon: U.Semicolon, A: U.A, PREFIX: U.PREFIX, BASE: U.BASE, PNAME_NS: U.PNAME_NS, PNAME_LN: U.PNAME_LN, BLANK_NODE_LABEL: U.BLANK_NODE_LABEL, TTL_BASE: Object(r.createToken)({ name: "TTL_BASE", pattern: /@base/ }), TTL_PREFIX: Object(r.createToken)({ name: "TTL_PREFIX", pattern: /@prefix/ }), LANGTAG: U.LANGTAG, INTEGER: Object(r.createToken)({ name: "INTEGER", pattern: i.a.and(i.a.option(/[+-]/), /\d+/) }), DECIMAL: Object(r.createToken)({ name: "DECIMAL", pattern: i.a.and(i.a.option(/[+-]/), /(\d*\.\d+)/) }), DOUBLE: Object(r.createToken)({ name: "DOUBLE", pattern: i.a.and(i.a.option(/[+-]/), i.a.or(i.a.and(/\d+\.\d*/, o.EXPONENT), i.a.and(/\.\d+/, o.EXPONENT), i.a.and(/\d+/, o.EXPONENT))) }), EXPONENT: Object(r.createToken)({ name: "EXPONENT", pattern: o.EXPONENT }), ECHAR: Object(r.createToken)({ name: "ECHAR", pattern: o.ECHAR }), ANON: U.ANON, PLX: Object(r.createToken)({ name: "PLX", pattern: o.PLX }), PERCENT: U.PERCENT, HEX: Object(r.createToken)({ name: "HEX", pattern: o.HEX }), STRING_LITERAL_LONG_SINGLE_QUOTE: Object(r.createToken)({ name: "STRING_LITERAL_LONG_SINGLE_QUOTE", pattern: function(t2, e2) {
          void 0 === e2 && (e2 = 0);
          var n2 = f.exec(t2.slice(e2));
          return n2 && null !== T(n2[1]) ? n2 : null;
        }, line_breaks: true }), STRING_LITERAL_LONG_QUOTE: Object(r.createToken)({ name: "STRING_LITERAL_LONG_QUOTE", pattern: function(t2, e2) {
          void 0 === e2 && (e2 = 0);
          var n2 = p.exec(t2.slice(e2));
          return n2 && null !== T(n2[1]) ? n2 : null;
        }, line_breaks: true }), STRING_LITERAL_QUOTE: Object(r.createToken)({ name: "STRING_LITERAL_QUOTE", pattern: function(t2, e2) {
          void 0 === e2 && (e2 = 0);
          var n2 = t2.slice(e2), r2 = s.exec(n2);
          return r2 || ((r2 = l.exec(n2)) ? null === T(r2[1]) ? null : r2 : null);
        }, line_breaks: false }), STRING_LITERAL_SINGLE_QUOTE: Object(r.createToken)({ name: "STRING_LITERAL_SINGLE_QUOTE", pattern: function(t2, e2) {
          void 0 === e2 && (e2 = 0);
          var n2 = t2.slice(e2), r2 = c.exec(n2);
          return r2 || ((r2 = E.exec(n2)) ? null === T(r2[1]) ? null : r2 : null);
        }, line_breaks: false }), UCHAR: Object(r.createToken)({ name: "UCHAR", pattern: function(t2, e2) {
          return void 0 === e2 && (e2 = 0), R.exec(t2.slice(e2));
        }, line_breaks: false }), IRIREF: Object(r.createToken)({ name: "IRIREF", pattern: function(t2, e2) {
          void 0 === e2 && (e2 = 0);
          var n2 = t2.slice(e2), r2 = h.exec(n2);
          if (r2)
            return r2;
          if (!(r2 = S.exec(n2)))
            return null;
          var i2 = T(r2[1]);
          return null === i2 || L.test(i2) ? null : r2;
        }, line_breaks: false }), PN_CHARS_BASE: Object(r.createToken)({ name: "PN_CHARS_BASE", pattern: o.PN_CHARS_BASE }), PN_CHARS_U: Object(r.createToken)({ name: "PN_CHARS_U", pattern: o.PN_CHARS_U }), PN_CHARS: Object(r.createToken)({ name: "PN_CHARS", pattern: o.PN_CHARS }), PN_PREFIX: Object(r.createToken)({ name: "PN_PREFIX", pattern: o.PN_PREFIX }), PN_LOCAL: Object(r.createToken)({ name: "PN_LOCAL", pattern: o.PN_LOCAL }), PN_LOCAL_ESC: Object(r.createToken)({ name: "PN_LOCAL_ESC", pattern: o.PN_LOCAL_ESC }), UNKNOWN: U.UNKNOWN }, O = [d.Comment, U.ANON, U.LBracket, U.RBracket, U.LCurly, U.RCurly, U.LParen, U.RParen, U.WhiteSpace, d.TRUE, d.FALSE, U.Comma, U.Semicolon, U.PNAME_NS, U.A, U.PREFIX, U.BASE, U.PNAME_LN, U.BLANK_NODE_LABEL, d.TTL_BASE, d.TTL_PREFIX, U.LANGTAG, d.DOUBLE, d.DECIMAL, U.Period, U.DoubleCaret, d.LEmbed, d.REmbed, d.IRIREF, d.STRING_LITERAL_LONG_SINGLE_QUOTE, d.STRING_LITERAL_LONG_QUOTE, d.STRING_LITERAL_QUOTE, d.STRING_LITERAL_SINGLE_QUOTE, d.INTEGER, d.EXPONENT, d.PLX, U.PERCENT, d.HEX, d.PN_CHARS_BASE, d.PN_CHARS_U, d.PN_CHARS, d.PN_PREFIX, d.PN_LOCAL, d.PN_LOCAL_ESC, d.ECHAR, d.UCHAR, d.UNKNOWN];
      }, function(t, e, n) {
        var r, i, o;
        "undefined" != typeof self && self, i = [], void 0 === (o = "function" == typeof (r = function() {
          function t2() {
          }
          t2.prototype.saveState = function() {
            return { idx: this.idx, input: this.input, groupIdx: this.groupIdx };
          }, t2.prototype.restoreState = function(t3) {
            this.idx = t3.idx, this.input = t3.input, this.groupIdx = t3.groupIdx;
          }, t2.prototype.pattern = function(t3) {
            this.idx = 0, this.input = t3, this.groupIdx = 0, this.consumeChar("/");
            var e3 = this.disjunction();
            this.consumeChar("/");
            for (var n3 = { type: "Flags", global: false, ignoreCase: false, multiLine: false, unicode: false, sticky: false }; this.isRegExpFlag(); )
              switch (this.popChar()) {
                case "g":
                  u(n3, "global");
                  break;
                case "i":
                  u(n3, "ignoreCase");
                  break;
                case "m":
                  u(n3, "multiLine");
                  break;
                case "u":
                  u(n3, "unicode");
                  break;
                case "y":
                  u(n3, "sticky");
              }
            if (this.idx !== this.input.length)
              throw Error("Redundant input: " + this.input.substring(this.idx));
            return { type: "Pattern", flags: n3, value: e3 };
          }, t2.prototype.disjunction = function() {
            var t3 = [];
            for (t3.push(this.alternative()); "|" === this.peekChar(); )
              this.consumeChar("|"), t3.push(this.alternative());
            return { type: "Disjunction", value: t3 };
          }, t2.prototype.alternative = function() {
            for (var t3 = []; this.isTerm(); )
              t3.push(this.term());
            return { type: "Alternative", value: t3 };
          }, t2.prototype.term = function() {
            return this.isAssertion() ? this.assertion() : this.atom();
          }, t2.prototype.assertion = function() {
            switch (this.popChar()) {
              case "^":
                return { type: "StartAnchor" };
              case "$":
                return { type: "EndAnchor" };
              case "\\":
                switch (this.popChar()) {
                  case "b":
                    return { type: "WordBoundary" };
                  case "B":
                    return { type: "NonWordBoundary" };
                }
                throw Error("Invalid Assertion Escape");
              case "(":
                var t3;
                switch (this.consumeChar("?"), this.popChar()) {
                  case "=":
                    t3 = "Lookahead";
                    break;
                  case "!":
                    t3 = "NegativeLookahead";
                }
                s(t3);
                var e3 = this.disjunction();
                return this.consumeChar(")"), { type: t3, value: e3 };
            }
            !function() {
              throw Error("Internal Error - Should never get here!");
            }();
          }, t2.prototype.quantifier = function(t3) {
            var e3;
            switch (this.popChar()) {
              case "*":
                e3 = { atLeast: 0, atMost: 1 / 0 };
                break;
              case "+":
                e3 = { atLeast: 1, atMost: 1 / 0 };
                break;
              case "?":
                e3 = { atLeast: 0, atMost: 1 };
                break;
              case "{":
                var n3 = this.integerIncludingZero();
                switch (this.popChar()) {
                  case "}":
                    e3 = { atLeast: n3, atMost: n3 };
                    break;
                  case ",":
                    var r3;
                    this.isDigit() ? (r3 = this.integerIncludingZero(), e3 = { atLeast: n3, atMost: r3 }) : e3 = { atLeast: n3, atMost: 1 / 0 }, this.consumeChar("}");
                }
                if (true === t3 && void 0 === e3)
                  return;
                s(e3);
            }
            if (true !== t3 || void 0 !== e3)
              return s(e3), "?" === this.peekChar(0) ? (this.consumeChar("?"), e3.greedy = false) : e3.greedy = true, e3.type = "Quantifier", e3;
          }, t2.prototype.atom = function() {
            var t3;
            switch (this.peekChar()) {
              case ".":
                t3 = this.dotAll();
                break;
              case "\\":
                t3 = this.atomEscape();
                break;
              case "[":
                t3 = this.characterClass();
                break;
              case "(":
                t3 = this.group();
            }
            return void 0 === t3 && this.isPatternCharacter() && (t3 = this.patternCharacter()), s(t3), this.isQuantifier() && (t3.quantifier = this.quantifier()), t3;
          }, t2.prototype.dotAll = function() {
            return this.consumeChar("."), { type: "Set", complement: true, value: [o2("\n"), o2("\r"), o2("\u2028"), o2("\u2029")] };
          }, t2.prototype.atomEscape = function() {
            switch (this.consumeChar("\\"), this.peekChar()) {
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
                return this.decimalEscapeAtom();
              case "d":
              case "D":
              case "s":
              case "S":
              case "w":
              case "W":
                return this.characterClassEscape();
              case "f":
              case "n":
              case "r":
              case "t":
              case "v":
                return this.controlEscapeAtom();
              case "c":
                return this.controlLetterEscapeAtom();
              case "0":
                return this.nulCharacterAtom();
              case "x":
                return this.hexEscapeSequenceAtom();
              case "u":
                return this.regExpUnicodeEscapeSequenceAtom();
              default:
                return this.identityEscapeAtom();
            }
          }, t2.prototype.decimalEscapeAtom = function() {
            var t3 = this.positiveInteger();
            return { type: "GroupBackReference", value: t3 };
          }, t2.prototype.characterClassEscape = function() {
            var t3, e3 = false;
            switch (this.popChar()) {
              case "d":
                t3 = c;
                break;
              case "D":
                t3 = c, e3 = true;
                break;
              case "s":
                t3 = E;
                break;
              case "S":
                t3 = E, e3 = true;
                break;
              case "w":
                t3 = l;
                break;
              case "W":
                t3 = l, e3 = true;
            }
            return s(t3), { type: "Set", value: t3, complement: e3 };
          }, t2.prototype.controlEscapeAtom = function() {
            var t3;
            switch (this.popChar()) {
              case "f":
                t3 = o2("\f");
                break;
              case "n":
                t3 = o2("\n");
                break;
              case "r":
                t3 = o2("\r");
                break;
              case "t":
                t3 = o2("	");
                break;
              case "v":
                t3 = o2("\v");
            }
            return s(t3), { type: "Character", value: t3 };
          }, t2.prototype.controlLetterEscapeAtom = function() {
            this.consumeChar("c");
            var t3 = this.popChar();
            if (false === /[a-zA-Z]/.test(t3))
              throw Error("Invalid ");
            var e3 = t3.toUpperCase().charCodeAt(0) - 64;
            return { type: "Character", value: e3 };
          }, t2.prototype.nulCharacterAtom = function() {
            return this.consumeChar("0"), { type: "Character", value: o2("\0") };
          }, t2.prototype.hexEscapeSequenceAtom = function() {
            return this.consumeChar("x"), this.parseHexDigits(2);
          }, t2.prototype.regExpUnicodeEscapeSequenceAtom = function() {
            return this.consumeChar("u"), this.parseHexDigits(4);
          }, t2.prototype.identityEscapeAtom = function() {
            var t3 = this.popChar();
            return { type: "Character", value: o2(t3) };
          }, t2.prototype.classPatternCharacterAtom = function() {
            switch (this.peekChar()) {
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
              case "\\":
              case "]":
                throw Error("TBD");
              default:
                var t3 = this.popChar();
                return { type: "Character", value: o2(t3) };
            }
          }, t2.prototype.characterClass = function() {
            var t3 = [], e3 = false;
            for (this.consumeChar("["), "^" === this.peekChar(0) && (this.consumeChar("^"), e3 = true); this.isClassAtom(); ) {
              var n3 = this.classAtom(), r3 = "Character" === n3.type;
              if (r3 && this.isRangeDash()) {
                this.consumeChar("-");
                var i3 = this.classAtom(), u2 = "Character" === i3.type;
                if (u2) {
                  if (i3.value < n3.value)
                    throw Error("Range out of order in character class");
                  t3.push({ from: n3.value, to: i3.value });
                } else
                  a(n3.value, t3), t3.push(o2("-")), a(i3.value, t3);
              } else
                a(n3.value, t3);
            }
            return this.consumeChar("]"), { type: "Set", complement: e3, value: t3 };
          }, t2.prototype.classAtom = function() {
            switch (this.peekChar()) {
              case "]":
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
                throw Error("TBD");
              case "\\":
                return this.classEscape();
              default:
                return this.classPatternCharacterAtom();
            }
          }, t2.prototype.classEscape = function() {
            switch (this.consumeChar("\\"), this.peekChar()) {
              case "b":
                return this.consumeChar("b"), { type: "Character", value: o2("\b") };
              case "d":
              case "D":
              case "s":
              case "S":
              case "w":
              case "W":
                return this.characterClassEscape();
              case "f":
              case "n":
              case "r":
              case "t":
              case "v":
                return this.controlEscapeAtom();
              case "c":
                return this.controlLetterEscapeAtom();
              case "0":
                return this.nulCharacterAtom();
              case "x":
                return this.hexEscapeSequenceAtom();
              case "u":
                return this.regExpUnicodeEscapeSequenceAtom();
              default:
                return this.identityEscapeAtom();
            }
          }, t2.prototype.group = function() {
            var t3 = true;
            switch (this.consumeChar("("), this.peekChar(0)) {
              case "?":
                this.consumeChar("?"), this.consumeChar(":"), t3 = false;
                break;
              default:
                this.groupIdx++;
            }
            var e3 = this.disjunction();
            this.consumeChar(")");
            var n3 = { type: "Group", capturing: t3, value: e3 };
            return t3 && (n3.idx = this.groupIdx), n3;
          }, t2.prototype.positiveInteger = function() {
            var t3 = this.popChar();
            if (false === i2.test(t3))
              throw Error("Expecting a positive integer");
            for (; r2.test(this.peekChar(0)); )
              t3 += this.popChar();
            return parseInt(t3, 10);
          }, t2.prototype.integerIncludingZero = function() {
            var t3 = this.popChar();
            if (false === r2.test(t3))
              throw Error("Expecting an integer");
            for (; r2.test(this.peekChar(0)); )
              t3 += this.popChar();
            return parseInt(t3, 10);
          }, t2.prototype.patternCharacter = function() {
            var t3 = this.popChar();
            switch (t3) {
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
              case "^":
              case "$":
              case "\\":
              case ".":
              case "*":
              case "+":
              case "?":
              case "(":
              case ")":
              case "[":
              case "|":
                throw Error("TBD");
              default:
                return { type: "Character", value: o2(t3) };
            }
          }, t2.prototype.isRegExpFlag = function() {
            switch (this.peekChar(0)) {
              case "g":
              case "i":
              case "m":
              case "u":
              case "y":
                return true;
              default:
                return false;
            }
          }, t2.prototype.isRangeDash = function() {
            return "-" === this.peekChar() && this.isClassAtom(1);
          }, t2.prototype.isDigit = function() {
            return r2.test(this.peekChar(0));
          }, t2.prototype.isClassAtom = function(t3) {
            switch (void 0 === t3 && (t3 = 0), this.peekChar(t3)) {
              case "]":
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
                return false;
              default:
                return true;
            }
          }, t2.prototype.isTerm = function() {
            return this.isAtom() || this.isAssertion();
          }, t2.prototype.isAtom = function() {
            if (this.isPatternCharacter())
              return true;
            switch (this.peekChar(0)) {
              case ".":
              case "\\":
              case "[":
              case "(":
                return true;
              default:
                return false;
            }
          }, t2.prototype.isAssertion = function() {
            switch (this.peekChar(0)) {
              case "^":
              case "$":
                return true;
              case "\\":
                switch (this.peekChar(1)) {
                  case "b":
                  case "B":
                    return true;
                  default:
                    return false;
                }
              case "(":
                return "?" === this.peekChar(1) && ("=" === this.peekChar(2) || "!" === this.peekChar(2));
              default:
                return false;
            }
          }, t2.prototype.isQuantifier = function() {
            var t3 = this.saveState();
            try {
              return void 0 !== this.quantifier(true);
            } catch (t4) {
              return false;
            } finally {
              this.restoreState(t3);
            }
          }, t2.prototype.isPatternCharacter = function() {
            switch (this.peekChar()) {
              case "^":
              case "$":
              case "\\":
              case ".":
              case "*":
              case "+":
              case "?":
              case "(":
              case ")":
              case "[":
              case "|":
              case "/":
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
                return false;
              default:
                return true;
            }
          }, t2.prototype.parseHexDigits = function(t3) {
            for (var e3 = "", r3 = 0; r3 < t3; r3++) {
              var i3 = this.popChar();
              if (false === n2.test(i3))
                throw Error("Expecting a HexDecimal digits");
              e3 += i3;
            }
            var o3 = parseInt(e3, 16);
            return { type: "Character", value: o3 };
          }, t2.prototype.peekChar = function(t3) {
            return void 0 === t3 && (t3 = 0), this.input[this.idx + t3];
          }, t2.prototype.popChar = function() {
            var t3 = this.peekChar(0);
            return this.consumeChar(), t3;
          }, t2.prototype.consumeChar = function(t3) {
            if (void 0 !== t3 && this.input[this.idx] !== t3)
              throw Error("Expected: '" + t3 + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx);
            if (this.idx >= this.input.length)
              throw Error("Unexpected end of input");
            this.idx++;
          };
          var e2, n2 = /[0-9a-fA-F]/, r2 = /[0-9]/, i2 = /[1-9]/;
          function o2(t3) {
            return t3.charCodeAt(0);
          }
          function a(t3, e3) {
            void 0 !== t3.length ? t3.forEach(function(t4) {
              e3.push(t4);
            }) : e3.push(t3);
          }
          function u(t3, e3) {
            if (true === t3[e3])
              throw "duplicate flag " + e3;
            t3[e3] = true;
          }
          function s(t3) {
            if (void 0 === t3)
              throw Error("Internal Error - Should never get here!");
          }
          var c = [];
          for (e2 = o2("0"); e2 <= o2("9"); e2++)
            c.push(e2);
          var l = [o2("_")].concat(c);
          for (e2 = o2("a"); e2 <= o2("z"); e2++)
            l.push(e2);
          for (e2 = o2("A"); e2 <= o2("Z"); e2++)
            l.push(e2);
          var E = [o2(" "), o2("\f"), o2("\n"), o2("\r"), o2("	"), o2("\v"), o2("	"), o2("\xA0"), o2("\u1680"), o2("\u2000"), o2("\u2001"), o2("\u2002"), o2("\u2003"), o2("\u2004"), o2("\u2005"), o2("\u2006"), o2("\u2007"), o2("\u2008"), o2("\u2009"), o2("\u200A"), o2("\u2028"), o2("\u2029"), o2("\u202F"), o2("\u205F"), o2("\u3000"), o2("\uFEFF")];
          function p() {
          }
          return p.prototype.visitChildren = function(t3) {
            for (var e3 in t3) {
              var n3 = t3[e3];
              t3.hasOwnProperty(e3) && (void 0 !== n3.type ? this.visit(n3) : Array.isArray(n3) && n3.forEach(function(t4) {
                this.visit(t4);
              }, this));
            }
          }, p.prototype.visit = function(t3) {
            switch (t3.type) {
              case "Pattern":
                this.visitPattern(t3);
                break;
              case "Flags":
                this.visitFlags(t3);
                break;
              case "Disjunction":
                this.visitDisjunction(t3);
                break;
              case "Alternative":
                this.visitAlternative(t3);
                break;
              case "StartAnchor":
                this.visitStartAnchor(t3);
                break;
              case "EndAnchor":
                this.visitEndAnchor(t3);
                break;
              case "WordBoundary":
                this.visitWordBoundary(t3);
                break;
              case "NonWordBoundary":
                this.visitNonWordBoundary(t3);
                break;
              case "Lookahead":
                this.visitLookahead(t3);
                break;
              case "NegativeLookahead":
                this.visitNegativeLookahead(t3);
                break;
              case "Character":
                this.visitCharacter(t3);
                break;
              case "Set":
                this.visitSet(t3);
                break;
              case "Group":
                this.visitGroup(t3);
                break;
              case "GroupBackReference":
                this.visitGroupBackReference(t3);
                break;
              case "Quantifier":
                this.visitQuantifier(t3);
            }
            this.visitChildren(t3);
          }, p.prototype.visitPattern = function(t3) {
          }, p.prototype.visitFlags = function(t3) {
          }, p.prototype.visitDisjunction = function(t3) {
          }, p.prototype.visitAlternative = function(t3) {
          }, p.prototype.visitStartAnchor = function(t3) {
          }, p.prototype.visitEndAnchor = function(t3) {
          }, p.prototype.visitWordBoundary = function(t3) {
          }, p.prototype.visitNonWordBoundary = function(t3) {
          }, p.prototype.visitLookahead = function(t3) {
          }, p.prototype.visitNegativeLookahead = function(t3) {
          }, p.prototype.visitCharacter = function(t3) {
          }, p.prototype.visitSet = function(t3) {
          }, p.prototype.visitGroup = function(t3) {
          }, p.prototype.visitGroupBackReference = function(t3) {
          }, p.prototype.visitQuantifier = function(t3) {
          }, { RegExpParser: t2, BaseRegExpVisitor: p, VERSION: "0.4.0" };
        }) ? r.apply(e, i) : r) || (t.exports = o);
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.defaultLexerErrorProvider = { buildUnableToPopLexerModeMessage: function(t2) {
          return "Unable to pop Lexer Mode after encountering Token ->" + t2.image + "<- The Mode Stack is empty";
        }, buildUnexpectedCharactersMessage: function(t2, e2, n2, r, i) {
          return "unexpected character: ->" + t2.charAt(e2) + "<- at offset: " + e2 + ", skipped " + n2 + " characters.";
        } };
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(4), i = n(6), o = n(15);
        function a(t2) {
          if (t2 instanceof i.NonTerminal)
            return a(t2.referencedRule);
          if (t2 instanceof i.Terminal)
            return c(t2);
          if (o.isSequenceProd(t2))
            return u(t2);
          if (o.isBranchingProd(t2))
            return s(t2);
          throw Error("non exhaustive match");
        }
        function u(t2) {
          for (var e2, n2 = [], i2 = t2.definition, u2 = 0, s2 = i2.length > u2, c2 = true; s2 && c2; )
            e2 = i2[u2], c2 = o.isOptionalProd(e2), n2 = n2.concat(a(e2)), u2 += 1, s2 = i2.length > u2;
          return r.uniq(n2);
        }
        function s(t2) {
          var e2 = r.map(t2.definition, function(t3) {
            return a(t3);
          });
          return r.uniq(r.flatten(e2));
        }
        function c(t2) {
          return [t2.terminalType];
        }
        e.first = a, e.firstForSequence = u, e.firstForBranching = s, e.firstForTerminal = c;
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.IN = "_~IN~_";
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r, i = n(40), o = n(4), a = n(6);
        !function(t2) {
          t2[t2.OPTION = 0] = "OPTION", t2[t2.OR = 1] = "OR", t2[t2.MANY = 2] = "MANY", t2[t2.MANY_SEP = 3] = "MANY_SEP", t2[t2.AT_LEAST_ONE = 4] = "AT_LEAST_ONE", t2[t2.AT_LEAST_ONE_SEP = 5] = "AT_LEAST_ONE_SEP", t2[t2.REF = 6] = "REF", t2[t2.TERMINAL = 7] = "TERMINAL", t2[t2.FLAT = 8] = "FLAT";
        }(r = e.ProdType || (e.ProdType = {}));
        var u = /(?:\s*{\s*NAME\s*:\s*["'`]([\w$]*)["'`])?/, s = new RegExp(u.source.replace("{", "").replace(")?", "\\s*,)?")), c = /\.\s*CONSUME(\d+)?\s*\(\s*(?:[a-zA-Z_$]\w*\s*\.\s*)*([a-zA-Z_$]\w*)/, l = new RegExp(c.source, "g"), E = /\.\s*SUBRULE(\d+)?\s*\(\s*(?:[a-zA-Z_$]\w*\s*\.\s*)*([a-zA-Z_$]\w*)/, p = new RegExp(E.source, "g"), f = /\.\s*OPTION(\d+)?\s*\(/, L = new RegExp(f.source + u.source), S = new RegExp(f.source, "g"), h = /\.\s*MANY(\d+)?\s*\(/, T = new RegExp(h.source + u.source), U = new RegExp(h.source, "g"), R = /\s*SEP\s*:\s*(?:[a-zA-Z_$]\w*\s*\.\s*)*([a-zA-Z_$]\w*)/, d = new RegExp(/\.\s*MANY_SEP(\d+)?\s*\(\s*{/.source + s.source + R.source), O = new RegExp(d.source, "g"), N = new RegExp(/\.\s*AT_LEAST_ONE_SEP(\d+)?\s*\(\s*{/.source + s.source + R.source), A = new RegExp(N.source, "g"), m = /\.\s*AT_LEAST_ONE(\d+)?\s*\(/, C = new RegExp(m.source + u.source), I = new RegExp(m.source, "g"), y = /\.\s*OR(\d+)?\s*\(/, _ = new RegExp(y.source + u.source), P = new RegExp(y.source, "g"), v = new RegExp(s.source + /\s*(ALT)\s*:/.source), M = new RegExp(v.source, "g");
        function g(t2, n2, i2) {
          switch (t2.type) {
            case r.AT_LEAST_ONE:
              return function(t3, e2, n3) {
                return B(C, new a.RepetitionMandatory({ definition: [] }), t3, e2, n3);
              }(t2, n2, i2);
            case r.AT_LEAST_ONE_SEP:
              return function(t3, e2, n3) {
                return k(t3, e2, a.RepetitionMandatoryWithSeparator, N, n3);
              }(t2, n2, i2);
            case r.MANY_SEP:
              return function(t3, e2, n3) {
                return k(t3, e2, a.RepetitionWithSeparator, d, n3);
              }(t2, n2, i2);
            case r.MANY:
              return function(t3, e2, n3) {
                return B(T, new a.Repetition({ definition: [] }), t3, e2, n3);
              }(t2, n2, i2);
            case r.OPTION:
              return function(t3, e2, n3) {
                return B(L, new a.Option({ definition: [] }), t3, e2, n3);
              }(t2, n2, i2);
            case r.OR:
              return function(t3, e2, n3) {
                return B(_, new a.Alternation({ definition: [] }), t3, e2, n3);
              }(t2, n2, i2);
            case r.FLAT:
              return function(t3, e2, n3) {
                var r2 = new a.Flat({ definition: [] }), i3 = v.exec(t3.text)[1];
                o.isUndefined(i3) || (r2.name = i3);
                return D(r2, t3.range, e2, n3);
              }(t2, n2, i2);
            case r.REF:
              return function(t3) {
                var e2 = E.exec(t3.text), n3 = void 0 === e2[1] ? 0 : parseInt(e2[1], 10), r2 = e2[2];
                return new a.NonTerminal({ nonTerminalName: r2, idx: n3 });
              }(t2);
            case r.TERMINAL:
              return function(t3, n3) {
                var r2 = c.exec(t3.text), i3 = void 0 === r2[1] ? 0 : parseInt(r2[1], 10), o2 = r2[2], u2 = e.terminalNameToConstructor[o2];
                if (!u2)
                  throw Error("Terminal Token name: <" + o2 + "> not found in rule: <" + n3 + ">  \n	See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#TERMINAL_NAME_NOT_FOUND\n	For Further details.");
                return new a.Terminal({ terminalType: u2, idx: i3 });
              }(t2, i2);
            default:
              throw Error("non exhaustive match");
          }
        }
        function B(t2, e2, n2, r2, i2) {
          var a2 = t2.exec(n2.text), u2 = void 0 === a2[1];
          e2.idx = u2 ? 0 : parseInt(a2[1], 10);
          var s2 = a2[2];
          return o.isUndefined(s2) || (e2.name = s2), D(e2, n2.range, r2, i2);
        }
        function k(t2, n2, r2, i2, a2) {
          var u2 = i2.exec(t2.text), s2 = void 0 === u2[1] ? 0 : parseInt(u2[1], 10), c2 = u2[3], l2 = e.terminalNameToConstructor[c2];
          if (!l2)
            throw Error("Separator Terminal Token name: " + c2 + " not found");
          var E2 = new r2({ definition: [], separator: l2, idx: s2 }), p2 = u2[2];
          return o.isUndefined(p2) || (E2.name = p2), D(E2, t2.range, n2, a2);
        }
        function D(t2, e2, n2, r2) {
          var i2 = b(e2, n2), a2 = o.sortBy(i2, function(t3) {
            return t3.range.start;
          }), u2 = [];
          return o.forEach(a2, function(t3) {
            u2.push(g(t3, n2, r2));
          }), t2.definition = u2, t2;
        }
        function b(t2, e2) {
          return o.filter(e2, function(n2) {
            var r2 = t2.strictlyContainsRange(n2.range), i2 = o.every(e2, function(e3) {
              var r3 = e3.range.strictlyContainsRange(n2.range), i3 = e3.range.isStrictlyContainedInRange(t2);
              return !(r3 && i3);
            });
            return r2 && i2;
          });
        }
        e.terminalNameToConstructor = {}, e.buildTopProduction = function(t2, n2, r2) {
          e.terminalNameToConstructor = r2;
          var o2 = W(H(j("  " + t2)));
          return function(t3, e2, n3, r3) {
            return D(new a.Rule({ name: t3, definition: [], orgText: r3 }), e2, n3, t3);
          }(n2, new i.Range(0, t2.length + 2), o2, t2);
        }, e.buildProdGast = g, e.getDirectlyContainedRanges = b;
        var x = /\/\/.*/g, F = /\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\//g, G = /(NAME\s*:\s*)?"([^\\"]|\\([bfnrtv"\\/]|u[0-9a-fA-F]{4}))*"/g, w = /(NAME\s*:\s*)?'([^\\']|\\([bfnrtv'\\/]|u[0-9a-fA-F]{4}))*'/g;
        function j(t2) {
          return t2.replace(x, "").replace(F, "");
        }
        function V(t2, e2) {
          return void 0 !== e2 ? t2 : "";
        }
        function H(t2) {
          return t2.replace(G, V).replace(w, V);
        }
        function W(t2) {
          var e2 = Y(t2), n2 = K(t2), r2 = X(t2), i2 = q(t2), o2 = z(t2), a2 = Q(t2), u2 = $(t2), s2 = Z(t2);
          return [].concat(e2, n2, r2, i2, o2, a2, u2, s2);
        }
        function Y(t2) {
          return nt(t2, r.TERMINAL, l);
        }
        function K(t2) {
          return nt(t2, r.REF, p);
        }
        function X(t2) {
          return rt(t2, r.AT_LEAST_ONE, I);
        }
        function q(t2) {
          return rt(t2, r.AT_LEAST_ONE_SEP, A);
        }
        function z(t2) {
          return rt(t2, r.MANY, U);
        }
        function Q(t2) {
          return rt(t2, r.MANY_SEP, O);
        }
        function $(t2) {
          return rt(t2, r.OPTION, S);
        }
        function Z(t2) {
          var e2 = rt(t2, r.OR, P), n2 = et(e2);
          return e2.concat(n2);
        }
        e.removeComments = j, e.removeStringLiterals = H, e.createRanges = W, e.createTerminalRanges = Y, e.createRefsRanges = K, e.createAtLeastOneRanges = X, e.createAtLeastOneSepRanges = q, e.createManyRanges = z, e.createManySepRanges = Q, e.createOptionRanges = $, e.createOrRanges = Z;
        var J = o.partial(ot, "{", "}"), tt = o.partial(ot, "(", ")");
        function et(t2) {
          var e2 = [];
          return o.forEach(t2, function(t3) {
            var n2 = it(t3.text, r.FLAT, M, J), i2 = t3.range.start;
            o.forEach(n2, function(t4) {
              t4.range.start += i2, t4.range.end += i2;
            }), e2 = e2.concat(n2);
          }), o.uniq(e2, function(t3) {
            return t3.type + "~" + t3.range.start + "~" + t3.range.end + "~" + t3.text;
          });
        }
        function nt(t2, e2, n2) {
          for (var r2, o2 = []; r2 = n2.exec(t2); ) {
            var a2 = r2.index, u2 = n2.lastIndex, s2 = new i.Range(a2, u2), c2 = r2[0];
            o2.push({ range: s2, text: c2, type: e2 });
          }
          return o2;
        }
        function rt(t2, e2, n2) {
          return it(t2, e2, n2, tt);
        }
        function it(t2, e2, n2, r2) {
          for (var o2, a2 = []; o2 = n2.exec(t2); ) {
            var u2 = o2.index, s2 = r2(u2 + o2[0].length, t2), c2 = new i.Range(u2, s2), l2 = t2.substr(u2, s2 - u2 + 1);
            a2.push({ range: c2, text: l2, type: e2 });
          }
          return a2;
        }
        function ot(t2, e2, n2, r2) {
          for (var i2 = [1], a2 = -1; !o.isEmpty(i2) && a2 + n2 < r2.length; ) {
            a2++;
            var u2 = r2.charAt(n2 + a2);
            u2 === t2 ? i2.push(1) : u2 === e2 && i2.pop();
          }
          if (o.isEmpty(i2))
            return a2 + n2;
          throw new Error("INVALID INPUT TEXT, UNTERMINATED PARENTHESIS");
        }
        function at(t2, e2) {
          return o.map(t2, function(t3) {
            return ut(t3, e2);
          });
        }
        function ut(t2, e2) {
          switch (t2.type) {
            case "NonTerminal":
              return new a.NonTerminal({ nonTerminalName: t2.name, idx: t2.idx });
            case "Flat":
              return new a.Flat({ name: t2.name, definition: at(t2.definition, e2) });
            case "Option":
              return new a.Option({ name: t2.name, idx: t2.idx, definition: at(t2.definition, e2) });
            case "RepetitionMandatory":
              return new a.RepetitionMandatory({ name: t2.name, idx: t2.idx, definition: at(t2.definition, e2) });
            case "RepetitionMandatoryWithSeparator":
              return new a.RepetitionMandatoryWithSeparator({ name: t2.name, idx: t2.idx, separator: e2[t2.separator.name], definition: at(t2.definition, e2) });
            case "RepetitionWithSeparator":
              return new a.RepetitionWithSeparator({ name: t2.name, idx: t2.idx, separator: e2[t2.separator.name], definition: at(t2.definition, e2) });
            case "Repetition":
              return new a.Repetition({ name: t2.name, idx: t2.idx, definition: at(t2.definition, e2) });
            case "Alternation":
              return new a.Alternation({ name: t2.name, idx: t2.idx, definition: at(t2.definition, e2) });
            case "Terminal":
              return new a.Terminal({ terminalType: e2[t2.name], idx: t2.idx });
            case "Rule":
              return new a.Rule({ name: t2.name, orgText: t2.orgText, definition: at(t2.definition, e2) });
            default:
          }
        }
        e.createOrPartRanges = et, e.findClosingOffset = ot, e.deserializeGrammar = at, e.deserializeProduction = ut;
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(4), i = n(10), o = n(41), a = n(18), u = n(17), s = n(15);
        e.resolveGrammar = function(t2) {
          t2 = r.defaults(t2, { errMsgProvider: u.defaultGrammarResolverErrorProvider });
          var e2 = new i.HashTable();
          return r.forEach(t2.rules, function(t3) {
            e2.put(t3.name, t3);
          }), o.resolveGrammar(e2, t2.errMsgProvider);
        }, e.validateGrammar = function(t2) {
          return t2 = r.defaults(t2, { errMsgProvider: u.defaultGrammarValidatorErrorProvider, ignoredIssues: {} }), a.validateGrammar(t2.rules, t2.maxLookahead, t2.tokenTypes, t2.ignoredIssues, t2.errMsgProvider, t2.grammarName);
        }, e.assignOccurrenceIndices = function(t2) {
          r.forEach(t2.rules, function(t3) {
            var e2 = new s.DslMethodsCollectorVisitor();
            t3.accept(e2), r.forEach(e2.dslMethods, function(t4) {
              r.forEach(t4, function(t5, e3) {
                t5.idx = e3 + 1;
              });
            });
          });
        };
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(7), i = n(4), o = n(13), a = n(31), u = n(10), s = n(8);
        function c(t2) {
          this.name = e.IN_RULE_RECOVERY_EXCEPTION, this.message = t2;
        }
        e.EOF_FOLLOW_KEY = {}, e.IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException", e.InRuleRecoveryException = c, c.prototype = Error.prototype;
        var l = function() {
          function t2() {
          }
          return t2.prototype.initRecoverable = function(t3) {
            this.firstAfterRepMap = new u.HashTable(), this.resyncFollows = new u.HashTable(), this.recoveryEnabled = i.has(t3, "recoveryEnabled") ? t3.recoveryEnabled : s.DEFAULT_PARSER_CONFIG.recoveryEnabled, this.recoveryEnabled && (this.attemptInRepetitionRecovery = E);
          }, t2.prototype.getTokenToInsert = function(t3) {
            var e2 = r.createTokenInstance(t3, "", NaN, NaN, NaN, NaN, NaN, NaN);
            return e2.isInsertedInRecovery = true, e2;
          }, t2.prototype.canTokenTypeBeInsertedInRecovery = function(t3) {
            return true;
          }, t2.prototype.tryInRepetitionRecovery = function(t3, e2, n2, r2) {
            for (var a2 = this, u2 = this.findReSyncTokenType(), s2 = this.exportLexerState(), c2 = [], l2 = false, E2 = this.LA(1), p = this.LA(1), f = function() {
              var t4 = a2.LA(0), e3 = a2.errorMessageProvider.buildMismatchTokenMessage({ expected: r2, actual: E2, previous: t4, ruleName: a2.getCurrRuleFullName() }), n3 = new o.MismatchedTokenException(e3, E2, a2.LA(0));
              n3.resyncedTokens = i.dropRight(c2), a2.SAVE_ERROR(n3);
            }; !l2; ) {
              if (this.tokenMatcher(p, r2))
                return void f();
              if (n2.call(this))
                return f(), void t3.apply(this, e2);
              this.tokenMatcher(p, u2) ? l2 = true : (p = this.SKIP_TOKEN(), this.addToResyncTokens(p, c2));
            }
            this.importLexerState(s2);
          }, t2.prototype.shouldInRepetitionRecoveryBeTried = function(t3, e2) {
            return void 0 !== t3 && void 0 !== e2 && (!this.tokenMatcher(this.LA(1), t3) && (!this.isBackTracking() && !this.canPerformInRuleRecovery(t3, this.getFollowsForInRuleRecovery(t3, e2))));
          }, t2.prototype.getFollowsForInRuleRecovery = function(t3, e2) {
            var n2 = this.getCurrentGrammarPath(t3, e2);
            return this.getNextPossibleTokenTypes(n2);
          }, t2.prototype.tryInRuleRecovery = function(t3, e2) {
            if (this.canRecoverWithSingleTokenInsertion(t3, e2))
              return this.getTokenToInsert(t3);
            if (this.canRecoverWithSingleTokenDeletion(t3)) {
              var n2 = this.SKIP_TOKEN();
              return this.consumeToken(), n2;
            }
            throw new c("sad sad panda");
          }, t2.prototype.canPerformInRuleRecovery = function(t3, e2) {
            return this.canRecoverWithSingleTokenInsertion(t3, e2) || this.canRecoverWithSingleTokenDeletion(t3);
          }, t2.prototype.canRecoverWithSingleTokenInsertion = function(t3, e2) {
            var n2 = this;
            if (!this.canTokenTypeBeInsertedInRecovery(t3))
              return false;
            if (i.isEmpty(e2))
              return false;
            var r2 = this.LA(1);
            return void 0 !== i.find(e2, function(t4) {
              return n2.tokenMatcher(r2, t4);
            });
          }, t2.prototype.canRecoverWithSingleTokenDeletion = function(t3) {
            return this.tokenMatcher(this.LA(2), t3);
          }, t2.prototype.isInCurrentRuleReSyncSet = function(t3) {
            var e2 = this.getCurrFollowKey(), n2 = this.getFollowSetFromFollowKey(e2);
            return i.contains(n2, t3);
          }, t2.prototype.findReSyncTokenType = function() {
            for (var t3 = this.flattenFollowSet(), e2 = this.LA(1), n2 = 2; ; ) {
              var r2 = e2.tokenType;
              if (i.contains(t3, r2))
                return r2;
              e2 = this.LA(n2), n2++;
            }
          }, t2.prototype.getCurrFollowKey = function() {
            if (1 === this.RULE_STACK.length)
              return e.EOF_FOLLOW_KEY;
            var t3 = this.getLastExplicitRuleShortName(), n2 = this.getLastExplicitRuleOccurrenceIndex(), r2 = this.getPreviousExplicitRuleShortName();
            return { ruleName: this.shortRuleNameToFullName(t3), idxInCallingRule: n2, inRule: this.shortRuleNameToFullName(r2) };
          }, t2.prototype.buildFullFollowKeyStack = function() {
            var t3 = this, n2 = this.RULE_STACK, r2 = this.RULE_OCCURRENCE_STACK;
            return i.isEmpty(this.LAST_EXPLICIT_RULE_STACK) || (n2 = i.map(this.LAST_EXPLICIT_RULE_STACK, function(e2) {
              return t3.RULE_STACK[e2];
            }), r2 = i.map(this.LAST_EXPLICIT_RULE_STACK, function(e2) {
              return t3.RULE_OCCURRENCE_STACK[e2];
            })), i.map(n2, function(i2, o2) {
              return 0 === o2 ? e.EOF_FOLLOW_KEY : { ruleName: t3.shortRuleNameToFullName(i2), idxInCallingRule: r2[o2], inRule: t3.shortRuleNameToFullName(n2[o2 - 1]) };
            });
          }, t2.prototype.flattenFollowSet = function() {
            var t3 = this, e2 = i.map(this.buildFullFollowKeyStack(), function(e3) {
              return t3.getFollowSetFromFollowKey(e3);
            });
            return i.flatten(e2);
          }, t2.prototype.getFollowSetFromFollowKey = function(t3) {
            if (t3 === e.EOF_FOLLOW_KEY)
              return [r.EOF];
            var n2 = t3.ruleName + t3.idxInCallingRule + a.IN + t3.inRule;
            return this.resyncFollows.get(n2);
          }, t2.prototype.addToResyncTokens = function(t3, e2) {
            return this.tokenMatcher(t3, r.EOF) || e2.push(t3), e2;
          }, t2.prototype.reSyncTo = function(t3) {
            for (var e2 = [], n2 = this.LA(1); false === this.tokenMatcher(n2, t3); )
              n2 = this.SKIP_TOKEN(), this.addToResyncTokens(n2, e2);
            return i.dropRight(e2);
          }, t2.prototype.attemptInRepetitionRecovery = function(t3, e2, n2, r2, i2, o2) {
          }, t2.prototype.getCurrentGrammarPath = function(t3, e2) {
            return { ruleStack: this.getHumanReadableRuleStack(), occurrenceStack: i.cloneArr(this.RULE_OCCURRENCE_STACK), lastTok: t3, lastTokOccurrence: e2 };
          }, t2.prototype.getHumanReadableRuleStack = function() {
            var t3 = this;
            return i.isEmpty(this.LAST_EXPLICIT_RULE_STACK) ? i.map(this.RULE_STACK, function(e2) {
              return t3.shortRuleNameToFullName(e2);
            }) : i.map(this.LAST_EXPLICIT_RULE_STACK, function(e2) {
              return t3.shortRuleNameToFullName(t3.RULE_STACK[e2]);
            });
          }, t2;
        }();
        function E(t2, e2, n2, i2, o2, a2) {
          var u2 = this.getKeyForAutomaticLookahead(i2, o2), s2 = this.firstAfterRepMap.get(u2);
          if (void 0 === s2) {
            var c2 = this.getCurrRuleFullName();
            s2 = new a2(this.getGAstProductions().get(c2), o2).startWalking(), this.firstAfterRepMap.put(u2, s2);
          }
          var l2 = s2.token, E2 = s2.occurrence, p = s2.isEndOfRule;
          1 === this.RULE_STACK.length && p && void 0 === l2 && (l2 = r.EOF, E2 = 1), this.shouldInRepetitionRecoveryBeTried(l2, E2) && this.tryInRepetitionRecovery(t2, e2, n2, l2);
        }
        e.Recoverable = l, e.attemptInRepetitionRecovery = E;
      }, function(t, e, n) {
        "use strict";
        n.d(e, "a", function() {
          return TurtleParser2;
        });
        var r, i = n(1), o = (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        }), a = function() {
          return (a = Object.assign || function(t2) {
            for (var e2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
              for (var i2 in e2 = arguments[n2])
                Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
            return t2;
          }).apply(this, arguments);
        }, u = n(27), s = u.turtleTokenTypes, c = u.turtleTokenMap, TurtleParser2 = function(t2) {
          function TurtleParser3(e2, n2, r2, o2) {
            void 0 === e2 && (e2 = {}), void 0 === n2 && (n2 = s), void 0 === r2 && (r2 = n2), void 0 === o2 && (o2 = true);
            var u2 = t2.call(this, n2, a({ outputCst: true, recoveryEnabled: true }, e2)) || this;
            return u2.namespacesMap = {}, u2.semanticErrors = [], u2.resetManagedState = function() {
              u2.namespacesMap = {}, u2.semanticErrors = [];
            }, u2.tokenize = function(t3) {
              return u2.lexer.tokenize(t3).tokens;
            }, u2.parse = function(t3, e3) {
              void 0 === e3 && (e3 = "standard"), u2.input = u2.lexer.tokenize(t3).tokens;
              var n3 = u2.turtleDoc(0, [e3]), r3 = u2.errors.slice(), i2 = u2.semanticErrors.slice();
              return u2.resetManagedState(), { errors: r3, semanticErrors: i2, cst: n3 };
            }, u2.turtleDoc = u2.RULE("turtleDoc", function(t3) {
              var e3 = "stardog" === t3;
              u2.MANY(function() {
                return u2.SUBRULE(u2.statement, { ARGS: [e3] });
              });
            }), u2.statement = u2.RULE("statement", function(t3) {
              u2.OR([{ ALT: function() {
                return u2.SUBRULE(u2.directive);
              } }, { ALT: function() {
                u2.SUBRULE(u2.triples, { ARGS: [t3] }), u2.CONSUME(c.Period);
              } }]);
            }), u2.directive = u2.RULE("directive", function() {
              u2.OR([{ ALT: function() {
                return u2.SUBRULE(u2.prefixID);
              } }, { ALT: function() {
                return u2.SUBRULE(u2.base);
              } }, { ALT: function() {
                return u2.SUBRULE(u2.sparqlPrefix);
              } }, { ALT: function() {
                return u2.SUBRULE(u2.sparqlBase);
              } }]);
            }), u2.prefixID = u2.RULE("prefixID", function() {
              u2.CONSUME(c.TTL_PREFIX);
              var t3 = u2.CONSUME(c.PNAME_NS), e3 = u2.CONSUME(c.IRIREF), n3 = t3.image.slice(0, -1), r3 = e3.image;
              u2.namespacesMap[n3] = r3, u2.CONSUME(c.Period);
            }), u2.base = u2.RULE("base", function() {
              u2.CONSUME(c.TTL_BASE), u2.CONSUME(c.IRIREF), u2.CONSUME(c.Period);
            }), u2.sparqlBase = u2.RULE("sparqlBase", function() {
              u2.CONSUME(c.BASE), u2.CONSUME(c.IRIREF);
            }), u2.sparqlPrefix = u2.RULE("sparqlPrefix", function() {
              u2.CONSUME(c.PREFIX);
              var t3 = u2.CONSUME(c.PNAME_NS), e3 = u2.CONSUME(c.IRIREF), n3 = t3.image.slice(0, -1), r3 = e3.image;
              u2.namespacesMap[n3] = r3;
            }), u2.triples = u2.RULE("triples", function(t3) {
              u2.OR([{ ALT: function() {
                u2.SUBRULE(u2.subject), u2.SUBRULE1(u2.predicateObjectList, { ARGS: [t3] });
              } }, { GATE: function() {
                return Boolean(t3);
              }, ALT: function() {
                u2.SUBRULE(u2.EmbeddedTriplePattern), u2.SUBRULE(u2.predicateObjectList);
              } }, { ALT: function() {
                u2.SUBRULE(u2.blankNodePropertyList, { ARGS: [t3] }), u2.OPTION(function() {
                  return u2.SUBRULE2(u2.predicateObjectList, { ARGS: [t3] });
                });
              } }]);
            }), u2.EmbeddedTriplePattern = u2.RULE("EmbeddedTriplePattern", function() {
              u2.CONSUME(c.LEmbed), u2.SUBRULE(u2.triples), u2.CONSUME(c.REmbed);
            }), u2.predicateObjectList = u2.RULE("predicateObjectList", function(t3) {
              u2.SUBRULE(u2.verb), u2.OR([{ ALT: function() {
                return u2.SUBRULE(u2.objectList, { ARGS: [t3] });
              } }, { GATE: function() {
                return Boolean(t3);
              }, ALT: function() {
                u2.SUBRULE(u2.EmbeddedPredicateObjectList), u2.SUBRULE(u2.object, { ARGS: [t3] });
              } }]), u2.MANY(function() {
                u2.CONSUME(c.Semicolon), u2.OPTION(function() {
                  u2.SUBRULE1(u2.verb), u2.OR1([{ ALT: function() {
                    return u2.SUBRULE1(u2.objectList, { ARGS: [t3] });
                  } }, { GATE: function() {
                    return Boolean(t3);
                  }, ALT: function() {
                    u2.SUBRULE1(u2.EmbeddedPredicateObjectList), u2.SUBRULE1(u2.object, { ARGS: [t3] });
                  } }]);
                });
              });
            }), u2.EmbeddedPredicateObjectList = u2.RULE("EmbeddedPredicateObjectList", function() {
              u2.CONSUME(c.LCurly), u2.SUBRULE(u2.predicateObjectList), u2.CONSUME(c.RCurly);
            }), u2.subject = u2.RULE("subject", function() {
              u2.OR([{ ALT: function() {
                return u2.SUBRULE(u2.iri);
              } }, { ALT: function() {
                return u2.SUBRULE(u2.BlankNode);
              } }, { ALT: function() {
                return u2.SUBRULE(u2.collection);
              } }]);
            }), u2.predicate = u2.RULE("predicate", function() {
              u2.SUBRULE(u2.iri);
            }), u2.objectList = u2.RULE("objectList", function(t3) {
              u2.SUBRULE(u2.object, { ARGS: [t3] }), u2.MANY(function() {
                u2.CONSUME(c.Comma), u2.SUBRULE1(u2.object, { ARGS: [t3] });
              });
            }), u2.verb = u2.RULE("verb", function() {
              u2.OR([{ ALT: function() {
                return u2.SUBRULE(u2.predicate);
              } }, { ALT: function() {
                return u2.CONSUME(c.A);
              } }]);
            }), u2.literal = u2.RULE("literal", function() {
              u2.OR([{ ALT: function() {
                return u2.SUBRULE(u2.RDFLiteral);
              } }, { ALT: function() {
                return u2.SUBRULE(u2.NumericLiteral);
              } }, { ALT: function() {
                return u2.SUBRULE(u2.BooleanLiteral);
              } }]);
            }), u2.blankNodePropertyList = u2.RULE("blankNodePropertyList", function(t3) {
              u2.CONSUME(c.LBracket), u2.SUBRULE(u2.predicateObjectList, { ARGS: [t3] }), u2.CONSUME(c.RBracket);
            }), u2.object = u2.RULE("object", function(t3) {
              u2.OR([{ ALT: function() {
                return u2.SUBRULE(u2.iri);
              } }, { ALT: function() {
                return u2.SUBRULE(u2.BlankNode);
              } }, { ALT: function() {
                return u2.SUBRULE(u2.collection);
              } }, { ALT: function() {
                return u2.SUBRULE(u2.blankNodePropertyList, { ARGS: [t3] });
              } }, { ALT: function() {
                return u2.SUBRULE(u2.literal);
              } }]);
            }), u2.collection = u2.RULE("collection", function() {
              u2.CONSUME(c.LParen), u2.MANY(function() {
                return u2.SUBRULE(u2.object);
              }), u2.CONSUME(c.RParen);
            }), u2.NumericLiteral = u2.RULE("NumericLiteral", function() {
              u2.OR([{ ALT: function() {
                return u2.CONSUME(c.INTEGER);
              } }, { ALT: function() {
                return u2.CONSUME(c.DECIMAL);
              } }, { ALT: function() {
                return u2.CONSUME(c.DOUBLE);
              } }]);
            }), u2.RDFLiteral = u2.RULE("RDFLiteral", function() {
              u2.SUBRULE(u2.String), u2.OPTION(function() {
                u2.OR([{ ALT: function() {
                  return u2.CONSUME(c.LANGTAG);
                } }, { ALT: function() {
                  u2.CONSUME(c.DoubleCaret), u2.SUBRULE(u2.iri);
                } }]);
              });
            }), u2.BooleanLiteral = u2.RULE("BooleanLiteral", function() {
              u2.OR([{ ALT: function() {
                return u2.CONSUME(c.TRUE);
              } }, { ALT: function() {
                return u2.CONSUME(c.FALSE);
              } }]);
            }), u2.String = u2.RULE("String", function() {
              u2.OR([{ ALT: function() {
                return u2.CONSUME(c.STRING_LITERAL_QUOTE);
              } }, { ALT: function() {
                return u2.CONSUME(c.STRING_LITERAL_SINGLE_QUOTE);
              } }, { ALT: function() {
                return u2.CONSUME(c.STRING_LITERAL_LONG_SINGLE_QUOTE);
              } }, { ALT: function() {
                return u2.CONSUME(c.STRING_LITERAL_LONG_QUOTE);
              } }]);
            }), u2.iri = u2.RULE("iri", function() {
              u2.OR([{ ALT: function() {
                return u2.CONSUME(c.IRIREF);
              } }, { ALT: function() {
                return u2.SUBRULE(u2.PrefixedName);
              } }]);
            }), u2.PrefixedName = u2.RULE("PrefixedName", function() {
              var t3 = u2.OR([{ ALT: function() {
                return u2.CONSUME(c.PNAME_LN);
              } }, { ALT: function() {
                return u2.CONSUME(c.PNAME_NS);
              } }]);
              t3.image.slice(0, t3.image.indexOf(":")) in u2.namespacesMap || u2.semanticErrors.push({ name: "NoNamespacePrefixError", message: "A prefix was used for which there was no namespace defined.", token: t3, context: { ruleStack: u2.getHumanReadableRuleStack(), ruleOccurrenceStack: u2.RULE_OCCURRENCE_STACK.slice() }, resyncedTokens: [] });
            }), u2.BlankNode = u2.RULE("BlankNode", function() {
              u2.OR([{ ALT: function() {
                return u2.CONSUME(c.BLANK_NODE_LABEL);
              } }, { ALT: function() {
                return u2.CONSUME(c.ANON);
              } }]);
            }), u2.lexer = new i.Lexer(r2), o2 && i.Parser.performSelfAnalysis(u2), u2;
          }
          return o(TurtleParser3, t2), TurtleParser3;
        }(i.Parser);
      }, function(t, e, n) {
        "use strict";
        n.d(e, "a", function() {
          return StardogSparqlParser;
        });
        var r, i = n(21), o = n(1), a = (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        }), u = n(9), s = u.sparqlTokenMap, c = u.stardogSparqlTokens, StardogSparqlParser = function(t2) {
          function StardogSparqlParser2(e2, n2, r2) {
            void 0 === n2 && (n2 = c);
            var i2 = t2.call(this, e2, n2) || this;
            return i2.ValidateQuery = i2.RULE("ValidateQuery", function() {
              i2.CONSUME(s.VALIDATE), i2.OR([{ ALT: function() {
                return i2.CONSUME(s.ALL);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.MultiGraphRef);
              } }, { ALT: function() {
                i2.AT_LEAST_ONE(function() {
                  return i2.SUBRULE1(i2.iri);
                }), i2.OPTION(function() {
                  return i2.SUBRULE2(i2.MultiGraphRef);
                });
              } }]), i2.OPTION1(function() {
                return i2.SUBRULE3(i2.UsingShapesClause);
              }), i2.OPTION2(function() {
                return i2.SUBRULE4(i2.LimitClause);
              }), i2.OPTION3(function() {
                return i2.SUBRULE5(i2.LimitPerShapeClause);
              });
            }), i2.MultiGraphRef = i2.RULE("MultiGraphRef", function() {
              i2.CONSUME(s.GRAPH), i2.AT_LEAST_ONE(function() {
                return i2.SUBRULE(i2.iri);
              });
            }), i2.UsingShapesClause = i2.RULE("UsingShapesClause", function() {
              i2.CONSUME(s.USING), i2.CONSUME(s.SHAPES), i2.OR([{ ALT: function() {
                return i2.AT_LEAST_ONE(function() {
                  return i2.SUBRULE(i2.iri);
                });
              } }, { ALT: function() {
                return i2.SUBRULE1(i2.MultiGraphRef);
              } }, { ALT: function() {
                return i2.SUBRULE2(i2.QuadData);
              } }]);
            }), i2.LimitPerShapeClause = i2.RULE("LimitPerShapeClause", function() {
              i2.CONSUME(s.LIMIT), i2.CONSUME(s.PER), i2.CONSUME(s.SHAPE), i2.CONSUME(s.INTEGER);
            }), i2.Query = i2.OVERRIDE_RULE("Query", function() {
              i2.OR([{ ALT: function() {
                return i2.SUBRULE(i2.SelectQuery);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.ConstructQuery);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.DescribeQuery);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.AskQuery);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.PathQuery);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.ValidateQuery);
              } }]), i2.SUBRULE(i2.ValuesClause);
            }), i2.PathQuery = i2.RULE("PathQuery", function() {
              i2.SUBRULE(i2.PathSpec), i2.MANY(function() {
                return i2.SUBRULE(i2.DatasetClause);
              }), i2.CONSUME(s.START), i2.SUBRULE(i2.PathTerminal), i2.CONSUME(s.END), i2.SUBRULE1(i2.PathTerminal), i2.SUBRULE(i2.Via), i2.OPTION(function() {
                return i2.SUBRULE(i2.MaxLength);
              }), i2.SUBRULE(i2.SolutionModifier);
            }), i2.Via = i2.RULE("Via", function() {
              i2.CONSUME(s.VIA), i2.OR([{ ALT: function() {
                return i2.SUBRULE(i2.GroupGraphPattern);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.Var);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.Path);
              } }]);
            }), i2.PathTerminal = i2.RULE("PathTerminal", function() {
              i2.SUBRULE(i2.Var), i2.OPTION(function() {
                i2.OR([{ ALT: function() {
                  i2.CONSUME(s.Equals), i2.SUBRULE(i2.Constant);
                } }, { ALT: function() {
                  return i2.SUBRULE(i2.GroupGraphPattern);
                } }]);
              });
            }), i2.PathSpec = i2.RULE("PathSpec", function() {
              i2.OR([{ ALT: function() {
                return i2.CONSUME(s.PATHS);
              } }, { ALT: function() {
                return i2.CONSUME(s.PATHS_SHORTEST);
              } }, { ALT: function() {
                return i2.CONSUME(s.PATHS_ALL);
              } }]), i2.OPTION1(function() {
                return i2.CONSUME(s.CYCLIC);
              });
            }), i2.GraphPatternNotTriples = i2.OVERRIDE_RULE("GraphPatternNotTriples", function() {
              i2.OR([{ ALT: function() {
                return i2.SUBRULE(i2.GroupOrUnionGraphPattern);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.OptionalGraphPattern);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.MinusGraphPattern);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.GraphGraphPattern);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.ServiceGraphPattern);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.Filter);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.Bind);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.Unnest);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.InlineData);
              } }]);
            }), i2.TriplesSameSubject = i2.OVERRIDE_RULE("TriplesSameSubject", function() {
              i2.OR([{ ALT: function() {
                i2.SUBRULE(i2.VarOrTerm), i2.SUBRULE(i2.PropertyListNotEmpty);
              } }, { ALT: function() {
                i2.SUBRULE(i2.EmbeddedTriplePattern), i2.SUBRULE1(i2.PropertyListNotEmpty, { ARGS: [true] });
              } }, { ALT: function() {
                i2.SUBRULE(i2.TriplesNode), i2.SUBRULE(i2.PropertyList);
              } }]);
            }), i2.PropertyListNotEmpty = i2.OVERRIDE_RULE("PropertyListNotEmpty", function(t3) {
              i2.SUBRULE(i2.Verb), i2.OR([{ ALT: function() {
                i2.SUBRULE(i2.ObjectList);
              } }, { GATE: function() {
                return !t3;
              }, ALT: function() {
                i2.SUBRULE(i2.EmbeddedPropertyList), i2.SUBRULE(i2.Object);
              } }]), i2.MANY(function() {
                i2.CONSUME(s.Semicolon), i2.OPTION(function() {
                  i2.SUBRULE1(i2.Verb), i2.OR1([{ ALT: function() {
                    i2.SUBRULE1(i2.ObjectList);
                  } }, { GATE: function() {
                    return !t3;
                  }, ALT: function() {
                    i2.SUBRULE1(i2.EmbeddedPropertyList), i2.SUBRULE1(i2.Object);
                  } }]);
                });
              });
            }), i2.EmbeddedPropertyList = i2.RULE("EmbeddedPropertyList", function() {
              i2.CONSUME(s.LCurly), i2.SUBRULE(i2.PropertyListNotEmpty, { ARGS: [true] }), i2.CONSUME(s.RCurly);
            }), i2.Object = i2.OVERRIDE_RULE("Object", function() {
              i2.OR([{ ALT: function() {
                return i2.SUBRULE(i2.GraphNode);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.EmbeddedTriplePattern);
              } }]);
            }), i2.TriplesSameSubjectPath = i2.OVERRIDE_RULE("TriplesSameSubjectPath", function() {
              i2.OR([{ ALT: function() {
                i2.SUBRULE(i2.VarOrTerm), i2.SUBRULE(i2.PropertyListPathNotEmpty);
              } }, { ALT: function() {
                i2.SUBRULE(i2.EmbeddedTriplePattern), i2.SUBRULE1(i2.PropertyListPathNotEmpty, { ARGS: [true] });
              } }, { ALT: function() {
                i2.SUBRULE(i2.TriplesNodePath), i2.SUBRULE(i2.PropertyListPath);
              } }]);
            }), i2.PropertyListPathNotEmpty = i2.OVERRIDE_RULE("PropertyListPathNotEmpty", function(t3) {
              i2.OR([{ ALT: function() {
                i2.OR1([{ ALT: function() {
                  return i2.SUBRULE(i2.VerbPath);
                } }, { ALT: function() {
                  return i2.SUBRULE1(i2.VerbSimple);
                } }]), i2.SUBRULE(i2.ObjectListPath);
              } }, { GATE: function() {
                return !t3;
              }, ALT: function() {
                i2.SUBRULE(i2.Verb), i2.SUBRULE(i2.EmbeddedPropertyListPath), i2.SUBRULE(i2.ObjectPath);
              } }]), i2.MANY(function() {
                i2.CONSUME(s.Semicolon), i2.OPTION(function() {
                  i2.OR2([{ ALT: function() {
                    i2.OR3([{ ALT: function() {
                      return i2.SUBRULE1(i2.VerbPath);
                    } }, { ALT: function() {
                      return i2.SUBRULE2(i2.VerbSimple);
                    } }]), i2.SUBRULE1(i2.ObjectListPath);
                  } }, { GATE: function() {
                    return !t3;
                  }, ALT: function() {
                    i2.SUBRULE1(i2.Verb), i2.SUBRULE1(i2.EmbeddedPropertyListPath), i2.SUBRULE1(i2.ObjectPath);
                  } }]);
                });
              });
            }), i2.EmbeddedPropertyListPath = i2.RULE("EmbeddedPropertyListPath", function() {
              i2.CONSUME(s.LCurly), i2.SUBRULE(i2.PropertyListPathNotEmpty, { ARGS: [true] }), i2.CONSUME(s.RCurly);
            }), i2.GraphNodePath = i2.OVERRIDE_RULE("GraphNodePath", function() {
              i2.OR([{ ALT: function() {
                return i2.SUBRULE(i2.VarOrTermOrEmbeddedTriplePattern);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.TriplesNodePath);
              } }]);
            }), i2.EmbeddedTriplePattern = i2.RULE("EmbeddedTriplePattern", function() {
              i2.CONSUME(s.LEmbed), i2.SUBRULE(i2.VarOrBlankNodeOrIriOrLit), i2.SUBRULE(i2.Verb), i2.SUBRULE1(i2.VarOrBlankNodeOrIriOrLit), i2.CONSUME(s.REmbed);
            }), i2.VarOrTermOrEmbeddedTriplePattern = i2.RULE("VarOrTermOrEmbeddedTriplePattern", function() {
              i2.OR([{ ALT: function() {
                return i2.SUBRULE(i2.Var);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.GraphTerm);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.EmbeddedTriplePattern);
              } }]);
            }), i2.Bind = i2.OVERRIDE_RULE("Bind", function() {
              i2.CONSUME(s.BIND), i2.CONSUME(s.LParen), i2.SUBRULE(i2.ExpressionOrEmbeddedTriplePattern), i2.CONSUME(s.AS), i2.SUBRULE(i2.Var), i2.CONSUME(s.RParen);
            }), i2.ExpressionOrEmbeddedTriplePattern = i2.RULE("ExpressionOrEmbeddedTriplePattern", function() {
              i2.OR([{ ALT: function() {
                return i2.SUBRULE(i2.Expression);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.EmbeddedTriplePattern);
              } }]);
            }), i2.VarOrBlankNodeOrIriOrLit = i2.RULE("VarOrBlankNodeOrIriOrLit", function() {
              i2.OR([{ ALT: function() {
                return i2.SUBRULE(i2.Var);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BlankNode);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.iri);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.RDFLiteral);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.NumericLiteral);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BooleanLiteral);
              } }]);
            }), i2.Unnest = i2.RULE("Unnest", function() {
              i2.CONSUME(s.UNNEST), i2.CONSUME(s.LParen), i2.SUBRULE(i2.Expression), i2.CONSUME(s.AS), i2.SUBRULE(i2.Var), i2.CONSUME(s.RParen);
            }), i2.BuiltInCall = i2.OVERRIDE_RULE("BuiltInCall", function() {
              i2.OR([{ ALT: function() {
                return i2.SUBRULE(i2.Aggregate);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_STR);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_LANG);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_LANGMATCHES);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_DATATYPE);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_BOUND);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_IRI);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_URI);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_BNODE);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_RAND);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_ABS);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_CEIL);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_FLOOR);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_ROUND);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_CONCAT);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.SubstringExpression);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_STRLEN);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.StrReplaceExpression);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_UCASE);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_LCASE);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_ENCODE_FOR_URI);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_CONTAINS);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_STRSTARTS);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_STRENDS);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_STRBEFORE);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_STRAFTER);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_YEAR);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_MONTH);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_DAY);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_HOURS);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_MINUTES);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_SECONDS);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_TIMEZONE);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_TZ);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_NOW);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_UUID);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_STRUUID);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_MD5);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_SHA1);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_SHA256);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_SHA384);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_SHA512);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_COALESCE);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_IF);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_STRLANG);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_STRDT);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_sameTerm);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_isIRI);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_isURI);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_isBLANK);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_isLITERAL);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.BuiltInCall_isNUMERIC);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.RegexExpression);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.ExistsFunction);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.NotExistsFunction);
              } }, { ALT: function() {
                return i2.SUBRULE(i2.StardogOrCustomFunction);
              } }]);
            }), i2.StardogOrCustomFunction = i2.RULE("StardogOrCustomFunction", function() {
              i2.CONSUME(s.UNKNOWN), i2.SUBRULE(i2.ExpressionList);
            }), i2.ConstructTemplate = i2.OVERRIDE_RULE("ConstructTemplate", function() {
              i2.CONSUME(s.LCurly), i2.OPTION(function() {
                return i2.SUBRULE(i2.Quads);
              }), i2.CONSUME(s.RCurly);
            }), r2 || o.Parser.performSelfAnalysis(i2), i2;
          }
          return a(StardogSparqlParser2, t2), StardogSparqlParser2;
        }(i.a);
      }, function(t, e, n) {
        "use strict";
        var r, i = this && this.__extends || (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        });
        Object.defineProperty(e, "__esModule", { value: true });
        var o = n(22), a = n(10), u = n(30), s = n(4), c = n(31), l = n(7), E = n(6), p = function(t2) {
          function e2(e3) {
            var n2 = t2.call(this) || this;
            return n2.topProd = e3, n2.follows = new a.HashTable(), n2;
          }
          return i(e2, t2), e2.prototype.startWalking = function() {
            return this.walk(this.topProd), this.follows;
          }, e2.prototype.walkTerminal = function(t3, e3, n2) {
          }, e2.prototype.walkProdRef = function(t3, e3, n2) {
            var r2 = f(t3.referencedRule, t3.idx) + this.topProd.name, i2 = e3.concat(n2), o2 = new E.Flat({ definition: i2 }), a2 = u.first(o2);
            this.follows.put(r2, a2);
          }, e2;
        }(o.RestWalker);
        function f(t2, e2) {
          return t2.name + e2 + c.IN;
        }
        e.ResyncFollowsWalker = p, e.computeAllProdsFollows = function(t2) {
          var e2 = new a.HashTable();
          return s.forEach(t2, function(t3) {
            var n2 = new p(t3).startWalking();
            e2.putAll(n2);
          }), e2;
        }, e.buildBetweenProdsFollowPrefix = f, e.buildInProdFollowPrefix = function(t2) {
          return l.tokenName(t2.terminalType) + t2.idx + c.IN;
        };
      }, function(t, e, n) {
        "use strict";
        var r, i = this && this.__extends || (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        });
        Object.defineProperty(e, "__esModule", { value: true });
        var o = n(28), a = n(7), u = n(23), s = n(4), c = n(39), l = new o.RegExpParser(), E = "PATTERN";
        function p(t2) {
          var e2 = s.filter(t2, function(t3) {
            return !s.has(t3, E);
          });
          return { errors: s.map(e2, function(t3) {
            return { message: "Token Type: ->" + a.tokenName(t3) + "<- missing static 'PATTERN' property", type: u.LexerDefinitionErrorType.MISSING_PATTERN, tokenTypes: [t3] };
          }), valid: s.difference(t2, e2) };
        }
        function f(t2) {
          var e2 = s.filter(t2, function(t3) {
            var e3 = t3[E];
            return !(s.isRegExp(e3) || s.isFunction(e3) || s.has(e3, "exec") || s.isString(e3));
          });
          return { errors: s.map(e2, function(t3) {
            return { message: "Token Type: ->" + a.tokenName(t3) + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.", type: u.LexerDefinitionErrorType.INVALID_PATTERN, tokenTypes: [t3] };
          }), valid: s.difference(t2, e2) };
        }
        e.DEFAULT_MODE = "defaultMode", e.MODES = "modes", e.SUPPORT_STICKY = "boolean" == typeof new RegExp("(?:)").sticky, e.disableSticky = function() {
          e.SUPPORT_STICKY = false;
        }, e.enableSticky = function() {
          e.SUPPORT_STICKY = true;
        }, e.analyzeTokenTypes = function(t2, n2) {
          n2 = s.defaults(n2, { useSticky: e.SUPPORT_STICKY, debug: false, safeMode: false, positionTracking: "full", lineTerminatorCharacters: ["\r", "\n"] });
          var r2 = s.reject(t2, function(t3) {
            return t3[E] === u.Lexer.NA;
          }), i2 = false, o2 = s.map(r2, function(t3) {
            var e2 = t3[E];
            if (s.isRegExp(e2)) {
              var r3 = e2.source;
              return 1 === r3.length && "^" !== r3 && "$" !== r3 && "." !== r3 ? r3 : 2 !== r3.length || "\\" !== r3[0] || s.contains(["d", "D", "s", "S", "t", "r", "n", "t", "0", "c", "b", "B", "f", "v", "w", "W"], r3[1]) ? n2.useSticky ? C(e2) : m(e2) : r3[1];
            }
            if (s.isFunction(e2))
              return i2 = true, { exec: e2 };
            if (s.has(e2, "exec"))
              return i2 = true, e2;
            if ("string" == typeof e2) {
              if (1 === e2.length)
                return e2;
              var o3 = e2.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&"), a2 = new RegExp(o3);
              return n2.useSticky ? C(a2) : m(a2);
            }
            throw Error("non exhaustive match");
          }), l2 = s.map(r2, function(t3) {
            return t3.tokenTypeIdx;
          }), p2 = s.map(r2, function(t3) {
            var e2 = t3.GROUP;
            if (e2 !== u.Lexer.SKIPPED) {
              if (s.isString(e2))
                return e2;
              if (s.isUndefined(e2))
                return false;
              throw Error("non exhaustive match");
            }
          }), f2 = s.map(r2, function(t3) {
            var e2 = t3.LONGER_ALT;
            if (e2)
              return s.indexOf(r2, e2);
          }), L2 = s.map(r2, function(t3) {
            return t3.PUSH_MODE;
          }), S2 = s.map(r2, function(t3) {
            return s.has(t3, "POP_MODE");
          }), h2 = v(n2.lineTerminatorCharacters), T2 = s.map(r2, function(t3) {
            return false;
          });
          "onlyOffset" !== n2.positionTracking && (T2 = s.map(r2, function(t3) {
            return s.has(t3, "LINE_BREAKS") ? t3.LINE_BREAKS : false === _(t3, h2) ? c.canMatchCharCode(h2, t3.PATTERN) : void 0;
          }));
          var U2 = s.map(r2, I), R2 = s.map(o2, y), d2 = s.reduce(r2, function(t3, e2) {
            var n3 = e2.GROUP;
            return s.isString(n3) && n3 !== u.Lexer.SKIPPED && (t3[n3] = []), t3;
          }, {}), O2 = s.map(o2, function(t3, e2) {
            return { pattern: o2[e2], longerAlt: f2[e2], canLineTerminator: T2[e2], isCustom: U2[e2], short: R2[e2], group: p2[e2], push: L2[e2], pop: S2[e2], tokenTypeIdx: l2[e2], tokenType: r2[e2] };
          });
          function N2(t3, e2, n3) {
            void 0 === t3[e2] && (t3[e2] = []), t3[e2].push(n3);
          }
          var A2 = true, P2 = [];
          return n2.safeMode || (P2 = s.reduce(r2, function(t3, e2, r3) {
            if ("string" == typeof e2.PATTERN) {
              var i3 = e2.PATTERN.charCodeAt(0);
              N2(t3, i3, O2[r3]);
            } else if (s.isArray(e2.START_CHARS_HINT))
              s.forEach(e2.START_CHARS_HINT, function(e3) {
                var n3 = "string" == typeof e3 ? e3.charCodeAt(0) : e3;
                N2(t3, n3, O2[r3]);
              });
            else if (s.isRegExp(e2.PATTERN))
              if (e2.PATTERN.unicode)
                A2 = false, n2.ensureOptimizations && s.PRINT_ERROR(c.failedOptimizationPrefixMsg + "	Unable to analyze < " + e2.PATTERN.toString() + " > pattern.\n	The regexp unicode flag is not currently supported by the regexp-to-ast library.\n	This will disable the lexer's first char optimizations.\n	For details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE");
              else {
                var o3 = c.getStartCodes(e2.PATTERN, n2.ensureOptimizations);
                s.isEmpty(o3) && (A2 = false), s.forEach(o3, function(e3) {
                  N2(t3, e3, O2[r3]);
                });
              }
            else
              n2.ensureOptimizations && s.PRINT_ERROR(c.failedOptimizationPrefixMsg + "	TokenType: <" + a.tokenName(e2) + "> is using a custom token pattern without providing <start_chars_hint> parameter.\n	This will disable the lexer's first char optimizations.\n	For details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE"), A2 = false;
            return t3;
          }, [])), A2 && P2.length < 65536 && (P2 = s.packArray(P2)), { emptyGroups: d2, patternIdxToConfig: O2, charCodeToPatternIdxToConfig: P2, hasCustom: i2, canBeOptimized: A2 };
        }, e.validatePatterns = function(t2, e2) {
          var n2 = [], r2 = p(t2);
          n2 = n2.concat(r2.errors);
          var i2 = f(r2.valid), o2 = i2.valid;
          return n2 = (n2 = (n2 = (n2 = (n2 = n2.concat(i2.errors)).concat(function(t3) {
            var e3 = [], n3 = s.filter(t3, function(t4) {
              return s.isRegExp(t4[E]);
            });
            return e3 = (e3 = (e3 = (e3 = (e3 = e3.concat(S(n3))).concat(U(n3))).concat(R(n3))).concat(d(n3))).concat(h(n3));
          }(o2))).concat(O(o2))).concat(N(o2, e2))).concat(A(o2));
        }, e.findMissingPatterns = p, e.findInvalidPatterns = f;
        var L = /[^\\][\$]/;
        function S(t2) {
          var e2 = function(t3) {
            function e3() {
              var e4 = null !== t3 && t3.apply(this, arguments) || this;
              return e4.found = false, e4;
            }
            return i(e3, t3), e3.prototype.visitEndAnchor = function(t4) {
              this.found = true;
            }, e3;
          }(o.BaseRegExpVisitor), n2 = s.filter(t2, function(t3) {
            var n3 = t3[E];
            try {
              var r2 = l.pattern(n3.toString()), i2 = new e2();
              return i2.visit(r2), i2.found;
            } catch (t4) {
              return L.test(n3.source);
            }
          });
          return s.map(n2, function(t3) {
            return { message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + a.tokenName(t3) + "<- static 'PATTERN' cannot contain end of input anchor '$'\n	See sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.", type: u.LexerDefinitionErrorType.EOI_ANCHOR_FOUND, tokenTypes: [t3] };
          });
        }
        function h(t2) {
          var e2 = s.filter(t2, function(t3) {
            return t3[E].test("");
          });
          return s.map(e2, function(t3) {
            return { message: "Token Type: ->" + a.tokenName(t3) + "<- static 'PATTERN' must not match an empty string", type: u.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN, tokenTypes: [t3] };
          });
        }
        e.findEndOfInputAnchor = S, e.findEmptyMatchRegExps = h;
        var T = /[^\\[][\^]|^\^/;
        function U(t2) {
          var e2 = function(t3) {
            function e3() {
              var e4 = null !== t3 && t3.apply(this, arguments) || this;
              return e4.found = false, e4;
            }
            return i(e3, t3), e3.prototype.visitStartAnchor = function(t4) {
              this.found = true;
            }, e3;
          }(o.BaseRegExpVisitor), n2 = s.filter(t2, function(t3) {
            var n3 = t3[E];
            try {
              var r2 = l.pattern(n3.toString()), i2 = new e2();
              return i2.visit(r2), i2.found;
            } catch (t4) {
              return T.test(n3.source);
            }
          });
          return s.map(n2, function(t3) {
            return { message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + a.tokenName(t3) + "<- static 'PATTERN' cannot contain start of input anchor '^'\n	See https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.", type: u.LexerDefinitionErrorType.SOI_ANCHOR_FOUND, tokenTypes: [t3] };
          });
        }
        function R(t2) {
          var e2 = s.filter(t2, function(t3) {
            var e3 = t3[E];
            return e3 instanceof RegExp && (e3.multiline || e3.global);
          });
          return s.map(e2, function(t3) {
            return { message: "Token Type: ->" + a.tokenName(t3) + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')", type: u.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND, tokenTypes: [t3] };
          });
        }
        function d(t2) {
          var e2 = [], n2 = s.map(t2, function(n3) {
            return s.reduce(t2, function(t3, r3) {
              return n3.PATTERN.source !== r3.PATTERN.source || s.contains(e2, r3) || r3.PATTERN === u.Lexer.NA ? t3 : (e2.push(r3), t3.push(r3), t3);
            }, []);
          });
          n2 = s.compact(n2);
          var r2 = s.filter(n2, function(t3) {
            return t3.length > 1;
          });
          return s.map(r2, function(t3) {
            var e3 = s.map(t3, function(t4) {
              return a.tokenName(t4);
            });
            return { message: "The same RegExp pattern ->" + s.first(t3).PATTERN + "<-has been used in all of the following Token Types: " + e3.join(", ") + " <-", type: u.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND, tokenTypes: t3 };
          });
        }
        function O(t2) {
          var e2 = s.filter(t2, function(t3) {
            if (!s.has(t3, "GROUP"))
              return false;
            var e3 = t3.GROUP;
            return e3 !== u.Lexer.SKIPPED && e3 !== u.Lexer.NA && !s.isString(e3);
          });
          return s.map(e2, function(t3) {
            return { message: "Token Type: ->" + a.tokenName(t3) + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String", type: u.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND, tokenTypes: [t3] };
          });
        }
        function N(t2, e2) {
          var n2 = s.filter(t2, function(t3) {
            return void 0 !== t3.PUSH_MODE && !s.contains(e2, t3.PUSH_MODE);
          });
          return s.map(n2, function(t3) {
            return { message: "Token Type: ->" + a.tokenName(t3) + "<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->" + t3.PUSH_MODE + "<-which does not exist", type: u.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST, tokenTypes: [t3] };
          });
        }
        function A(t2) {
          var e2 = [], n2 = s.reduce(t2, function(t3, e3, n3) {
            var r2, i2 = e3.PATTERN;
            return i2 === u.Lexer.NA ? t3 : (s.isString(i2) ? t3.push({ str: i2, idx: n3, tokenType: e3 }) : s.isRegExp(i2) && (r2 = i2, void 0 === s.find([".", "\\", "[", "]", "|", "^", "$", "(", ")", "?", "*", "+", "{"], function(t4) {
              return -1 !== r2.source.indexOf(t4);
            })) && t3.push({ str: i2.source, idx: n3, tokenType: e3 }), t3);
          }, []);
          return s.forEach(t2, function(t3, r2) {
            s.forEach(n2, function(n3) {
              var i2 = n3.str, o2 = n3.idx, c2 = n3.tokenType;
              if (r2 < o2 && function(t4, e3) {
                if (s.isRegExp(e3)) {
                  var n4 = e3.exec(t4);
                  return null !== n4 && 0 === n4.index;
                }
                if (s.isFunction(e3))
                  return e3(t4, 0, [], {});
                if (s.has(e3, "exec"))
                  return e3.exec(t4, 0, [], {});
                if ("string" == typeof e3)
                  return e3 === t4;
                throw Error("non exhaustive match");
              }(i2, t3.PATTERN)) {
                var l2 = "Token: ->" + a.tokenName(c2) + "<- can never be matched.\nBecause it appears AFTER the Token Type ->" + a.tokenName(t3) + "<-in the lexer's definition.\nSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNREACHABLE";
                e2.push({ message: l2, type: u.LexerDefinitionErrorType.UNREACHABLE_PATTERN, tokenTypes: [t3, c2] });
              }
            });
          }), e2;
        }
        function m(t2) {
          var e2 = t2.ignoreCase ? "i" : "";
          return new RegExp("^(?:" + t2.source + ")", e2);
        }
        function C(t2) {
          var e2 = t2.ignoreCase ? "iy" : "y";
          return new RegExp("" + t2.source, e2);
        }
        function I(t2) {
          var e2 = t2.PATTERN;
          if (s.isRegExp(e2))
            return false;
          if (s.isFunction(e2))
            return true;
          if (s.has(e2, "exec"))
            return true;
          if (s.isString(e2))
            return false;
          throw Error("non exhaustive match");
        }
        function y(t2) {
          return !(!s.isString(t2) || 1 !== t2.length) && t2.charCodeAt(0);
        }
        function _(t2, e2) {
          if (s.has(t2, "LINE_BREAKS"))
            return false;
          if (s.isRegExp(t2.PATTERN)) {
            try {
              c.canMatchCharCode(e2, t2.PATTERN);
            } catch (t3) {
              return { issue: u.LexerDefinitionErrorType.IDENTIFY_TERMINATOR, errMsg: t3.message };
            }
            return false;
          }
          if (s.isString(t2.PATTERN))
            return false;
          if (I(t2))
            return { issue: u.LexerDefinitionErrorType.CUSTOM_LINE_BREAK };
          throw Error("non exhaustive match");
        }
        function P(t2, e2) {
          if (e2.issue === u.LexerDefinitionErrorType.IDENTIFY_TERMINATOR)
            return "Warning: unable to identify line terminator usage in pattern.\n	The problem is in the <" + t2.name + "> Token Type\n	 Root cause: " + e2.errMsg + ".\n	For details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR";
          if (e2.issue === u.LexerDefinitionErrorType.CUSTOM_LINE_BREAK)
            return "Warning: A Custom Token Pattern should specify the <line_breaks> option.\n	The problem is in the <" + t2.name + "> Token Type\n	For details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK";
          throw Error("non exhaustive match");
        }
        function v(t2) {
          return s.map(t2, function(t3) {
            return s.isString(t3) && t3.length > 0 ? t3.charCodeAt(0) : t3;
          });
        }
        e.findStartOfInputAnchor = U, e.findUnsupportedFlags = R, e.findDuplicatePatterns = d, e.findInvalidGroupType = O, e.findModesThatDoNotExist = N, e.findUnreachablePatterns = A, e.addStartOfInput = m, e.addStickyFlag = C, e.performRuntimeChecks = function(t2, n2, r2) {
          var i2 = [];
          return s.has(t2, e.DEFAULT_MODE) || i2.push({ message: "A MultiMode Lexer cannot be initialized without a <" + e.DEFAULT_MODE + "> property in its definition\n", type: u.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE }), s.has(t2, e.MODES) || i2.push({ message: "A MultiMode Lexer cannot be initialized without a <" + e.MODES + "> property in its definition\n", type: u.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY }), s.has(t2, e.MODES) && s.has(t2, e.DEFAULT_MODE) && !s.has(t2.modes, t2.defaultMode) && i2.push({ message: "A MultiMode Lexer cannot be initialized with a " + e.DEFAULT_MODE + ": <" + t2.defaultMode + ">which does not exist\n", type: u.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST }), s.has(t2, e.MODES) && s.forEach(t2.modes, function(t3, e2) {
            s.forEach(t3, function(t4, n3) {
              s.isUndefined(t4) && i2.push({ message: "A Lexer cannot be initialized using an undefined Token Type. Mode:<" + e2 + "> at index: <" + n3 + ">\n", type: u.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED });
            });
          }), i2;
        }, e.performWarningRuntimeChecks = function(t2, e2, n2) {
          var r2 = [], i2 = false, o2 = s.compact(s.flatten(s.mapValues(t2.modes, function(t3) {
            return t3;
          }))), a2 = s.reject(o2, function(t3) {
            return t3[E] === u.Lexer.NA;
          }), l2 = v(n2);
          return e2 && s.forEach(a2, function(t3) {
            var e3 = _(t3, l2);
            if (false !== e3) {
              var n3 = { message: P(t3, e3), type: e3.issue, tokenType: t3 };
              r2.push(n3);
            } else
              s.has(t3, "LINE_BREAKS") ? true === t3.LINE_BREAKS && (i2 = true) : c.canMatchCharCode(l2, t3.PATTERN) && (i2 = true);
          }), e2 && !i2 && r2.push({ message: "Warning: No LINE_BREAKS Found.\n	This Lexer has been defined to track line and column information,\n	But none of the Token Types can be identified as matching a line terminator.\n	See https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n	for details.", type: u.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS }), r2;
        }, e.cloneEmptyGroups = function(t2) {
          var e2 = {}, n2 = s.keys(t2);
          return s.forEach(n2, function(n3) {
            var r2 = t2[n3];
            if (!s.isArray(r2))
              throw Error("non exhaustive match");
            e2[n3] = [];
          }), e2;
        }, e.isCustomPattern = I, e.isShortPattern = y, e.LineTerminatorOptimizedTester = { test: function(t2) {
          for (var e2 = t2.length, n2 = this.lastIndex; n2 < e2; n2++) {
            var r2 = t2.charCodeAt(n2);
            if (10 === r2)
              return this.lastIndex = n2 + 1, true;
            if (13 === r2)
              return 10 === t2.charCodeAt(n2 + 1) ? this.lastIndex = n2 + 2 : this.lastIndex = n2 + 1, true;
          }
          return false;
        }, lastIndex: 0 }, e.buildLineBreakIssueMessage = P;
      }, function(t, e, n) {
        "use strict";
        var r, i = this && this.__extends || (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        });
        Object.defineProperty(e, "__esModule", { value: true });
        var o = n(28), a = n(4), u = new o.RegExpParser(), s = "Complement Sets are not supported for first char optimization";
        function c(t2) {
          switch (t2.type) {
            case "Disjunction":
              return a.flatten(a.map(t2.value, c));
            case "Alternative":
              for (var e2 = [], n2 = t2.value, r2 = 0; r2 < n2.length; r2++) {
                var i2 = n2[r2];
                if (!a.contains(["GroupBackReference", "Lookahead", "NegativeLookahead", "StartAnchor", "EndAnchor", "WordBoundary", "NonWordBoundary"], i2.type)) {
                  var o2 = i2;
                  switch (o2.type) {
                    case "Character":
                      e2.push(o2.value);
                      break;
                    case "Set":
                      if (true === o2.complement)
                        throw Error(s);
                      a.forEach(o2.value, function(t3) {
                        if ("number" == typeof t3)
                          e2.push(t3);
                        else
                          for (var n3 = t3, r3 = n3.from; r3 <= n3.to; r3++)
                            e2.push(r3);
                      });
                      break;
                    case "Group":
                      var u2 = c(o2.value);
                      a.forEach(u2, function(t3) {
                        return e2.push(t3);
                      });
                      break;
                    default:
                      throw Error("Non Exhaustive Match");
                  }
                  var l2 = void 0 !== o2.quantifier && 0 === o2.quantifier.atLeast;
                  if ("Group" === o2.type && false === p(o2) || "Group" !== o2.type && false === l2)
                    break;
                }
              }
              return e2;
            default:
              throw Error("non exhaustive match!");
          }
        }
        function l(t2) {
          var e2 = [];
          return a.forEach(t2, function(t3) {
            e2.push(t3);
            var n2 = String.fromCharCode(t3);
            n2.toUpperCase() !== n2 ? e2.push(n2.toUpperCase().charCodeAt(0)) : n2.toLowerCase() !== n2 && e2.push(n2.toLowerCase().charCodeAt(0));
          }), e2;
        }
        function E(t2, e2) {
          return a.find(t2.value, function(t3) {
            if ("number" == typeof t3)
              return a.contains(e2, t3);
            var n2 = t3;
            return void 0 !== a.find(e2, function(t4) {
              return n2.from <= t4 && t4 <= n2.to;
            });
          });
        }
        function p(t2) {
          return !(!t2.quantifier || 0 !== t2.quantifier.atLeast) || !!t2.value && (a.isArray(t2.value) ? a.every(t2.value, p) : p(t2.value));
        }
        e.failedOptimizationPrefixMsg = 'Unable to use "first char" lexer optimizations:\n', e.getStartCodes = function(t2, n2) {
          void 0 === n2 && (n2 = false);
          try {
            var r2 = u.pattern(t2.toString()), i2 = c(r2.value);
            return r2.flags.ignoreCase && (i2 = l(i2)), i2;
          } catch (r3) {
            if (r3.message === s)
              n2 && a.PRINT_WARNING(e.failedOptimizationPrefixMsg + "	Unable to optimize: < " + t2.toString() + " >\n	Complement Sets cannot be automatically optimized.\n	This will disable the lexer's first char optimizations.\n	See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.");
            else {
              var E2 = "";
              n2 && (E2 = "\n	This will disable the lexer's first char optimizations.\n	See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details."), a.PRINT_ERROR(e.failedOptimizationPrefixMsg + "\n	Failed parsing: < " + t2.toString() + " >\n	Using the regexp-to-ast library version: " + o.VERSION + "\n	Please open an issue at: https://github.com/bd82/regexp-to-ast/issues" + E2);
            }
          }
          return [];
        }, e.firstChar = c, e.applyIgnoreCase = l;
        var f = function(t2) {
          function e2(e3) {
            var n2 = t2.call(this) || this;
            return n2.targetCharCodes = e3, n2.found = false, n2;
          }
          return i(e2, t2), e2.prototype.visitChildren = function(e3) {
            switch (e3.type) {
              case "Lookahead":
                return void this.visitLookahead(e3);
              case "NegativeLookahead":
                return void this.visitNegativeLookahead(e3);
            }
            t2.prototype.visitChildren.call(this, e3);
          }, e2.prototype.visitCharacter = function(t3) {
            a.contains(this.targetCharCodes, t3.value) && (this.found = true);
          }, e2.prototype.visitSet = function(t3) {
            t3.complement ? void 0 === E(t3, this.targetCharCodes) && (this.found = true) : void 0 !== E(t3, this.targetCharCodes) && (this.found = true);
          }, e2;
        }(o.BaseRegExpVisitor);
        e.canMatchCharCode = function(t2, e2) {
          if (e2 instanceof RegExp) {
            var n2 = u.pattern(e2.toString()), r2 = new f(t2);
            return r2.visit(n2), r2.found;
          }
          return void 0 !== a.find(e2, function(e3) {
            return a.contains(t2, e3.charCodeAt(0));
          });
        };
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = function() {
          function t2(t3, e2) {
            if (this.start = t3, this.end = e2, !i(t3, e2))
              throw new Error("INVALID RANGE");
          }
          return t2.prototype.contains = function(t3) {
            return this.start <= t3 && this.end >= t3;
          }, t2.prototype.containsRange = function(t3) {
            return this.start <= t3.start && this.end >= t3.end;
          }, t2.prototype.isContainedInRange = function(t3) {
            return t3.containsRange(this);
          }, t2.prototype.strictlyContainsRange = function(t3) {
            return this.start < t3.start && this.end > t3.end;
          }, t2.prototype.isStrictlyContainedInRange = function(t3) {
            return t3.strictlyContainsRange(this);
          }, t2;
        }();
        function i(t2, e2) {
          return !(t2 < 0 || e2 < t2);
        }
        e.Range = r, e.isValidRange = i;
      }, function(t, e, n) {
        "use strict";
        var r, i = this && this.__extends || (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        });
        Object.defineProperty(e, "__esModule", { value: true });
        var o = n(8), a = n(4), u = n(11);
        e.resolveGrammar = function(t2, e2) {
          var n2 = new s(t2, e2);
          return n2.resolveRefs(), n2.errors;
        };
        var s = function(t2) {
          function e2(e3, n2) {
            var r2 = t2.call(this) || this;
            return r2.nameToTopRule = e3, r2.errMsgProvider = n2, r2.errors = [], r2;
          }
          return i(e2, t2), e2.prototype.resolveRefs = function() {
            var t3 = this;
            a.forEach(this.nameToTopRule.values(), function(e3) {
              t3.currTopLevel = e3, e3.accept(t3);
            });
          }, e2.prototype.visitNonTerminal = function(t3) {
            var e3 = this.nameToTopRule.get(t3.nonTerminalName);
            if (e3)
              t3.referencedRule = e3;
            else {
              var n2 = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, t3);
              this.errors.push({ message: n2, type: o.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF, ruleName: this.currTopLevel.name, unresolvedRefName: t3.nonTerminalName });
            }
          }, e2;
        }(u.GAstVisitor);
        e.GastRefResolverVisitor = s;
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(19), i = n(4), o = n(8), a = n(16), u = function() {
          function t2() {
          }
          return t2.prototype.initLooksAhead = function(t3) {
            this.dynamicTokensEnabled = i.has(t3, "dynamicTokensEnabled") ? t3.dynamicTokensEnabled : o.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled, this.maxLookahead = i.has(t3, "maxLookahead") ? t3.maxLookahead : o.DEFAULT_PARSER_CONFIG.maxLookahead, this.lookAheadFuncsCache = i.isES2015MapSupported() ? /* @__PURE__ */ new Map() : [], i.isES2015MapSupported() ? (this.getLaFuncFromCache = this.getLaFuncFromMap, this.setLaFuncCache = this.setLaFuncCacheUsingMap) : (this.getLaFuncFromCache = this.getLaFuncFromObj, this.setLaFuncCache = this.setLaFuncUsingObj);
          }, t2.prototype.lookAheadBuilderForOptional = function(t3, e2, n2) {
            return r.buildSingleAlternativeLookaheadFunction(t3, e2, n2);
          }, t2.prototype.lookAheadBuilderForAlternatives = function(t3, e2, n2, i2) {
            return r.buildAlternativesLookAheadFunc(t3, e2, n2, i2);
          }, t2.prototype.getKeyForAutomaticLookahead = function(t3, e2) {
            var n2 = this.getLastExplicitRuleShortName();
            return a.getKeyForAutomaticLookahead(n2, t3, e2);
          }, t2.prototype.getLookaheadFuncForOr = function(t3, e2) {
            var n2 = this.getKeyForAutomaticLookahead(a.OR_IDX, t3), o2 = this.getLaFuncFromCache(n2);
            if (void 0 === o2) {
              var u2 = this.getCurrRuleFullName(), s = this.getGAstProductions().get(u2), c = i.some(e2, function(t4) {
                return i.isFunction(t4.GATE);
              });
              return o2 = r.buildLookaheadFuncForOr(t3, s, this.maxLookahead, c, this.dynamicTokensEnabled, this.lookAheadBuilderForAlternatives), this.setLaFuncCache(n2, o2), o2;
            }
            return o2;
          }, t2.prototype.getLookaheadFuncForOption = function(t3, e2) {
            return this.getLookaheadFuncFor(t3, e2, this.maxLookahead, r.PROD_TYPE.OPTION);
          }, t2.prototype.getLookaheadFuncForMany = function(t3, e2) {
            return this.getLookaheadFuncFor(t3, e2, this.maxLookahead, r.PROD_TYPE.REPETITION);
          }, t2.prototype.getLookaheadFuncForManySep = function(t3, e2) {
            return this.getLookaheadFuncFor(t3, e2, this.maxLookahead, r.PROD_TYPE.REPETITION_WITH_SEPARATOR);
          }, t2.prototype.getLookaheadFuncForAtLeastOne = function(t3, e2) {
            return this.getLookaheadFuncFor(t3, e2, this.maxLookahead, r.PROD_TYPE.REPETITION_MANDATORY);
          }, t2.prototype.getLookaheadFuncForAtLeastOneSep = function(t3, e2) {
            return this.getLookaheadFuncFor(t3, e2, this.maxLookahead, r.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);
          }, t2.prototype.getLookaheadFuncFor = function(t3, e2, n2, i2) {
            var o2 = this.getLaFuncFromCache(t3);
            if (void 0 === o2) {
              var a2 = this.getCurrRuleFullName(), u2 = this.getGAstProductions().get(a2);
              return o2 = r.buildLookaheadFuncForOptionalProd(e2, u2, n2, this.dynamicTokensEnabled, i2, this.lookAheadBuilderForOptional), this.setLaFuncCache(t3, o2), o2;
            }
            return o2;
          }, t2.prototype.getLaFuncFromCache = function(t3) {
          }, t2.prototype.getLaFuncFromMap = function(t3) {
            return this.lookAheadFuncsCache.get(t3);
          }, t2.prototype.getLaFuncFromObj = function(t3) {
            return this.lookAheadFuncsCache[t3];
          }, t2.prototype.setLaFuncCache = function(t3, e2) {
          }, t2.prototype.setLaFuncCacheUsingMap = function(t3, e2) {
            this.lookAheadFuncsCache.set(t3, e2);
          }, t2.prototype.setLaFuncUsingObj = function(t3, e2) {
            this.lookAheadFuncsCache[t3] = e2;
          }, t2;
        }();
        e.LooksAhead = u;
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(24), i = n(4), o = n(44), a = n(16), u = n(8), s = function() {
          function t2() {
          }
          return t2.prototype.initTreeBuilder = function(t3) {
            if (this.LAST_EXPLICIT_RULE_STACK = [], this.CST_STACK = [], this.outputCst = i.has(t3, "outputCst") ? t3.outputCst : u.DEFAULT_PARSER_CONFIG.outputCst, this.nodeLocationTracking = i.has(t3, "nodeLocationTracking") ? t3.nodeLocationTracking : u.DEFAULT_PARSER_CONFIG.nodeLocationTracking, this.outputCst)
              if (/full/i.test(this.nodeLocationTracking))
                this.recoveryEnabled ? (this.setNodeLocationFromToken = r.setNodeLocationFull, this.setNodeLocationFromNode = r.setNodeLocationFull, this.cstPostRule = i.NOOP, this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery) : (this.setNodeLocationFromToken = i.NOOP, this.setNodeLocationFromNode = i.NOOP, this.cstPostRule = this.cstPostRuleFull, this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular);
              else if (/onlyOffset/i.test(this.nodeLocationTracking))
                this.recoveryEnabled ? (this.setNodeLocationFromToken = r.setNodeLocationOnlyOffset, this.setNodeLocationFromNode = r.setNodeLocationOnlyOffset, this.cstPostRule = i.NOOP, this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery) : (this.setNodeLocationFromToken = i.NOOP, this.setNodeLocationFromNode = i.NOOP, this.cstPostRule = this.cstPostRuleOnlyOffset, this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular);
              else {
                if (!/none/i.test(this.nodeLocationTracking))
                  throw Error('Invalid <nodeLocationTracking> config option: "' + t3.nodeLocationTracking + '"');
                this.setNodeLocationFromToken = i.NOOP, this.setNodeLocationFromNode = i.NOOP, this.cstPostRule = i.NOOP, this.setInitialNodeLocation = i.NOOP;
              }
            else
              this.cstInvocationStateUpdate = i.NOOP, this.cstFinallyStateUpdate = i.NOOP, this.cstPostTerminal = i.NOOP, this.cstPostNonTerminal = i.NOOP, this.cstPostRule = i.NOOP, this.getLastExplicitRuleShortName = this.getLastExplicitRuleShortNameNoCst, this.getPreviousExplicitRuleShortName = this.getPreviousExplicitRuleShortNameNoCst, this.getLastExplicitRuleOccurrenceIndex = this.getLastExplicitRuleOccurrenceIndexNoCst, this.manyInternal = this.manyInternalNoCst, this.orInternal = this.orInternalNoCst, this.optionInternal = this.optionInternalNoCst, this.atLeastOneInternal = this.atLeastOneInternalNoCst, this.manySepFirstInternal = this.manySepFirstInternalNoCst, this.atLeastOneSepFirstInternal = this.atLeastOneSepFirstInternalNoCst;
          }, t2.prototype.setInitialNodeLocationOnlyOffsetRecovery = function(t3) {
            t3.location = { startOffset: NaN, endOffset: NaN };
          }, t2.prototype.setInitialNodeLocationOnlyOffsetRegular = function(t3) {
            t3.location = { startOffset: this.LA(1).startOffset, endOffset: NaN };
          }, t2.prototype.setInitialNodeLocationFullRecovery = function(t3) {
            t3.location = { startOffset: NaN, startLine: NaN, startColumn: NaN, endOffset: NaN, endLine: NaN, endColumn: NaN };
          }, t2.prototype.setInitialNodeLocationFullRegular = function(t3) {
            var e2 = this.LA(1);
            t3.location = { startOffset: e2.startOffset, startLine: e2.startLine, startColumn: e2.startColumn, endOffset: NaN, endLine: NaN, endColumn: NaN };
          }, t2.prototype.cstNestedInvocationStateUpdate = function(t3, e2) {
            var n2 = { name: t3, fullName: this.shortRuleNameToFull.get(this.getLastExplicitRuleShortName()) + t3, children: {} };
            this.setInitialNodeLocation(n2), this.CST_STACK.push(n2);
          }, t2.prototype.cstInvocationStateUpdate = function(t3, e2) {
            this.LAST_EXPLICIT_RULE_STACK.push(this.RULE_STACK.length - 1);
            var n2 = { name: t3, children: {} };
            this.setInitialNodeLocation(n2), this.CST_STACK.push(n2);
          }, t2.prototype.cstFinallyStateUpdate = function() {
            this.LAST_EXPLICIT_RULE_STACK.pop(), this.CST_STACK.pop();
          }, t2.prototype.cstNestedFinallyStateUpdate = function() {
            var t3 = this.CST_STACK.pop();
            this.cstPostRule(t3);
          }, t2.prototype.cstPostRuleFull = function(t3) {
            var e2 = this.LA(0), n2 = t3.location;
            n2.startOffset <= e2.startOffset == true ? (n2.endOffset = e2.endOffset, n2.endLine = e2.endLine, n2.endColumn = e2.endColumn) : (n2.startOffset = NaN, n2.startLine = NaN, n2.startColumn = NaN);
          }, t2.prototype.cstPostRuleOnlyOffset = function(t3) {
            var e2 = this.LA(0), n2 = t3.location;
            n2.startOffset <= e2.startOffset == true ? n2.endOffset = e2.endOffset : n2.startOffset = NaN;
          }, t2.prototype.cstPostTerminal = function(t3, e2) {
            var n2 = this.CST_STACK[this.CST_STACK.length - 1];
            r.addTerminalToCst(n2, e2, t3), this.setNodeLocationFromToken(n2.location, e2);
          }, t2.prototype.cstPostNonTerminal = function(t3, e2) {
            var n2 = this.CST_STACK[this.CST_STACK.length - 1];
            r.addNoneTerminalToCst(n2, e2, t3), this.setNodeLocationFromNode(n2.location, t3.location);
          }, t2.prototype.getBaseCstVisitorConstructor = function() {
            if (i.isUndefined(this.baseCstVisitorConstructor)) {
              var t3 = o.createBaseSemanticVisitorConstructor(this.className, this.allRuleNames);
              return this.baseCstVisitorConstructor = t3, t3;
            }
            return this.baseCstVisitorConstructor;
          }, t2.prototype.getBaseCstVisitorConstructorWithDefaults = function() {
            if (i.isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {
              var t3 = o.createBaseVisitorConstructorWithDefaults(this.className, this.allRuleNames, this.getBaseCstVisitorConstructor());
              return this.baseCstVisitorWithDefaultsConstructor = t3, t3;
            }
            return this.baseCstVisitorWithDefaultsConstructor;
          }, t2.prototype.nestedRuleBeforeClause = function(t3, e2) {
            var n2;
            return void 0 !== t3.NAME ? (n2 = t3.NAME, this.nestedRuleInvocationStateUpdate(n2, e2), n2) : void 0;
          }, t2.prototype.nestedAltBeforeClause = function(t3, e2, n2, r2) {
            var i2, o2 = this.getLastExplicitRuleShortName(), u2 = a.getKeyForAltIndex(o2, n2, e2, r2);
            return void 0 !== t3.NAME ? (i2 = t3.NAME, this.nestedRuleInvocationStateUpdate(i2, u2), { shortName: u2, nestedName: i2 }) : void 0;
          }, t2.prototype.nestedRuleFinallyClause = function(t3, e2) {
            var n2 = this.CST_STACK, i2 = n2[n2.length - 1];
            this.nestedRuleFinallyStateUpdate();
            var o2 = n2[n2.length - 1];
            r.addNoneTerminalToCst(o2, e2, i2), this.setNodeLocationFromNode(o2.location, i2.location);
          }, t2.prototype.getLastExplicitRuleShortName = function() {
            var t3 = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1];
            return this.RULE_STACK[t3];
          }, t2.prototype.getLastExplicitRuleShortNameNoCst = function() {
            var t3 = this.RULE_STACK;
            return t3[t3.length - 1];
          }, t2.prototype.getPreviousExplicitRuleShortName = function() {
            var t3 = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 2];
            return this.RULE_STACK[t3];
          }, t2.prototype.getPreviousExplicitRuleShortNameNoCst = function() {
            var t3 = this.RULE_STACK;
            return t3[t3.length - 2];
          }, t2.prototype.getLastExplicitRuleOccurrenceIndex = function() {
            var t3 = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1];
            return this.RULE_OCCURRENCE_STACK[t3];
          }, t2.prototype.getLastExplicitRuleOccurrenceIndexNoCst = function() {
            var t3 = this.RULE_OCCURRENCE_STACK;
            return t3[t3.length - 1];
          }, t2.prototype.nestedRuleInvocationStateUpdate = function(t3, e2) {
            this.RULE_OCCURRENCE_STACK.push(1), this.RULE_STACK.push(e2), this.cstNestedInvocationStateUpdate(t3, e2);
          }, t2.prototype.nestedRuleFinallyStateUpdate = function() {
            this.RULE_STACK.pop(), this.RULE_OCCURRENCE_STACK.pop(), this.cstNestedFinallyStateUpdate();
          }, t2;
        }();
        e.TreeBuilder = s;
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r, i = n(4), o = n(10), a = n(18);
        function u(t2, e2) {
          for (var n2 = i.keys(t2), r2 = n2.length, o2 = 0; o2 < r2; o2++)
            for (var a2 = t2[n2[o2]], u2 = a2.length, s2 = 0; s2 < u2; s2++) {
              var c2 = a2[s2];
              void 0 === c2.tokenTypeIdx && (void 0 !== c2.fullName ? this[c2.fullName](c2.children, e2) : this[c2.name](c2.children, e2));
            }
        }
        function s(t2, e2) {
          var n2 = c(t2, e2), r2 = E(t2, e2);
          return n2.concat(r2);
        }
        function c(t2, e2) {
          var n2 = i.map(e2, function(e3) {
            if (!i.isFunction(t2[e3]))
              return { msg: "Missing visitor method: <" + e3 + "> on " + o.functionName(t2.constructor) + " CST Visitor.", type: r.MISSING_METHOD, methodName: e3 };
          });
          return i.compact(n2);
        }
        e.defaultVisit = u, e.createBaseSemanticVisitorConstructor = function(t2, e2) {
          var n2 = function() {
          };
          return o.defineNameProp(n2, t2 + "BaseSemantics"), (n2.prototype = { visit: function(t3, e3) {
            if (i.isArray(t3) && (t3 = t3[0]), !i.isUndefined(t3))
              return void 0 !== t3.fullName ? this[t3.fullName](t3.children, e3) : this[t3.name](t3.children, e3);
          }, validateVisitor: function() {
            var t3 = s(this, e2);
            if (!i.isEmpty(t3)) {
              var n3 = i.map(t3, function(t4) {
                return t4.msg;
              });
              throw Error("Errors Detected in CST Visitor <" + o.functionName(this.constructor) + ">:\n	" + n3.join("\n\n").replace(/\n/g, "\n	"));
            }
          } }).constructor = n2, n2._RULE_NAMES = e2, n2;
        }, e.createBaseVisitorConstructorWithDefaults = function(t2, e2, n2) {
          var r2 = function() {
          };
          o.defineNameProp(r2, t2 + "BaseSemanticsWithDefaults");
          var a2 = Object.create(n2.prototype);
          return i.forEach(e2, function(t3) {
            a2[t3] = u;
          }), (r2.prototype = a2).constructor = r2, r2;
        }, function(t2) {
          t2[t2.REDUNDANT_METHOD = 0] = "REDUNDANT_METHOD", t2[t2.MISSING_METHOD = 1] = "MISSING_METHOD";
        }(r = e.CstVisitorDefinitionError || (e.CstVisitorDefinitionError = {})), e.validateVisitor = s, e.validateMissingCstMethods = c;
        var l = ["constructor", "visit", "validateVisitor"];
        function E(t2, e2) {
          var n2 = [];
          for (var u2 in t2)
            a.validTermsPattern.test(u2) && i.isFunction(t2[u2]) && !i.contains(l, u2) && !i.contains(e2, u2) && n2.push({ msg: "Redundant visitor method: <" + u2 + "> on " + o.functionName(t2.constructor) + " CST Visitor\nThere is no Grammar Rule corresponding to this method's name.\nFor utility methods on visitor classes use methods names that do not match /" + a.validTermsPattern.source + "/.", type: r.REDUNDANT_METHOD, methodName: u2 });
          return n2;
        }
        e.validateRedundantMethods = E;
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(8), i = function() {
          function t2() {
          }
          return t2.prototype.initLexerAdapter = function() {
            this.tokVector = [], this.tokVectorLength = 0, this.currIdx = -1;
          }, Object.defineProperty(t2.prototype, "input", { get: function() {
            return this.tokVector;
          }, set: function(t3) {
            this.reset(), this.tokVector = t3, this.tokVectorLength = t3.length;
          }, enumerable: true, configurable: true }), t2.prototype.SKIP_TOKEN = function() {
            return this.currIdx <= this.tokVector.length - 2 ? (this.consumeToken(), this.LA(1)) : r.END_OF_FILE;
          }, t2.prototype.LA = function(t3) {
            return this.currIdx + t3 < 0 || this.tokVectorLength <= this.currIdx + t3 ? r.END_OF_FILE : this.tokVector[this.currIdx + t3];
          }, t2.prototype.consumeToken = function() {
            this.currIdx++;
          }, t2.prototype.exportLexerState = function() {
            return this.currIdx;
          }, t2.prototype.importLexerState = function(t3) {
            this.currIdx = t3;
          }, t2.prototype.resetLexerState = function() {
            this.currIdx = -1;
          }, t2.prototype.moveToTerminatedState = function() {
            this.currIdx = this.tokVector.length - 1;
          }, t2.prototype.getLexerPosition = function() {
            return this.exportLexerState();
          }, t2;
        }();
        e.LexerAdapter = i;
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(4), i = n(13), o = n(8), a = n(17), u = n(32), s = n(18), c = n(6), l = function() {
          function t2() {
          }
          return t2.prototype.CONSUME = function(t3, e2) {
            return this.consumeInternal(t3, 0, e2);
          }, t2.prototype.CONSUME1 = function(t3, e2) {
            return this.consumeInternal(t3, 1, e2);
          }, t2.prototype.CONSUME2 = function(t3, e2) {
            return this.consumeInternal(t3, 2, e2);
          }, t2.prototype.CONSUME3 = function(t3, e2) {
            return this.consumeInternal(t3, 3, e2);
          }, t2.prototype.CONSUME4 = function(t3, e2) {
            return this.consumeInternal(t3, 4, e2);
          }, t2.prototype.CONSUME5 = function(t3, e2) {
            return this.consumeInternal(t3, 5, e2);
          }, t2.prototype.CONSUME6 = function(t3, e2) {
            return this.consumeInternal(t3, 6, e2);
          }, t2.prototype.CONSUME7 = function(t3, e2) {
            return this.consumeInternal(t3, 7, e2);
          }, t2.prototype.CONSUME8 = function(t3, e2) {
            return this.consumeInternal(t3, 8, e2);
          }, t2.prototype.CONSUME9 = function(t3, e2) {
            return this.consumeInternal(t3, 9, e2);
          }, t2.prototype.SUBRULE = function(t3, e2) {
            return this.subruleInternal(t3, 0, e2);
          }, t2.prototype.SUBRULE1 = function(t3, e2) {
            return this.subruleInternal(t3, 1, e2);
          }, t2.prototype.SUBRULE2 = function(t3, e2) {
            return this.subruleInternal(t3, 2, e2);
          }, t2.prototype.SUBRULE3 = function(t3, e2) {
            return this.subruleInternal(t3, 3, e2);
          }, t2.prototype.SUBRULE4 = function(t3, e2) {
            return this.subruleInternal(t3, 4, e2);
          }, t2.prototype.SUBRULE5 = function(t3, e2) {
            return this.subruleInternal(t3, 5, e2);
          }, t2.prototype.SUBRULE6 = function(t3, e2) {
            return this.subruleInternal(t3, 6, e2);
          }, t2.prototype.SUBRULE7 = function(t3, e2) {
            return this.subruleInternal(t3, 7, e2);
          }, t2.prototype.SUBRULE8 = function(t3, e2) {
            return this.subruleInternal(t3, 8, e2);
          }, t2.prototype.SUBRULE9 = function(t3, e2) {
            return this.subruleInternal(t3, 9, e2);
          }, t2.prototype.OPTION = function(t3) {
            return this.optionInternal(t3, 0);
          }, t2.prototype.OPTION1 = function(t3) {
            return this.optionInternal(t3, 1);
          }, t2.prototype.OPTION2 = function(t3) {
            return this.optionInternal(t3, 2);
          }, t2.prototype.OPTION3 = function(t3) {
            return this.optionInternal(t3, 3);
          }, t2.prototype.OPTION4 = function(t3) {
            return this.optionInternal(t3, 4);
          }, t2.prototype.OPTION5 = function(t3) {
            return this.optionInternal(t3, 5);
          }, t2.prototype.OPTION6 = function(t3) {
            return this.optionInternal(t3, 6);
          }, t2.prototype.OPTION7 = function(t3) {
            return this.optionInternal(t3, 7);
          }, t2.prototype.OPTION8 = function(t3) {
            return this.optionInternal(t3, 8);
          }, t2.prototype.OPTION9 = function(t3) {
            return this.optionInternal(t3, 9);
          }, t2.prototype.OR = function(t3) {
            return this.orInternal(t3, 0);
          }, t2.prototype.OR1 = function(t3) {
            return this.orInternal(t3, 1);
          }, t2.prototype.OR2 = function(t3) {
            return this.orInternal(t3, 2);
          }, t2.prototype.OR3 = function(t3) {
            return this.orInternal(t3, 3);
          }, t2.prototype.OR4 = function(t3) {
            return this.orInternal(t3, 4);
          }, t2.prototype.OR5 = function(t3) {
            return this.orInternal(t3, 5);
          }, t2.prototype.OR6 = function(t3) {
            return this.orInternal(t3, 6);
          }, t2.prototype.OR7 = function(t3) {
            return this.orInternal(t3, 7);
          }, t2.prototype.OR8 = function(t3) {
            return this.orInternal(t3, 8);
          }, t2.prototype.OR9 = function(t3) {
            return this.orInternal(t3, 9);
          }, t2.prototype.MANY = function(t3) {
            this.manyInternal(0, t3);
          }, t2.prototype.MANY1 = function(t3) {
            this.manyInternal(1, t3);
          }, t2.prototype.MANY2 = function(t3) {
            this.manyInternal(2, t3);
          }, t2.prototype.MANY3 = function(t3) {
            this.manyInternal(3, t3);
          }, t2.prototype.MANY4 = function(t3) {
            this.manyInternal(4, t3);
          }, t2.prototype.MANY5 = function(t3) {
            this.manyInternal(5, t3);
          }, t2.prototype.MANY6 = function(t3) {
            this.manyInternal(6, t3);
          }, t2.prototype.MANY7 = function(t3) {
            this.manyInternal(7, t3);
          }, t2.prototype.MANY8 = function(t3) {
            this.manyInternal(8, t3);
          }, t2.prototype.MANY9 = function(t3) {
            this.manyInternal(9, t3);
          }, t2.prototype.MANY_SEP = function(t3) {
            this.manySepFirstInternal(0, t3);
          }, t2.prototype.MANY_SEP1 = function(t3) {
            this.manySepFirstInternal(1, t3);
          }, t2.prototype.MANY_SEP2 = function(t3) {
            this.manySepFirstInternal(2, t3);
          }, t2.prototype.MANY_SEP3 = function(t3) {
            this.manySepFirstInternal(3, t3);
          }, t2.prototype.MANY_SEP4 = function(t3) {
            this.manySepFirstInternal(4, t3);
          }, t2.prototype.MANY_SEP5 = function(t3) {
            this.manySepFirstInternal(5, t3);
          }, t2.prototype.MANY_SEP6 = function(t3) {
            this.manySepFirstInternal(6, t3);
          }, t2.prototype.MANY_SEP7 = function(t3) {
            this.manySepFirstInternal(7, t3);
          }, t2.prototype.MANY_SEP8 = function(t3) {
            this.manySepFirstInternal(8, t3);
          }, t2.prototype.MANY_SEP9 = function(t3) {
            this.manySepFirstInternal(9, t3);
          }, t2.prototype.AT_LEAST_ONE = function(t3) {
            this.atLeastOneInternal(0, t3);
          }, t2.prototype.AT_LEAST_ONE1 = function(t3) {
            return this.atLeastOneInternal(1, t3);
          }, t2.prototype.AT_LEAST_ONE2 = function(t3) {
            this.atLeastOneInternal(2, t3);
          }, t2.prototype.AT_LEAST_ONE3 = function(t3) {
            this.atLeastOneInternal(3, t3);
          }, t2.prototype.AT_LEAST_ONE4 = function(t3) {
            this.atLeastOneInternal(4, t3);
          }, t2.prototype.AT_LEAST_ONE5 = function(t3) {
            this.atLeastOneInternal(5, t3);
          }, t2.prototype.AT_LEAST_ONE6 = function(t3) {
            this.atLeastOneInternal(6, t3);
          }, t2.prototype.AT_LEAST_ONE7 = function(t3) {
            this.atLeastOneInternal(7, t3);
          }, t2.prototype.AT_LEAST_ONE8 = function(t3) {
            this.atLeastOneInternal(8, t3);
          }, t2.prototype.AT_LEAST_ONE9 = function(t3) {
            this.atLeastOneInternal(9, t3);
          }, t2.prototype.AT_LEAST_ONE_SEP = function(t3) {
            this.atLeastOneSepFirstInternal(0, t3);
          }, t2.prototype.AT_LEAST_ONE_SEP1 = function(t3) {
            this.atLeastOneSepFirstInternal(1, t3);
          }, t2.prototype.AT_LEAST_ONE_SEP2 = function(t3) {
            this.atLeastOneSepFirstInternal(2, t3);
          }, t2.prototype.AT_LEAST_ONE_SEP3 = function(t3) {
            this.atLeastOneSepFirstInternal(3, t3);
          }, t2.prototype.AT_LEAST_ONE_SEP4 = function(t3) {
            this.atLeastOneSepFirstInternal(4, t3);
          }, t2.prototype.AT_LEAST_ONE_SEP5 = function(t3) {
            this.atLeastOneSepFirstInternal(5, t3);
          }, t2.prototype.AT_LEAST_ONE_SEP6 = function(t3) {
            this.atLeastOneSepFirstInternal(6, t3);
          }, t2.prototype.AT_LEAST_ONE_SEP7 = function(t3) {
            this.atLeastOneSepFirstInternal(7, t3);
          }, t2.prototype.AT_LEAST_ONE_SEP8 = function(t3) {
            this.atLeastOneSepFirstInternal(8, t3);
          }, t2.prototype.AT_LEAST_ONE_SEP9 = function(t3) {
            this.atLeastOneSepFirstInternal(9, t3);
          }, t2.prototype.RULE = function(t3, e2, n2) {
            if (void 0 === n2 && (n2 = o.DEFAULT_RULE_CONFIG), r.contains(this.definedRulesNames, t3)) {
              var i2 = { message: a.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({ topLevelRule: t3, grammarName: this.className }), type: o.ParserDefinitionErrorType.DUPLICATE_RULE_NAME, ruleName: t3 };
              this.definitionErrors.push(i2);
            }
            if (this.definedRulesNames.push(t3), !this.gastProductionsCache.containsKey(t3) && !this.serializedGrammar) {
              var s2 = u.buildTopProduction(e2.toString(), t3, this.tokensMap);
              this.gastProductionsCache.put(t3, s2);
            }
            var c2 = this.defineRule(t3, e2, n2);
            return this[t3] = c2, c2;
          }, t2.prototype.OVERRIDE_RULE = function(t3, e2, n2) {
            void 0 === n2 && (n2 = o.DEFAULT_RULE_CONFIG);
            var r2 = [];
            if (r2 = r2.concat(s.validateRuleIsOverridden(t3, this.definedRulesNames, this.className)), this.definitionErrors.push.apply(this.definitionErrors, r2), !this.serializedGrammar) {
              var i2 = u.buildTopProduction(e2.toString(), t3, this.tokensMap);
              this.gastProductionsCache.put(t3, i2);
            }
            var a2 = this.defineRule(t3, e2, n2);
            return this[t3] = a2, a2;
          }, t2.prototype.BACKTRACK = function(t3, e2) {
            return function() {
              this.isBackTrackingStack.push(1);
              var n2 = this.saveRecogState();
              try {
                return t3.apply(this, e2), true;
              } catch (t4) {
                if (i.isRecognitionException(t4))
                  return false;
                throw t4;
              } finally {
                this.reloadRecogState(n2), this.isBackTrackingStack.pop();
              }
            };
          }, t2.prototype.getGAstProductions = function() {
            return this.gastProductionsCache;
          }, t2.prototype.getSerializedGastProductions = function() {
            return c.serializeGrammar(this.gastProductionsCache.values());
          }, t2;
        }();
        e.RecognizerApi = l;
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(4), i = n(16), o = n(13), a = n(19), u = n(20), s = n(8), c = n(34), l = n(7), E = n(14), p = n(10), f = function() {
          function t2() {
          }
          return t2.prototype.initRecognizerEngine = function(t3, e2) {
            if (this.className = p.classNameFromInstance(this), this.shortRuleNameToFull = new p.HashTable(), this.fullRuleNameToShort = new p.HashTable(), this.ruleShortNameIdx = 256, this.tokenMatcher = E.tokenStructuredMatcherNoCategories, this.definedRulesNames = [], this.tokensMap = {}, this.allRuleNames = [], this.isBackTrackingStack = [], this.RULE_STACK = [], this.RULE_OCCURRENCE_STACK = [], this.gastProductionsCache = new p.HashTable(), this.serializedGrammar = r.has(e2, "serializedGrammar") ? e2.serializedGrammar : s.DEFAULT_PARSER_CONFIG.serializedGrammar, r.isArray(t3)) {
              if (r.isEmpty(t3))
                throw Error("A Token Vocabulary cannot be empty.\n	Note that the first argument for the parser constructor\n	is no longer a Token vector (since v4.0).");
              if ("number" == typeof t3[0].startOffset)
                throw Error("The Parser constructor no longer accepts a token vector as the first argument.\n	See: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_4-0-0\n	For Further details.");
            }
            if (r.isArray(t3))
              this.tokensMap = r.reduce(t3, function(t4, e3) {
                return t4[l.tokenName(e3)] = e3, t4;
              }, {});
            else if (r.has(t3, "modes") && r.every(r.flatten(r.values(t3.modes)), E.isTokenType)) {
              var n2 = r.flatten(r.values(t3.modes)), i2 = r.uniq(n2);
              this.tokensMap = r.reduce(i2, function(t4, e3) {
                return t4[l.tokenName(e3)] = e3, t4;
              }, {});
            } else {
              if (!r.isObject(t3))
                throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
              this.tokensMap = r.cloneObj(t3);
            }
            this.tokensMap.EOF = l.EOF;
            var o2 = r.every(r.values(t3), function(t4) {
              return r.isEmpty(t4.categoryMatches);
            });
            this.tokenMatcher = o2 ? E.tokenStructuredMatcherNoCategories : E.tokenStructuredMatcher, E.augmentTokenTypes(r.values(this.tokensMap));
          }, t2.prototype.defineRule = function(t3, e2, n2) {
            if (this.selfAnalysisDone)
              throw Error("Grammar rule <" + t3 + "> may not be defined after the 'performSelfAnalysis' method has been called'\nMake sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.");
            var a2, u2 = r.has(n2, "resyncEnabled") ? n2.resyncEnabled : s.DEFAULT_RULE_CONFIG.resyncEnabled, c2 = r.has(n2, "recoveryValueFunc") ? n2.recoveryValueFunc : s.DEFAULT_RULE_CONFIG.recoveryValueFunc, l2 = this.ruleShortNameIdx << i.BITS_FOR_METHOD_IDX + i.BITS_FOR_OCCURRENCE_IDX;
            this.ruleShortNameIdx++, this.shortRuleNameToFull.put(l2, t3), this.fullRuleNameToShort.put(t3, l2);
            return (a2 = function(n3, r2) {
              return void 0 === n3 && (n3 = 0), this.ruleInvocationStateUpdate(l2, t3, n3), function(t4) {
                try {
                  if (true === this.outputCst) {
                    e2.apply(this, t4);
                    var n4 = this.CST_STACK[this.CST_STACK.length - 1];
                    return this.cstPostRule(n4), n4;
                  }
                  return e2.apply(this, t4);
                } catch (t5) {
                  var r3 = 1 === this.RULE_STACK.length, i2 = u2 && !this.isBackTracking() && this.recoveryEnabled;
                  if (o.isRecognitionException(t5)) {
                    if (i2) {
                      var a3, s2 = this.findReSyncTokenType();
                      if (this.isInCurrentRuleReSyncSet(s2))
                        return t5.resyncedTokens = this.reSyncTo(s2), this.outputCst ? ((a3 = this.CST_STACK[this.CST_STACK.length - 1]).recoveredNode = true, a3) : c2();
                      throw this.outputCst && ((a3 = this.CST_STACK[this.CST_STACK.length - 1]).recoveredNode = true, t5.partialCstResult = a3), t5;
                    }
                    if (r3)
                      return this.moveToTerminatedState(), c2();
                    throw t5;
                  }
                  throw t5;
                } finally {
                  this.ruleFinallyStateUpdate();
                }
              }.call(this, r2);
            }).ruleName = t3, a2;
          }, t2.prototype.optionInternal = function(t3, e2) {
            var n2 = this.getKeyForAutomaticLookahead(i.OPTION_IDX, e2), r2 = this.nestedRuleBeforeClause(t3, n2);
            try {
              return this.optionInternalLogic(t3, e2, n2);
            } finally {
              void 0 !== r2 && this.nestedRuleFinallyClause(n2, r2);
            }
          }, t2.prototype.optionInternalNoCst = function(t3, e2) {
            var n2 = this.getKeyForAutomaticLookahead(i.OPTION_IDX, e2);
            return this.optionInternalLogic(t3, e2, n2);
          }, t2.prototype.optionInternalLogic = function(t3, e2, n2) {
            var r2, i2, o2 = this, a2 = this.getLookaheadFuncForOption(n2, e2);
            if (void 0 !== t3.DEF) {
              if (r2 = t3.DEF, void 0 !== (i2 = t3.GATE)) {
                var u2 = a2;
                a2 = function() {
                  return i2.call(o2) && u2.call(o2);
                };
              }
            } else
              r2 = t3;
            if (true === a2.call(this))
              return r2.call(this);
          }, t2.prototype.atLeastOneInternal = function(t3, e2) {
            var n2 = this.getKeyForAutomaticLookahead(i.AT_LEAST_ONE_IDX, t3), r2 = this.nestedRuleBeforeClause(e2, n2);
            try {
              return this.atLeastOneInternalLogic(t3, e2, n2);
            } finally {
              void 0 !== r2 && this.nestedRuleFinallyClause(n2, r2);
            }
          }, t2.prototype.atLeastOneInternalNoCst = function(t3, e2) {
            var n2 = this.getKeyForAutomaticLookahead(i.AT_LEAST_ONE_IDX, t3);
            this.atLeastOneInternalLogic(t3, e2, n2);
          }, t2.prototype.atLeastOneInternalLogic = function(t3, e2, n2) {
            var r2, o2, s2 = this, c2 = this.getLookaheadFuncForAtLeastOne(n2, t3);
            if (void 0 !== e2.DEF) {
              if (r2 = e2.DEF, void 0 !== (o2 = e2.GATE)) {
                var l2 = c2;
                c2 = function() {
                  return o2.call(s2) && l2.call(s2);
                };
              }
            } else
              r2 = e2;
            if (true !== c2.call(this))
              throw this.raiseEarlyExitException(t3, a.PROD_TYPE.REPETITION_MANDATORY, e2.ERR_MSG);
            for (var E2 = this.doSingleRepetition(r2); true === c2.call(this) && true === E2; )
              E2 = this.doSingleRepetition(r2);
            this.attemptInRepetitionRecovery(this.atLeastOneInternal, [t3, e2], c2, i.AT_LEAST_ONE_IDX, t3, u.NextTerminalAfterAtLeastOneWalker);
          }, t2.prototype.atLeastOneSepFirstInternal = function(t3, e2) {
            var n2 = this.getKeyForAutomaticLookahead(i.AT_LEAST_ONE_SEP_IDX, t3), r2 = this.nestedRuleBeforeClause(e2, n2);
            try {
              this.atLeastOneSepFirstInternalLogic(t3, e2, n2);
            } finally {
              void 0 !== r2 && this.nestedRuleFinallyClause(n2, r2);
            }
          }, t2.prototype.atLeastOneSepFirstInternalNoCst = function(t3, e2) {
            var n2 = this.getKeyForAutomaticLookahead(i.AT_LEAST_ONE_SEP_IDX, t3);
            this.atLeastOneSepFirstInternalLogic(t3, e2, n2);
          }, t2.prototype.atLeastOneSepFirstInternalLogic = function(t3, e2, n2) {
            var r2 = this, o2 = e2.DEF, s2 = e2.SEP;
            if (true !== this.getLookaheadFuncForAtLeastOneSep(n2, t3).call(this))
              throw this.raiseEarlyExitException(t3, a.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, e2.ERR_MSG);
            o2.call(this);
            for (var c2 = function() {
              return r2.tokenMatcher(r2.LA(1), s2);
            }; true === this.tokenMatcher(this.LA(1), s2); )
              this.CONSUME(s2), o2.call(this);
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [t3, s2, c2, o2, u.NextTerminalAfterAtLeastOneSepWalker], c2, i.AT_LEAST_ONE_SEP_IDX, t3, u.NextTerminalAfterAtLeastOneSepWalker);
          }, t2.prototype.manyInternal = function(t3, e2) {
            var n2 = this.getKeyForAutomaticLookahead(i.MANY_IDX, t3), r2 = this.nestedRuleBeforeClause(e2, n2);
            try {
              return this.manyInternalLogic(t3, e2, n2);
            } finally {
              void 0 !== r2 && this.nestedRuleFinallyClause(n2, r2);
            }
          }, t2.prototype.manyInternalNoCst = function(t3, e2) {
            var n2 = this.getKeyForAutomaticLookahead(i.MANY_IDX, t3);
            return this.manyInternalLogic(t3, e2, n2);
          }, t2.prototype.manyInternalLogic = function(t3, e2, n2) {
            var r2, o2, a2 = this, s2 = this.getLookaheadFuncForMany(n2, t3);
            if (void 0 !== e2.DEF) {
              if (r2 = e2.DEF, void 0 !== (o2 = e2.GATE)) {
                var c2 = s2;
                s2 = function() {
                  return o2.call(a2) && c2.call(a2);
                };
              }
            } else
              r2 = e2;
            for (var l2 = true; true === s2.call(this) && true === l2; )
              l2 = this.doSingleRepetition(r2);
            this.attemptInRepetitionRecovery(this.manyInternal, [t3, e2], s2, i.MANY_IDX, t3, u.NextTerminalAfterManyWalker);
          }, t2.prototype.manySepFirstInternal = function(t3, e2) {
            var n2 = this.getKeyForAutomaticLookahead(i.MANY_SEP_IDX, t3), r2 = this.nestedRuleBeforeClause(e2, n2);
            try {
              this.manySepFirstInternalLogic(t3, e2, n2);
            } finally {
              void 0 !== r2 && this.nestedRuleFinallyClause(n2, r2);
            }
          }, t2.prototype.manySepFirstInternalNoCst = function(t3, e2) {
            var n2 = this.getKeyForAutomaticLookahead(i.MANY_SEP_IDX, t3);
            this.manySepFirstInternalLogic(t3, e2, n2);
          }, t2.prototype.manySepFirstInternalLogic = function(t3, e2, n2) {
            var r2 = this, o2 = e2.DEF, a2 = e2.SEP;
            if (true === this.getLookaheadFuncForManySep(n2, t3).call(this)) {
              o2.call(this);
              for (var s2 = function() {
                return r2.tokenMatcher(r2.LA(1), a2);
              }; true === this.tokenMatcher(this.LA(1), a2); )
                this.CONSUME(a2), o2.call(this);
              this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [t3, a2, s2, o2, u.NextTerminalAfterManySepWalker], s2, i.MANY_SEP_IDX, t3, u.NextTerminalAfterManySepWalker);
            }
          }, t2.prototype.repetitionSepSecondInternal = function(t3, e2, n2, r2, o2) {
            for (; n2(); )
              this.CONSUME(e2), r2.call(this);
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [t3, e2, n2, r2, o2], n2, i.AT_LEAST_ONE_SEP_IDX, t3, o2);
          }, t2.prototype.doSingleRepetition = function(t3) {
            var e2 = this.getLexerPosition();
            return t3.call(this), this.getLexerPosition() > e2;
          }, t2.prototype.orInternalNoCst = function(t3, e2) {
            var n2 = r.isArray(t3) ? t3 : t3.DEF, i2 = this.getLookaheadFuncForOr(e2, n2).call(this, n2);
            if (void 0 !== i2)
              return n2[i2].ALT.call(this);
            this.raiseNoAltException(e2, t3.ERR_MSG);
          }, t2.prototype.orInternal = function(t3, e2) {
            var n2 = this.getKeyForAutomaticLookahead(i.OR_IDX, e2), o2 = this.nestedRuleBeforeClause(t3, n2);
            try {
              var a2 = r.isArray(t3) ? t3 : t3.DEF, u2 = this.getLookaheadFuncForOr(e2, a2).call(this, a2);
              if (void 0 !== u2) {
                var s2 = a2[u2], c2 = this.nestedAltBeforeClause(s2, e2, i.OR_IDX, u2);
                try {
                  return s2.ALT.call(this);
                } finally {
                  void 0 !== c2 && this.nestedRuleFinallyClause(c2.shortName, c2.nestedName);
                }
              }
              this.raiseNoAltException(e2, t3.ERR_MSG);
            } finally {
              void 0 !== o2 && this.nestedRuleFinallyClause(n2, o2);
            }
          }, t2.prototype.ruleFinallyStateUpdate = function() {
            if (this.RULE_STACK.pop(), this.RULE_OCCURRENCE_STACK.pop(), this.cstFinallyStateUpdate(), 0 === this.RULE_STACK.length && !this.isAtEndOfInput()) {
              var t3 = this.LA(1), e2 = this.errorMessageProvider.buildNotAllInputParsedMessage({ firstRedundant: t3, ruleName: this.getCurrRuleFullName() });
              this.SAVE_ERROR(new o.NotAllInputParsedException(e2, t3));
            }
          }, t2.prototype.subruleInternal = function(t3, e2, n2) {
            var r2;
            try {
              var i2 = void 0 !== n2 ? n2.ARGS : void 0;
              return r2 = t3.call(this, e2, i2), this.cstPostNonTerminal(r2, void 0 !== n2 && void 0 !== n2.LABEL ? n2.LABEL : t3.ruleName), r2;
            } catch (e3) {
              throw o.isRecognitionException(e3) && void 0 !== e3.partialCstResult && (this.cstPostNonTerminal(e3.partialCstResult, void 0 !== n2 && void 0 !== n2.LABEL ? n2.LABEL : t3.ruleName), delete e3.partialCstResult), e3;
            }
          }, t2.prototype.consumeInternal = function(t3, e2, n2) {
            var r2;
            try {
              var i2 = this.LA(1);
              if (true !== this.tokenMatcher(i2, t3)) {
                var a2 = void 0, u2 = this.LA(0);
                throw a2 = void 0 !== n2 && n2.ERR_MSG ? n2.ERR_MSG : this.errorMessageProvider.buildMismatchTokenMessage({ expected: t3, actual: i2, previous: u2, ruleName: this.getCurrRuleFullName() }), this.SAVE_ERROR(new o.MismatchedTokenException(a2, i2, u2));
              }
              this.consumeToken(), r2 = i2;
            } catch (n3) {
              if (!this.recoveryEnabled || "MismatchedTokenException" !== n3.name || this.isBackTracking())
                throw n3;
              var s2 = this.getFollowsForInRuleRecovery(t3, e2);
              try {
                r2 = this.tryInRuleRecovery(t3, s2);
              } catch (t4) {
                throw t4.name === c.IN_RULE_RECOVERY_EXCEPTION ? n3 : t4;
              }
            }
            return this.cstPostTerminal(void 0 !== n2 && void 0 !== n2.LABEL ? n2.LABEL : t3.tokenName, r2), r2;
          }, t2.prototype.saveRecogState = function() {
            var t3 = this.errors, e2 = r.cloneArr(this.RULE_STACK);
            return { errors: t3, lexerState: this.exportLexerState(), RULE_STACK: e2, CST_STACK: this.CST_STACK, LAST_EXPLICIT_RULE_STACK: this.LAST_EXPLICIT_RULE_STACK };
          }, t2.prototype.reloadRecogState = function(t3) {
            this.errors = t3.errors, this.importLexerState(t3.lexerState), this.RULE_STACK = t3.RULE_STACK;
          }, t2.prototype.ruleInvocationStateUpdate = function(t3, e2, n2) {
            this.RULE_OCCURRENCE_STACK.push(n2), this.RULE_STACK.push(t3), this.cstInvocationStateUpdate(e2, t3);
          }, t2.prototype.isBackTracking = function() {
            return !r.isEmpty(this.isBackTrackingStack);
          }, t2.prototype.getCurrRuleFullName = function() {
            var t3 = this.getLastExplicitRuleShortName();
            return this.shortRuleNameToFull.get(t3);
          }, t2.prototype.shortRuleNameToFullName = function(t3) {
            return this.shortRuleNameToFull.get(t3);
          }, t2.prototype.isAtEndOfInput = function() {
            return this.tokenMatcher(this.LA(1), l.EOF);
          }, t2.prototype.reset = function() {
            this.resetLexerState(), this.isBackTrackingStack = [], this.errors = [], this.RULE_STACK = [], this.LAST_EXPLICIT_RULE_STACK = [], this.CST_STACK = [], this.RULE_OCCURRENCE_STACK = [];
          }, t2;
        }();
        e.RecognizerEngine = f;
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(13), i = n(4), o = n(19), a = n(8), u = function() {
          function t2() {
          }
          return t2.prototype.initErrorHandler = function(t3) {
            this._errors = [], this.errorMessageProvider = i.defaults(t3.errorMessageProvider, a.DEFAULT_PARSER_CONFIG.errorMessageProvider);
          }, t2.prototype.SAVE_ERROR = function(t3) {
            if (r.isRecognitionException(t3))
              return t3.context = { ruleStack: this.getHumanReadableRuleStack(), ruleOccurrenceStack: i.cloneArr(this.RULE_OCCURRENCE_STACK) }, this._errors.push(t3), t3;
            throw Error("Trying to save an Error which is not a RecognitionException");
          }, Object.defineProperty(t2.prototype, "errors", { get: function() {
            return i.cloneArr(this._errors);
          }, set: function(t3) {
            this._errors = t3;
          }, enumerable: true, configurable: true }), t2.prototype.raiseEarlyExitException = function(t3, e2, n2) {
            for (var i2 = this.getCurrRuleFullName(), a2 = this.getGAstProductions().get(i2), u2 = o.getLookaheadPathsForOptionalProd(t3, a2, e2, this.maxLookahead)[0], s = [], c = 1; c < this.maxLookahead; c++)
              s.push(this.LA(c));
            var l = this.errorMessageProvider.buildEarlyExitMessage({ expectedIterationPaths: u2, actual: s, previous: this.LA(0), customUserDescription: n2, ruleName: i2 });
            throw this.SAVE_ERROR(new r.EarlyExitException(l, this.LA(1), this.LA(0)));
          }, t2.prototype.raiseNoAltException = function(t3, e2) {
            for (var n2 = this.getCurrRuleFullName(), i2 = this.getGAstProductions().get(n2), a2 = o.getLookaheadPathsForOr(t3, i2, this.maxLookahead), u2 = [], s = 1; s <= this.maxLookahead; s++)
              u2.push(this.LA(s));
            var c = this.LA(0), l = this.errorMessageProvider.buildNoViableAltMessage({ expectedPathsPerAlt: a2, actual: u2, previous: c, customUserDescription: e2, ruleName: this.getCurrRuleFullName() });
            throw this.SAVE_ERROR(new r.NoViableAltException(l, this.LA(1), c));
          }, t2;
        }();
        e.ErrorHandler = u;
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(20), i = n(4), o = function() {
          function t2() {
          }
          return t2.prototype.initContentAssist = function() {
          }, t2.prototype.computeContentAssist = function(t3, e2) {
            var n2 = this.gastProductionsCache.get(t3);
            if (i.isUndefined(n2))
              throw Error("Rule ->" + t3 + "<- does not exist in this grammar.");
            return r.nextPossibleTokensAfter([n2], e2, this.tokenMatcher, this.maxLookahead);
          }, t2.prototype.getNextPossibleTokenTypes = function(t3) {
            var e2 = i.first(t3.ruleStack), n2 = this.getGAstProductions().get(e2);
            return new r.NextAfterTokenWalker(n2, t3).startWalking();
          }, t2;
        }();
        e.ContentAssist = o;
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(25);
        e.createSyntaxDiagramsCode = function(t2, e2) {
          var n2 = void 0 === e2 ? {} : e2, i = n2.resourceBase, o = void 0 === i ? "https://unpkg.com/chevrotain@" + r.VERSION + "/diagrams/" : i, a = n2.css;
          return `
<!-- This is a generated file -->
<!DOCTYPE html>
<meta charset="utf-8">
<style>
  body {
    background-color: hsl(30, 20%, 95%)
  }
</style>


<link rel='stylesheet' href='` + (void 0 === a ? "https://unpkg.com/chevrotain@" + r.VERSION + "/diagrams/diagrams.css" : a) + "'>\n\n<script src='" + o + "vendor/railroad-diagrams.js'></script>\n<script src='" + o + "src/diagrams_builder.js'></script>\n<script src='" + o + "src/diagrams_behavior.js'></script>\n<script src='" + o + `src/main.js'></script>

<div id="diagrams" align="center"></div>    

<script>
    window.serializedGrammar = ` + JSON.stringify(t2, null, "  ") + ';\n</script>\n\n<script>\n    var diagramsDiv = document.getElementById("diagrams");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n</script>\n';
        };
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(52);
        e.generateParserFactory = function(t2) {
          var e2 = r.genWrapperFunction({ name: t2.name, rules: t2.rules }), i = new Function("tokenVocabulary", "config", "chevrotain", e2);
          return function(e3) {
            return i(t2.tokenVocabulary, e3, n(1));
          };
        }, e.generateParserModule = function(t2) {
          return r.genUmdModule({ name: t2.name, rules: t2.rules });
        };
      }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var r = n(4), i = n(7), o = n(6), a = "\n";
        function u(t2) {
          return "\nfunction " + t2.name + "(tokenVocabulary, config) {\n    // invoke super constructor\n    // No support for embedded actions currently, so we can 'hardcode'\n    // The use of CstParser.\n    chevrotain.CstParser.call(this, tokenVocabulary, config)\n\n    const $ = this\n\n    " + s(t2.rules) + "\n\n    // very important to call this after all the rules have been defined.\n    // otherwise the parser may not work correctly as it will lack information\n    // derived during the self analysis phase.\n    this.performSelfAnalysis(this)\n}\n\n// inheritance as implemented in javascript in the previous decade... :(\n" + t2.name + ".prototype = Object.create(chevrotain.CstParser.prototype)\n" + t2.name + ".prototype.constructor = " + t2.name + "    \n    ";
        }
        function s(t2) {
          return r.map(t2, function(t3) {
            return c(t3, 1);
          }).join("\n");
        }
        function c(t2, e2) {
          var n2 = T(e2, '$.RULE("' + t2.name + '", function() {') + a;
          return n2 += h(t2.definition, e2 + 1), n2 += T(e2 + 1, "})") + a;
        }
        function l(t2, e2) {
          var n2 = i.tokenName(t2.terminalType);
          return T(e2, "$.CONSUME" + t2.idx + "(this.tokensMap." + n2 + ")" + a);
        }
        function E(t2, e2) {
          return T(e2, "$.SUBRULE" + t2.idx + "($." + t2.nonTerminalName + ")" + a);
        }
        function p(t2, e2) {
          var n2 = T(e2, "$.OR" + t2.idx + "([") + a;
          return n2 += r.map(t2.definition, function(t3) {
            return f(t3, e2 + 1);
          }).join("," + a), n2 += a + T(e2, "])" + a);
        }
        function f(t2, e2) {
          var n2 = T(e2, "{") + a;
          return t2.name && (n2 += T(e2 + 1, 'NAME: "' + t2.name + '",') + a), n2 += T(e2 + 1, "ALT: function() {") + a, n2 += h(t2.definition, e2 + 1), n2 += T(e2 + 1, "}") + a, n2 += T(e2, "}");
        }
        function L(t2, e2, n2) {
          var r2 = T(n2, "$." + (t2 + e2.idx) + "(");
          return e2.name || e2.separator ? (r2 += "{" + a, e2.name && (r2 += T(n2 + 1, 'NAME: "' + e2.name + '"') + "," + a), e2.separator && (r2 += T(n2 + 1, "SEP: this.tokensMap." + i.tokenName(e2.separator)) + "," + a), r2 += "DEF: " + S(e2.definition, n2 + 2) + a, r2 += T(n2, "}") + a) : r2 += S(e2.definition, n2 + 1), r2 += T(n2, ")") + a;
        }
        function S(t2, e2) {
          var n2 = "function() {" + a;
          return n2 += h(t2, e2), n2 += T(e2, "}") + a;
        }
        function h(t2, e2) {
          var n2 = "";
          return r.forEach(t2, function(t3) {
            n2 += function(t4, e3) {
              if (t4 instanceof o.NonTerminal)
                return E(t4, e3);
              if (t4 instanceof o.Option)
                return L("OPTION", t4, e3);
              if (t4 instanceof o.RepetitionMandatory)
                return L("AT_LEAST_ONE", t4, e3);
              if (t4 instanceof o.RepetitionMandatoryWithSeparator)
                return L("AT_LEAST_ONE_SEP", t4, e3);
              if (t4 instanceof o.RepetitionWithSeparator)
                return L("MANY_SEP", t4, e3);
              if (t4 instanceof o.Repetition)
                return L("MANY", t4, e3);
              if (t4 instanceof o.Alternation)
                return p(t4, e3);
              if (t4 instanceof o.Terminal)
                return l(t4, e3);
              if (t4 instanceof o.Flat)
                return h(t4.definition, e3);
              throw Error("non exhaustive match");
            }(t3, e2 + 1);
          }), n2;
        }
        function T(t2, e2) {
          return Array(4 * t2 + 1).join(" ") + e2;
        }
        e.genUmdModule = function(t2) {
          return "\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['chevrotain'], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory(require('chevrotain'));\n    } else {\n        // Browser globals (root is window)\n        root.returnExports = factory(root.b);\n    }\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\n\n" + u(t2) + "\n    \nreturn {\n    " + t2.name + ": " + t2.name + " \n}\n}));\n";
        }, e.genWrapperFunction = function(t2) {
          return "    \n" + u(t2) + "\nreturn new " + t2.name + "(tokenVocabulary, config)    \n";
        }, e.genClass = u, e.genAllRules = s, e.genRule = c, e.genTerminal = l, e.genNonTerminal = E, e.genAlternation = p, e.genSingleAlt = f;
      }, function(t, e, n) {
        "use strict";
        n.d(e, "a", function() {
          return W3SpecSparqlParser;
        });
        var r, i = n(21), o = n(1), a = (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        }), u = n(9).baseTokens, W3SpecSparqlParser = function(t2) {
          function W3SpecSparqlParser2(e2) {
            var n2 = t2.call(this, e2, u) || this;
            return o.Parser.performSelfAnalysis(n2), n2;
          }
          return a(W3SpecSparqlParser2, t2), W3SpecSparqlParser2;
        }(i.a);
      }, function(t, e, n) {
        "use strict";
        n.d(e, "a", function() {
          return BaseGraphQlParser;
        });
        var r, i = n(1), o = (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        }), a = function() {
          return (a = Object.assign || function(t2) {
            for (var e2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
              for (var i2 in e2 = arguments[n2])
                Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
            return t2;
          }).apply(this, arguments);
        }, u = n(57).graphQlTokenMap, BaseGraphQlParser = function(t2) {
          function BaseGraphQlParser2(e2, n2) {
            void 0 === e2 && (e2 = {});
            var r2 = t2.call(this, n2, a({ recoveryEnabled: true, outputCst: true }, e2.config)) || this;
            return r2.tokenize = function(t3) {
              return r2.lexer.tokenize(t3).tokens;
            }, r2.parse = function(t3, e3) {
              void 0 === e3 && (e3 = r2.Document), r2.input = r2.lexer.tokenize(t3).tokens;
              var n3 = e3.call(r2);
              return { errors: r2.errors, cst: n3 };
            }, r2.Document = r2.RULE("Document", function() {
              r2.AT_LEAST_ONE(function() {
                return r2.SUBRULE(r2.Definition);
              });
            }), r2.Definition = r2.RULE("Definition", function() {
              r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.ExecutableDefinition);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.TypeSystemDefinition);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.TypeSystemExtension);
              } }]);
            }), r2.ExecutableDefinition = r2.RULE("ExecutableDefinition", function() {
              r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.OperationDefinition);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.FragmentDefinition);
              } }]);
            }), r2.OperationDefinition = r2.RULE("OperationDefinition", function() {
              r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.SelectionSet);
              } }, { ALT: function() {
                r2.SUBRULE(r2.OperationType), r2.OPTION(function() {
                  return r2.CONSUME(u.Name);
                }), r2.OPTION1(function() {
                  return r2.SUBRULE(r2.VariableDefinitions);
                }), r2.OPTION2(function() {
                  return r2.SUBRULE(r2.Directives);
                }), r2.SUBRULE1(r2.SelectionSet);
              } }]);
            }), r2.OperationType = r2.RULE("OperationType", function() {
              r2.OR([{ ALT: function() {
                return r2.CONSUME(u.Query);
              } }, { ALT: function() {
                return r2.CONSUME(u.Mutation);
              } }, { ALT: function() {
                return r2.CONSUME(u.Subscription);
              } }]);
            }), r2.SelectionSet = r2.RULE("SelectionSet", function() {
              r2.CONSUME(u.LCurly), r2.AT_LEAST_ONE(function() {
                return r2.SUBRULE(r2.Selection);
              }), r2.CONSUME(u.RCurly);
            }), r2.Selection = r2.RULE("Selection", function() {
              r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.Field);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.InlineFragment);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.FragmentSpread);
              } }]);
            }), r2.Field = r2.RULE("Field", function() {
              r2.OPTION(function() {
                return r2.SUBRULE(r2.Alias);
              }), r2.CONSUME(u.Name), r2.OPTION1(function() {
                return r2.SUBRULE(r2.Arguments, { ARGS: [false] });
              }), r2.OPTION2(function() {
                return r2.SUBRULE(r2.Directives);
              }), r2.OPTION3(function() {
                return r2.SUBRULE(r2.SelectionSet);
              });
            }), r2.Alias = r2.RULE("Alias", function() {
              r2.CONSUME(u.Name), r2.CONSUME(u.Colon);
            }), r2.Arguments = r2.RULE("Arguments", function(t3) {
              r2.CONSUME(u.LParen), r2.AT_LEAST_ONE(function() {
                return r2.SUBRULE(r2.Argument, { ARGS: [t3] });
              }), r2.CONSUME(u.RParen);
            }), r2.Argument = r2.RULE("Argument", function(t3) {
              r2.SUBRULE(r2.Alias), r2.SUBRULE(r2.Value, { ARGS: [t3] });
            }), r2.FragmentSpread = r2.RULE("FragmentSpread", function() {
              r2.CONSUME(u.Spread), r2.CONSUME(u.FragmentName), r2.OPTION(function() {
                return r2.SUBRULE(r2.Directives);
              });
            }), r2.InlineFragment = r2.RULE("InlineFragment", function() {
              r2.CONSUME(u.Spread), r2.OPTION(function() {
                return r2.SUBRULE(r2.TypeCondition);
              }), r2.OPTION1(function() {
                return r2.SUBRULE(r2.Directives);
              }), r2.SUBRULE(r2.SelectionSet);
            }), r2.FragmentDefinition = r2.RULE("FragmentDefinition", function() {
              r2.CONSUME(u.Fragment), r2.CONSUME(u.FragmentName), r2.SUBRULE(r2.TypeCondition), r2.OPTION(function() {
                return r2.SUBRULE(r2.Directives);
              }), r2.SUBRULE(r2.SelectionSet);
            }), r2.TypeCondition = r2.RULE("TypeCondition", function() {
              r2.CONSUME(u.On), r2.SUBRULE(r2.NamedType);
            }), r2.Value = r2.RULE("Value", function(t3) {
              r2.OR([{ GATE: function() {
                return !t3;
              }, ALT: function() {
                return r2.SUBRULE(r2.Variable);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.IntValue);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.FloatValue);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.StringValue);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BooleanValue);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.NullValue);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.EnumValue);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.ListValue, { ARGS: [t3] });
              } }, { ALT: function() {
                return r2.SUBRULE(r2.ObjectValue, { ARGS: [t3] });
              } }]);
            }), r2.IntValue = r2.RULE("IntValue", function() {
              r2.CONSUME(u.IntValueToken);
            }), r2.FloatValue = r2.RULE("FloatValue", function() {
              r2.CONSUME(u.FloatValueToken);
            }), r2.StringValue = r2.RULE("StringValue", function() {
              r2.CONSUME(u.StringValueToken);
            }), r2.BooleanValue = r2.RULE("BooleanValue", function() {
              r2.CONSUME(u.BooleanValueToken);
            }), r2.NullValue = r2.RULE("NullValue", function() {
              r2.CONSUME(u.NullValueToken);
            }), r2.EnumValue = r2.RULE("EnumValue", function() {
              r2.CONSUME(u.EnumValueToken);
            }), r2.ListValue = r2.RULE("ListValue", function(t3) {
              r2.CONSUME(u.LBracket), r2.MANY(function() {
                return r2.SUBRULE(r2.Value, { ARGS: [t3] });
              }), r2.CONSUME(u.RBracket);
            }), r2.ObjectValue = r2.RULE("ObjectValue", function(t3) {
              r2.CONSUME(u.LCurly), r2.MANY(function() {
                return r2.SUBRULE(r2.ObjectField, { ARGS: [t3] });
              }), r2.CONSUME(u.RCurly);
            }), r2.ObjectField = r2.RULE("ObjectField", function(t3) {
              r2.SUBRULE(r2.Alias), r2.SUBRULE(r2.Value, { ARGS: [t3] });
            }), r2.VariableDefinitions = r2.RULE("VariableDefinitions", function() {
              r2.CONSUME(u.LParen), r2.AT_LEAST_ONE(function() {
                return r2.SUBRULE(r2.VariableDefinition);
              }), r2.CONSUME(u.RParen);
            }), r2.VariableDefinition = r2.RULE("VariableDefinition", function() {
              r2.SUBRULE(r2.Variable), r2.CONSUME(u.Colon), r2.SUBRULE(r2.Type), r2.OPTION(function() {
                return r2.SUBRULE(r2.DefaultValue);
              });
            }), r2.Variable = r2.RULE("Variable", function() {
              r2.CONSUME(u.Dollar), r2.CONSUME(u.Name);
            }), r2.DefaultValue = r2.RULE("DefaultValue", function() {
              r2.CONSUME(u.Equals), r2.SUBRULE(r2.Value, { ARGS: [true] });
            }), r2.Type = r2.RULE("Type", function() {
              r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.NamedType);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.ListType);
              } }]), r2.OPTION(function() {
                return r2.CONSUME(u.Bang);
              });
            }), r2.NamedType = r2.RULE("NamedType", function() {
              r2.CONSUME(u.Name);
            }), r2.ListType = r2.RULE("ListType", function() {
              r2.CONSUME(u.LBracket), r2.SUBRULE(r2.Type), r2.CONSUME(u.RBracket);
            }), r2.Directives = r2.RULE("Directives", function(t3) {
              r2.AT_LEAST_ONE(function() {
                return r2.SUBRULE(r2.Directive, { ARGS: [t3] });
              });
            }), r2.Directive = r2.RULE("Directive", function(t3) {
              r2.CONSUME(u.At), r2.CONSUME(u.Name), r2.OPTION(function() {
                return r2.SUBRULE(r2.Arguments, { ARGS: [t3] });
              });
            }), r2.TypeSystemDefinition = r2.RULE("TypeSystemDefinition", function() {
              r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.SchemaDefinition);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.TypeDefinition);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.DirectiveDefinition);
              } }]);
            }), r2.TypeSystemExtension = r2.RULE("TypeSystemExtension", function() {
              r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.SchemaExtension);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.TypeExtension);
              } }]);
            }), r2.SchemaDefinition = r2.RULE("SchemaDefinition", function() {
              r2.CONSUME(u.Schema), r2.OPTION(function() {
                return r2.SUBRULE(r2.Directives, { ARGS: [true] });
              }), r2.CONSUME(u.LCurly), r2.AT_LEAST_ONE(function() {
                return r2.SUBRULE(r2.OperationTypeDefinition);
              }), r2.CONSUME(u.RCurly);
            }), r2.SchemaExtension = r2.RULE("SchemaExtension", function() {
              r2.CONSUME(u.Extend), r2.CONSUME(u.Schema), r2.OR([{ ALT: function() {
                r2.SUBRULE(r2.Directives, { ARGS: [true] }), r2.OPTION(function() {
                  return r2.SUBRULE1(r2.OperationTypeDefinitionList);
                });
              } }, { ALT: function() {
                return r2.SUBRULE(r2.OperationTypeDefinitionList);
              } }]);
            }), r2.OperationTypeDefinitionList = r2.RULE("OperationTypeDefinitionList", function() {
              r2.CONSUME(u.LCurly), r2.AT_LEAST_ONE(function() {
                return r2.SUBRULE(r2.OperationTypeDefinition);
              }), r2.CONSUME(u.RCurly);
            }), r2.OperationTypeDefinition = r2.RULE("OperationTypeDefinition", function() {
              r2.SUBRULE(r2.OperationType), r2.CONSUME(u.Colon), r2.SUBRULE(r2.NamedType);
            }), r2.Description = r2.RULE("Description", function() {
              r2.SUBRULE(r2.StringValue);
            }), r2.TypeDefinition = r2.RULE("TypeDefinition", function() {
              r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.ScalarTypeDefinition);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.ObjectTypeDefinition);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.InterfaceTypeDefinition);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.UnionTypeDefinition);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.EnumTypeDefinition);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.InputObjectTypeDefinition);
              } }]);
            }), r2.TypeExtension = r2.RULE("TypeExtension", function() {
              r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.ScalarTypeExtension);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.ObjectTypeExtension);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.InterfaceTypeExtension);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.UnionTypeExtension);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.EnumTypeExtension);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.InputObjectTypeExtension);
              } }]);
            }), r2.ScalarTypeDefinition = r2.RULE("ScalarTypeDefinition", function() {
              r2.OPTION(function() {
                return r2.SUBRULE(r2.Description);
              }), r2.CONSUME(u.Scalar), r2.CONSUME(u.Name), r2.OPTION1(function() {
                return r2.SUBRULE(r2.Directives, { ARGS: [true] });
              });
            }), r2.ScalarTypeExtension = r2.RULE("ScalarTypeExtension", function() {
              r2.CONSUME(u.Extend), r2.CONSUME(u.Scalar), r2.CONSUME(u.Name), r2.SUBRULE(r2.Directives, { ARGS: [true] });
            }), r2.ObjectTypeDefinition = r2.RULE("ObjectTypeDefinition", function() {
              r2.OPTION(function() {
                return r2.SUBRULE(r2.Description);
              }), r2.CONSUME(u.TypeToken), r2.CONSUME(u.Name), r2.OPTION1(function() {
                return r2.SUBRULE(r2.ImplementsInterfaces);
              }), r2.OPTION2(function() {
                return r2.SUBRULE1(r2.Directives, { ARGS: [true] });
              }), r2.OPTION3(function() {
                return r2.SUBRULE(r2.FieldsDefinition);
              });
            }), r2.ObjectTypeExtension = r2.RULE("ObjectTypeExtension", function() {
              r2.CONSUME(u.Extend), r2.CONSUME(u.TypeToken), r2.CONSUME(u.Name), r2.OR([{ ALT: function() {
                r2.SUBRULE(r2.ImplementsInterfaces), r2.OPTION(function() {
                  return r2.SUBRULE1(r2.Directives, { ARGS: [true] });
                }), r2.OPTION1(function() {
                  return r2.SUBRULE(r2.FieldsDefinition);
                });
              } }, { ALT: function() {
                r2.SUBRULE(r2.Directives, { ARGS: [true] }), r2.OPTION2(function() {
                  return r2.SUBRULE1(r2.FieldsDefinition);
                });
              } }, { ALT: function() {
                return r2.SUBRULE2(r2.FieldsDefinition);
              } }]);
            }), r2.ImplementsInterfaces = r2.RULE("ImplementsInterfaces", function() {
              r2.CONSUME(u.Implements), r2.OPTION(function() {
                return r2.CONSUME(u.Amp);
              }), r2.SUBRULE(r2.NamedType), r2.MANY(function() {
                r2.CONSUME1(u.Amp), r2.SUBRULE1(r2.NamedType);
              });
            }), r2.FieldsDefinition = r2.RULE("FieldsDefinition", function() {
              r2.CONSUME(u.LCurly), r2.AT_LEAST_ONE(function() {
                return r2.SUBRULE(r2.FieldDefinition);
              }), r2.CONSUME(u.RCurly);
            }), r2.FieldDefinition = r2.RULE("FieldDefinition", function() {
              r2.OPTION(function() {
                return r2.SUBRULE(r2.Description);
              }), r2.CONSUME(u.Name), r2.OPTION1(function() {
                return r2.SUBRULE(r2.ArgumentsDefinition);
              }), r2.CONSUME(u.Colon), r2.SUBRULE(r2.Type), r2.OPTION2(function() {
                return r2.SUBRULE(r2.Directives, { ARGS: [true] });
              });
            }), r2.ArgumentsDefinition = r2.RULE("ArgumentsDefinition", function() {
              r2.CONSUME(u.LParen), r2.AT_LEAST_ONE(function() {
                return r2.SUBRULE(r2.InputValueDefinition);
              }), r2.CONSUME(u.RParen);
            }), r2.InputValueDefinition = r2.RULE("InputValueDefinition", function() {
              r2.OPTION(function() {
                return r2.SUBRULE(r2.Description);
              }), r2.CONSUME(u.Name), r2.CONSUME(u.Colon), r2.SUBRULE(r2.Type), r2.OPTION1(function() {
                return r2.SUBRULE(r2.DefaultValue);
              }), r2.OPTION2(function() {
                return r2.SUBRULE(r2.Directives, { ARGS: [true] });
              });
            }), r2.InterfaceTypeDefinition = r2.RULE("InterfaceTypeDefinition", function() {
              r2.OPTION(function() {
                return r2.SUBRULE(r2.Description);
              }), r2.CONSUME(u.Interface), r2.CONSUME(u.Name), r2.OPTION2(function() {
                return r2.SUBRULE(r2.Directives, { ARGS: [true] });
              }), r2.OPTION3(function() {
                return r2.SUBRULE(r2.FieldsDefinition);
              });
            }), r2.InterfaceTypeExtension = r2.RULE("InterfaceTypeExtension", function() {
              r2.CONSUME(u.Extend), r2.CONSUME(u.Interface), r2.CONSUME(u.Name), r2.OR([{ ALT: function() {
                r2.SUBRULE(r2.Directives, { ARGS: [true] }), r2.OPTION(function() {
                  return r2.SUBRULE(r2.FieldsDefinition);
                });
              } }, { ALT: function() {
                return r2.SUBRULE1(r2.FieldsDefinition);
              } }]);
            }), r2.UnionTypeDefinition = r2.RULE("UnionTypeDefinition", function() {
              r2.OPTION(function() {
                return r2.SUBRULE(r2.Description);
              }), r2.CONSUME(u.Union), r2.CONSUME(u.Name), r2.OPTION1(function() {
                return r2.SUBRULE(r2.Directives, { ARGS: [true] });
              }), r2.OPTION2(function() {
                return r2.SUBRULE(r2.UnionMemberTypes);
              });
            }), r2.UnionMemberTypes = r2.RULE("UnionMemberTypes", function() {
              r2.CONSUME(u.Equals), r2.OPTION(function() {
                return r2.CONSUME(u.Pipe);
              }), r2.SUBRULE(r2.NamedType), r2.MANY(function() {
                r2.CONSUME1(u.Pipe), r2.SUBRULE1(r2.NamedType);
              });
            }), r2.UnionTypeExtension = r2.RULE("UnionTypeExtension", function() {
              r2.CONSUME(u.Extend), r2.CONSUME(u.Union), r2.CONSUME(u.Name), r2.OR([{ ALT: function() {
                r2.SUBRULE(r2.Directives, { ARGS: [true] }), r2.OPTION(function() {
                  return r2.SUBRULE(r2.UnionMemberTypes);
                });
              } }, { ALT: function() {
                return r2.SUBRULE1(r2.UnionMemberTypes);
              } }]);
            }), r2.EnumTypeDefinition = r2.RULE("EnumTypeDefinition", function() {
              r2.OPTION(function() {
                return r2.SUBRULE(r2.Description);
              }), r2.CONSUME(u.Enum), r2.CONSUME(u.Name), r2.OPTION1(function() {
                return r2.SUBRULE(r2.Directives, { ARGS: [true] });
              }), r2.OPTION2(function() {
                return r2.SUBRULE(r2.EnumValuesDefinition);
              });
            }), r2.EnumValuesDefinition = r2.RULE("EnumValuesDefinition", function() {
              r2.CONSUME(u.LCurly), r2.AT_LEAST_ONE(function() {
                return r2.SUBRULE(r2.EnumValueDefinition);
              }), r2.CONSUME(u.RCurly);
            }), r2.EnumValueDefinition = r2.RULE("EnumValueDefinition", function() {
              r2.OPTION(function() {
                return r2.SUBRULE(r2.Description);
              }), r2.SUBRULE(r2.EnumValue), r2.OPTION1(function() {
                return r2.SUBRULE(r2.Directives, { ARGS: [true] });
              });
            }), r2.EnumTypeExtension = r2.RULE("EnumTypeExtension", function() {
              r2.CONSUME(u.Extend), r2.CONSUME(u.Enum), r2.CONSUME(u.Name), r2.OR([{ ALT: function() {
                r2.SUBRULE(r2.Directives, { ARGS: [true] }), r2.OPTION(function() {
                  return r2.SUBRULE(r2.EnumValuesDefinition);
                });
              } }, { ALT: function() {
                return r2.SUBRULE1(r2.EnumValuesDefinition);
              } }]);
            }), r2.InputObjectTypeDefinition = r2.RULE("InputObjectTypeDefinition", function() {
              r2.OPTION(function() {
                return r2.SUBRULE(r2.Description);
              }), r2.CONSUME(u.Input), r2.CONSUME(u.Name), r2.OPTION1(function() {
                return r2.SUBRULE(r2.Directives, { ARGS: [true] });
              }), r2.OPTION2(function() {
                return r2.SUBRULE(r2.InputFieldsDefinition);
              });
            }), r2.InputFieldsDefinition = r2.RULE("InputFieldsDefinition", function() {
              r2.CONSUME(u.LCurly), r2.AT_LEAST_ONE(function() {
                return r2.SUBRULE(r2.InputValueDefinition);
              }), r2.CONSUME(u.RCurly);
            }), r2.InputObjectTypeExtension = r2.RULE("InputObjectTypeExtension", function() {
              r2.CONSUME(u.Extend), r2.CONSUME(u.Input), r2.CONSUME(u.Name), r2.OR([{ ALT: function() {
                r2.SUBRULE(r2.Directives, { ARGS: [true] }), r2.OPTION(function() {
                  return r2.SUBRULE1(r2.InputFieldsDefinition);
                });
              } }, { ALT: function() {
                return r2.SUBRULE(r2.InputFieldsDefinition);
              } }]);
            }), r2.DirectiveDefinition = r2.RULE("DirectiveDefinition", function() {
              r2.OPTION(function() {
                return r2.SUBRULE(r2.Description);
              }), r2.CONSUME(u.DirectiveToken), r2.CONSUME(u.At), r2.CONSUME(u.Name), r2.OPTION1(function() {
                return r2.SUBRULE(r2.ArgumentsDefinition);
              }), r2.CONSUME(u.On), r2.SUBRULE(r2.DirectiveLocations);
            }), r2.DirectiveLocations = r2.RULE("DirectiveLocations", function() {
              r2.OPTION(function() {
                return r2.CONSUME(u.Pipe);
              }), r2.SUBRULE(r2.DirectiveLocation), r2.MANY(function() {
                r2.CONSUME1(u.Pipe), r2.SUBRULE1(r2.DirectiveLocation);
              });
            }), r2.DirectiveLocation = r2.RULE("DirectiveLocation", function() {
              r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.ExecutableDirectiveLocation);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.TypeSystemDirectiveLocation);
              } }]);
            }), r2.ExecutableDirectiveLocation = r2.RULE("ExecutableDirectiveLocation", function() {
              r2.OR([{ ALT: function() {
                return r2.CONSUME(u.QUERY);
              } }, { ALT: function() {
                return r2.CONSUME(u.MUTATION);
              } }, { ALT: function() {
                return r2.CONSUME(u.SUBSCRIPTION);
              } }, { ALT: function() {
                return r2.CONSUME(u.FIELD);
              } }, { ALT: function() {
                return r2.CONSUME(u.FRAGMENT_DEFINITION);
              } }, { ALT: function() {
                return r2.CONSUME(u.FRAGMENT_SPREAD);
              } }, { ALT: function() {
                return r2.CONSUME(u.INLINE_FRAGMENT);
              } }]);
            }), r2.TypeSystemDirectiveLocation = r2.RULE("TypeSystemDirectiveLocation", function() {
              r2.OR([{ ALT: function() {
                return r2.CONSUME(u.SCHEMA);
              } }, { ALT: function() {
                return r2.CONSUME(u.SCALAR);
              } }, { ALT: function() {
                return r2.CONSUME(u.OBJECT);
              } }, { ALT: function() {
                return r2.CONSUME(u.FIELD_DEFINITION);
              } }, { ALT: function() {
                return r2.CONSUME(u.ARGUMENT_DEFINITION);
              } }, { ALT: function() {
                return r2.CONSUME(u.INTERFACE);
              } }, { ALT: function() {
                return r2.CONSUME(u.UNION);
              } }, { ALT: function() {
                return r2.CONSUME(u.ENUM);
              } }, { ALT: function() {
                return r2.CONSUME(u.ENUM_VALUE);
              } }, { ALT: function() {
                return r2.CONSUME(u.INPUT_OBJECT);
              } }, { ALT: function() {
                return r2.CONSUME(u.INPUT_FIELD_DEFINITION);
              } }]);
            }), r2.lexer = new i.Lexer(n2), r2;
          }
          return o(BaseGraphQlParser2, t2), BaseGraphQlParser2;
        }(i.Parser);
      }, function(t, e, n) {
        "use strict";
        n.d(e, "a", function() {
          return L;
        });
        var r = n(1), i = n(12), o = n(57).stardogGraphQlTokenMap, a = o.ToArgumentToken, u = o.IfArgumentToken, s = o.AliasArgumentToken, c = o.GraphArgumentToken, l = o.BindDirectiveToken, E = o.ConfigDirectiveToken, p = [o.SkipDirectiveToken, o.IncludeDirectiveToken, o.FilterDirectiveToken], f = [l].concat(p);
        var L = { getArgumentNodes: function(t2) {
          if (!t2 || !t2.Arguments)
            return [];
          var e2 = t2.Arguments[0];
          return Object(i.b)(e2) && e2.children.Argument || [];
        }, getArgumentTokenTypesForDirectiveNameToken: function(t2) {
          return Object(r.tokenMatcher)(t2, l) ? [a] : Object(r.tokenMatcher)(t2, E) ? [s, c] : p.some(function(e2) {
            return Object(r.tokenMatcher)(t2, e2);
          }) ? [u] : [];
        }, isSparqlReceivingStardogDirective: function(t2) {
          return f.some(function(e2) {
            return Object(r.tokenMatcher)(t2, e2);
          });
        } };
      }, function(t, e, n) {
        "use strict";
        n.r(e), n.d(e, "sparqlTokens", function() {
          return a;
        }), n.d(e, "keywords", function() {
          return u;
        }), n.d(e, "terminals", function() {
          return s;
        });
        var r = n(21);
        n.d(e, "BaseSparqlParser", function() {
          return r.a;
        });
        var i = n(53);
        n.d(e, "W3SpecSparqlParser", function() {
          return i.a;
        });
        var o = n(36);
        n.d(e, "StardogSparqlParser", function() {
          return o.a;
        });
        var a = n(9), u = n(0).keywords, s = n(5).terminals;
      }, function(t, e, n) {
        "use strict";
        n.r(e), n.d(e, "graphQlTokenMap", function() {
          return I;
        }), n.d(e, "graphQlTokens", function() {
          return f;
        }), n.d(e, "stardogGraphQlTokenMap", function() {
          return D;
        }), n.d(e, "stardogGraphQlTokens", function() {
          return b;
        });
        var r = n(1), i = n(2), o = n(3), a = function() {
          return (a = Object.assign || function(t2) {
            for (var e2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
              for (var i2 in e2 = arguments[n2])
                Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
            return t2;
          }).apply(this, arguments);
        }, u = /\-?(?:0|[1-9][0-9]*)/, s = /[eE][+-]?[0-9]+/, c = i.a.and(/"/, i.a.many(i.a.or(/[\u0009\u0020\u0021\u0023-\u005B\u005D-\uFFFF]/, /\\u[0-9A-Fa-f]{4}/, /\\["\\/bfnrt]/)), /"/), l = /true|false/, E = /null/, p = /on/, f = [], L = function(t2) {
          var e2 = [T];
          return t2.pattern !== l && t2.pattern !== E && e2.push(U), t2.pattern !== p && e2.push(R), h({ name: t2.name, pattern: t2.pattern, longer_alt: T, categories: e2 });
        }, S = function(t2) {
          return h(a({}, t2, { categories: [O] }));
        }, h = function(t2) {
          var e2 = Object(r.createToken)(t2);
          return f.push(e2), e2;
        }, T = Object(r.createToken)({ name: "Name", pattern: /[_A-Za-z][_0-9A-Za-z]*/ }), U = Object(r.createToken)({ name: "EnumValueToken", pattern: r.Lexer.NA }), R = Object(r.createToken)({ name: "FragmentName", pattern: r.Lexer.NA }), d = Object(r.createToken)({ name: "StringValueToken", pattern: r.Lexer.NA }), O = Object(r.createToken)({ name: "Punctuator", pattern: r.Lexer.NA });
        T.CATEGORIES.push(U, R);
        var N = { WhiteSpace: h({ name: "WhiteSpace", pattern: /[ \t]+/, group: r.Lexer.SKIPPED }), UnicodeBOM: h({ name: "UnicodeBOM", pattern: "\\uFFFE", group: r.Lexer.SKIPPED }), LineTerminator: h({ name: "LineTerminator", pattern: /\n\r|\r|\n/, group: r.Lexer.SKIPPED }), Comment: h({ name: "Comment", pattern: /#[^\n\r]*/, group: r.Lexer.SKIPPED }), Comma: h({ name: "Comma", pattern: ",", group: r.Lexer.SKIPPED }) }, A = { Bang: S({ name: "Bang", pattern: "!" }), Dollar: S({ name: "Dollar", pattern: "$" }), LParen: S({ name: "LParen", pattern: "(" }), RParen: S({ name: "RParen", pattern: ")" }), Spread: S({ name: "Spread", pattern: "..." }), Colon: S({ name: "Colon", pattern: ":" }), Equals: S({ name: "Equals", pattern: "=" }), At: S({ name: "At", pattern: "@" }), LBracket: S({ name: "LBracket", pattern: "[" }), RBracket: S({ name: "RBracket", pattern: "]" }), LCurly: S({ name: "LCurly", pattern: "{" }), RCurly: S({ name: "RCurly", pattern: "}" }), Pipe: S({ name: "Pipe", pattern: "|" }), Amp: S({ name: "Amp", pattern: "&" }), Punctuator: O }, m = { FloatValueToken: h({ name: "FloatValueToken", pattern: i.a.and(u, i.a.or(i.a.and(/\.[0-9]+/, i.a.option(s)), s)) }), IntValueToken: h({ name: "IntValueToken", pattern: u }), BlockStringToken: h({ name: "BlockStringToken", pattern: o.STRING_LITERAL_LONG2, categories: [d] }), StringToken: h({ name: "StringToken", pattern: c, categories: [d] }), BooleanValueToken: h({ name: "BooleanValueToken", pattern: l, longer_alt: T }), NullValueToken: h({ name: "NullValueToken", pattern: E, longer_alt: T }), EnumValueToken: U, FragmentName: R, Name: T, StringValueToken: d }, C = { Query: L({ name: "Query", pattern: "query" }), Mutation: L({ name: "Mutation", pattern: "mutation" }), Subscription: L({ name: "Subscription", pattern: "subscription" }), Fragment: L({ name: "Fragment", pattern: "fragment" }), On: L({ name: "On", pattern: p }), Schema: L({ name: "Schema", pattern: "schema" }), Extend: L({ name: "Extend", pattern: "extend" }), Scalar: L({ name: "Scalar", pattern: "scalar" }), TypeToken: L({ name: "TypeToken", pattern: "type" }), Implements: L({ name: "Implements", pattern: "implements" }), Interface: L({ name: "Interface", pattern: "interface" }), Union: L({ name: "Union", pattern: "union" }), Enum: L({ name: "Enum", pattern: "enum" }), Input: L({ name: "Input", pattern: "input" }), DirectiveToken: L({ name: "DirectiveToken", pattern: "directive" }), QUERY: L({ name: "QUERY", pattern: "QUERY" }), MUTATION: L({ name: "MUTATION", pattern: "MUTATION" }), SUBSCRIPTION: L({ name: "SUBSCRIPTION", pattern: "SUBSCRIPTION" }), FRAGMENT_DEFINITION: L({ name: "FRAGMENT_DEFINITION", pattern: "FRAGMENT_DEFINITION" }), FRAGMENT_SPREAD: L({ name: "FRAGMENT_SPREAD", pattern: "FRAGMENT_SPREAD" }), INLINE_FRAGMENT: L({ name: "INLINE_FRAGMENT", pattern: "INLINE_FRAGMENT" }), SCHEMA: L({ name: "SCHEMA", pattern: "SCHEMA" }), SCALAR: L({ name: "SCALAR", pattern: "SCALAR" }), OBJECT: L({ name: "OBJECT", pattern: "OBJECT" }), FIELD_DEFINITION: L({ name: "FIELD_DEFINITION", pattern: "FIELD_DEFINITION" }), FIELD: L({ name: "FIELD", pattern: "FIELD" }), ARGUMENT_DEFINITION: L({ name: "ARGUMENT_DEFINITION", pattern: "ARGUMENT_DEFINITION" }), INTERFACE: L({ name: "INTERFACE", pattern: "INTERFACE" }), UNION: L({ name: "UNION", pattern: "UNION" }), ENUM_VALUE: L({ name: "ENUM_VALUE", pattern: "ENUM_VALUE" }), ENUM: L({ name: "ENUM", pattern: "ENUM" }), INPUT_OBJECT: L({ name: "INPUT_OBJECT", pattern: "INPUT_OBJECT" }), INPUT_FIELD_DEFINITION: L({ name: "INPUT_FIELD_DEFINITION", pattern: "INPUT_FIELD_DEFINITION" }) }, I = a({}, N, A, m, C, { Name: T }), y = Object(r.createToken)({ name: "StardogDirective", pattern: r.Lexer.NA }), _ = Object(r.createToken)({ name: "SparqlReceivingStardogDirective", pattern: r.Lexer.NA }), P = Object(r.createToken)({ name: "StardogArgument", pattern: r.Lexer.NA }), v = Object(r.createToken)({ name: "TopLevel", pattern: r.Lexer.NA }), M = ["optional", "bind", "hide", "skip", "include", "filter", "prefix", "config"].sort().reduce(function(t2, e2) {
          var n2, i2 = "" + e2[0].toUpperCase() + e2.slice(1) + "DirectiveToken", o2 = [T, U, R, y];
          ["prefix", "config"].includes(e2) && o2.push(v), ["bind", "skip", "include", "filter"].includes(e2) && o2.push(_);
          var u2 = Object(r.createToken)({ name: i2, pattern: e2, categories: o2, longer_alt: T });
          return a({}, t2, { tokenMap: a({}, t2.tokenMap, (n2 = {}, n2[i2] = u2, n2)), orderedTokens: t2.orderedTokens.concat(u2) });
        }, { tokenMap: {}, orderedTokens: [] }), g = ["orderBy", "first", "to", "if", "alias", "graph", "offset", "limit", "iri"].sort().reduce(function(t2, e2) {
          var n2, i2 = "" + e2[0].toUpperCase() + e2.slice(1) + "ArgumentToken", o2 = [T, U, R, P];
          ["orderBy", "first", "limit", "offset"].includes(e2) && o2.push(v);
          var u2 = Object(r.createToken)({ name: i2, pattern: e2, categories: o2, longer_alt: T });
          return a({}, t2, { tokenMap: a({}, t2.tokenMap, (n2 = {}, n2[i2] = u2, n2)), orderedTokens: t2.orderedTokens.concat(u2) });
        }, { tokenMap: {}, orderedTokens: [] }), B = Object(r.createToken)({ name: "OrderByArgumentFieldPropertyToken", pattern: "field", categories: [T, U, R], longer_alt: T }), k = Object(r.createToken)({ name: "OrderByArgumentDescPropertyToken", pattern: "desc", categories: [T, U, R], longer_alt: T }), D = a({}, I, M.tokenMap, g.tokenMap, { OrderByArgumentFieldPropertyToken: B, OrderByArgumentDescPropertyToken: k, StardogDirective: y, SparqlReceivingStardogDirective: _, StardogArgument: P, TopLevel: v }), b = f.concat(M.orderedTokens, g.orderedTokens, [B, k, y, _, P, v]), x = [R, U, T, d, O];
        f.push.apply(f, x), b.push.apply(b, x);
      }, function(t, e, n) {
        (function(t2, n2) {
          var r = 200, i = "__lodash_hash_undefined__", o = 1, a = 2, u = 9007199254740991, s = "[object Arguments]", c = "[object Array]", l = "[object AsyncFunction]", E = "[object Boolean]", p = "[object Date]", f = "[object Error]", L = "[object Function]", S = "[object GeneratorFunction]", h = "[object Map]", T = "[object Number]", U = "[object Null]", R = "[object Object]", d = "[object Proxy]", O = "[object RegExp]", N = "[object Set]", A = "[object String]", m = "[object Symbol]", C = "[object Undefined]", I = "[object ArrayBuffer]", y = "[object DataView]", _ = /^\[object .+?Constructor\]$/, P = /^(?:0|[1-9]\d*)$/, v = {};
          v["[object Float32Array]"] = v["[object Float64Array]"] = v["[object Int8Array]"] = v["[object Int16Array]"] = v["[object Int32Array]"] = v["[object Uint8Array]"] = v["[object Uint8ClampedArray]"] = v["[object Uint16Array]"] = v["[object Uint32Array]"] = true, v[s] = v[c] = v[I] = v[E] = v[y] = v[p] = v[f] = v[L] = v[h] = v[T] = v[R] = v[O] = v[N] = v[A] = v["[object WeakMap]"] = false;
          var M = "object" == typeof t2 && t2 && t2.Object === Object && t2, g = "object" == typeof self && self && self.Object === Object && self, B = M || g || Function("return this")(), k = e && !e.nodeType && e, D = k && "object" == typeof n2 && n2 && !n2.nodeType && n2, b = D && D.exports === k, x = b && M.process, F = function() {
            try {
              return x && x.binding && x.binding("util");
            } catch (t3) {
            }
          }(), G = F && F.isTypedArray;
          function w(t3, e2) {
            for (var n3 = -1, r2 = null == t3 ? 0 : t3.length; ++n3 < r2; )
              if (e2(t3[n3], n3, t3))
                return true;
            return false;
          }
          function j(t3) {
            var e2 = -1, n3 = Array(t3.size);
            return t3.forEach(function(t4, r2) {
              n3[++e2] = [r2, t4];
            }), n3;
          }
          function V(t3) {
            var e2 = -1, n3 = Array(t3.size);
            return t3.forEach(function(t4) {
              n3[++e2] = t4;
            }), n3;
          }
          var H, W, Y, K = Array.prototype, X = Function.prototype, q = Object.prototype, z = B["__core-js_shared__"], Q = X.toString, $ = q.hasOwnProperty, Z = (H = /[^.]+$/.exec(z && z.keys && z.keys.IE_PROTO || "")) ? "Symbol(src)_1." + H : "", J = q.toString, tt = RegExp("^" + Q.call($).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), et = b ? B.Buffer : void 0, nt = B.Symbol, rt = B.Uint8Array, it = q.propertyIsEnumerable, ot = K.splice, at = nt ? nt.toStringTag : void 0, ut = Object.getOwnPropertySymbols, st = et ? et.isBuffer : void 0, ct = (W = Object.keys, Y = Object, function(t3) {
            return W(Y(t3));
          }), lt = Ft(B, "DataView"), Et = Ft(B, "Map"), pt = Ft(B, "Promise"), ft = Ft(B, "Set"), Lt = Ft(B, "WeakMap"), St = Ft(Object, "create"), ht = Vt(lt), Tt = Vt(Et), Ut = Vt(pt), Rt = Vt(ft), dt = Vt(Lt), Ot = nt ? nt.prototype : void 0, Nt = Ot ? Ot.valueOf : void 0;
          function At(t3) {
            var e2 = -1, n3 = null == t3 ? 0 : t3.length;
            for (this.clear(); ++e2 < n3; ) {
              var r2 = t3[e2];
              this.set(r2[0], r2[1]);
            }
          }
          function mt(t3) {
            var e2 = -1, n3 = null == t3 ? 0 : t3.length;
            for (this.clear(); ++e2 < n3; ) {
              var r2 = t3[e2];
              this.set(r2[0], r2[1]);
            }
          }
          function Ct(t3) {
            var e2 = -1, n3 = null == t3 ? 0 : t3.length;
            for (this.clear(); ++e2 < n3; ) {
              var r2 = t3[e2];
              this.set(r2[0], r2[1]);
            }
          }
          function It(t3) {
            var e2 = -1, n3 = null == t3 ? 0 : t3.length;
            for (this.__data__ = new Ct(); ++e2 < n3; )
              this.add(t3[e2]);
          }
          function yt(t3) {
            var e2 = this.__data__ = new mt(t3);
            this.size = e2.size;
          }
          function _t(t3, e2) {
            var n3 = Yt(t3), r2 = !n3 && Wt(t3), i2 = !n3 && !r2 && Kt(t3), o2 = !n3 && !r2 && !i2 && $t(t3), a2 = n3 || r2 || i2 || o2, u2 = a2 ? function(t4, e3) {
              for (var n4 = -1, r3 = Array(t4); ++n4 < t4; )
                r3[n4] = e3(n4);
              return r3;
            }(t3.length, String) : [], s2 = u2.length;
            for (var c2 in t3)
              !e2 && !$.call(t3, c2) || a2 && ("length" == c2 || i2 && ("offset" == c2 || "parent" == c2) || o2 && ("buffer" == c2 || "byteLength" == c2 || "byteOffset" == c2) || jt(c2, s2)) || u2.push(c2);
            return u2;
          }
          function Pt(t3, e2) {
            for (var n3 = t3.length; n3--; )
              if (Ht(t3[n3][0], e2))
                return n3;
            return -1;
          }
          function vt(t3) {
            return null == t3 ? void 0 === t3 ? C : U : at && at in Object(t3) ? function(t4) {
              var e2 = $.call(t4, at), n3 = t4[at];
              try {
                t4[at] = void 0;
                var r2 = true;
              } catch (t5) {
              }
              var i2 = J.call(t4);
              r2 && (e2 ? t4[at] = n3 : delete t4[at]);
              return i2;
            }(t3) : function(t4) {
              return J.call(t4);
            }(t3);
          }
          function Mt(t3) {
            return Qt(t3) && vt(t3) == s;
          }
          function gt(t3, e2, n3, r2, i2) {
            return t3 === e2 || (null == t3 || null == e2 || !Qt(t3) && !Qt(e2) ? t3 != t3 && e2 != e2 : function(t4, e3, n4, r3, i3, u2) {
              var l2 = Yt(t4), L2 = Yt(e3), S2 = l2 ? c : wt(t4), U2 = L2 ? c : wt(e3), d2 = (S2 = S2 == s ? R : S2) == R, C2 = (U2 = U2 == s ? R : U2) == R, _2 = S2 == U2;
              if (_2 && Kt(t4)) {
                if (!Kt(e3))
                  return false;
                l2 = true, d2 = false;
              }
              if (_2 && !d2)
                return u2 || (u2 = new yt()), l2 || $t(t4) ? Dt(t4, e3, n4, r3, i3, u2) : function(t5, e4, n5, r4, i4, u3, s2) {
                  switch (n5) {
                    case y:
                      if (t5.byteLength != e4.byteLength || t5.byteOffset != e4.byteOffset)
                        return false;
                      t5 = t5.buffer, e4 = e4.buffer;
                    case I:
                      return !(t5.byteLength != e4.byteLength || !u3(new rt(t5), new rt(e4)));
                    case E:
                    case p:
                    case T:
                      return Ht(+t5, +e4);
                    case f:
                      return t5.name == e4.name && t5.message == e4.message;
                    case O:
                    case A:
                      return t5 == e4 + "";
                    case h:
                      var c2 = j;
                    case N:
                      var l3 = r4 & o;
                      if (c2 || (c2 = V), t5.size != e4.size && !l3)
                        return false;
                      var L3 = s2.get(t5);
                      if (L3)
                        return L3 == e4;
                      r4 |= a, s2.set(t5, e4);
                      var S3 = Dt(c2(t5), c2(e4), r4, i4, u3, s2);
                      return s2.delete(t5), S3;
                    case m:
                      if (Nt)
                        return Nt.call(t5) == Nt.call(e4);
                  }
                  return false;
                }(t4, e3, S2, n4, r3, i3, u2);
              if (!(n4 & o)) {
                var P2 = d2 && $.call(t4, "__wrapped__"), v2 = C2 && $.call(e3, "__wrapped__");
                if (P2 || v2) {
                  var M2 = P2 ? t4.value() : t4, g2 = v2 ? e3.value() : e3;
                  return u2 || (u2 = new yt()), i3(M2, g2, n4, r3, u2);
                }
              }
              if (!_2)
                return false;
              return u2 || (u2 = new yt()), function(t5, e4, n5, r4, i4, a2) {
                var u3 = n5 & o, s2 = bt(t5), c2 = s2.length, l3 = bt(e4).length;
                if (c2 != l3 && !u3)
                  return false;
                for (var E2 = c2; E2--; ) {
                  var p2 = s2[E2];
                  if (!(u3 ? p2 in e4 : $.call(e4, p2)))
                    return false;
                }
                var f2 = a2.get(t5);
                if (f2 && a2.get(e4))
                  return f2 == e4;
                var L3 = true;
                a2.set(t5, e4), a2.set(e4, t5);
                for (var S3 = u3; ++E2 < c2; ) {
                  p2 = s2[E2];
                  var h2 = t5[p2], T2 = e4[p2];
                  if (r4)
                    var U3 = u3 ? r4(T2, h2, p2, e4, t5, a2) : r4(h2, T2, p2, t5, e4, a2);
                  if (!(void 0 === U3 ? h2 === T2 || i4(h2, T2, n5, r4, a2) : U3)) {
                    L3 = false;
                    break;
                  }
                  S3 || (S3 = "constructor" == p2);
                }
                if (L3 && !S3) {
                  var R2 = t5.constructor, d3 = e4.constructor;
                  R2 != d3 && "constructor" in t5 && "constructor" in e4 && !("function" == typeof R2 && R2 instanceof R2 && "function" == typeof d3 && d3 instanceof d3) && (L3 = false);
                }
                return a2.delete(t5), a2.delete(e4), L3;
              }(t4, e3, n4, r3, i3, u2);
            }(t3, e2, n3, r2, gt, i2));
          }
          function Bt(t3) {
            return !(!zt(t3) || (e2 = t3, Z && Z in e2)) && (Xt(t3) ? tt : _).test(Vt(t3));
            var e2;
          }
          function kt(t3) {
            if (n3 = (e2 = t3) && e2.constructor, r2 = "function" == typeof n3 && n3.prototype || q, e2 !== r2)
              return ct(t3);
            var e2, n3, r2, i2 = [];
            for (var o2 in Object(t3))
              $.call(t3, o2) && "constructor" != o2 && i2.push(o2);
            return i2;
          }
          function Dt(t3, e2, n3, r2, i2, u2) {
            var s2 = n3 & o, c2 = t3.length, l2 = e2.length;
            if (c2 != l2 && !(s2 && l2 > c2))
              return false;
            var E2 = u2.get(t3);
            if (E2 && u2.get(e2))
              return E2 == e2;
            var p2 = -1, f2 = true, L2 = n3 & a ? new It() : void 0;
            for (u2.set(t3, e2), u2.set(e2, t3); ++p2 < c2; ) {
              var S2 = t3[p2], h2 = e2[p2];
              if (r2)
                var T2 = s2 ? r2(h2, S2, p2, e2, t3, u2) : r2(S2, h2, p2, t3, e2, u2);
              if (void 0 !== T2) {
                if (T2)
                  continue;
                f2 = false;
                break;
              }
              if (L2) {
                if (!w(e2, function(t4, e3) {
                  if (o2 = e3, !L2.has(o2) && (S2 === t4 || i2(S2, t4, n3, r2, u2)))
                    return L2.push(e3);
                  var o2;
                })) {
                  f2 = false;
                  break;
                }
              } else if (S2 !== h2 && !i2(S2, h2, n3, r2, u2)) {
                f2 = false;
                break;
              }
            }
            return u2.delete(t3), u2.delete(e2), f2;
          }
          function bt(t3) {
            return function(t4, e2, n3) {
              var r2 = e2(t4);
              return Yt(t4) ? r2 : function(t5, e3) {
                for (var n4 = -1, r3 = e3.length, i2 = t5.length; ++n4 < r3; )
                  t5[i2 + n4] = e3[n4];
                return t5;
              }(r2, n3(t4));
            }(t3, Zt, Gt);
          }
          function xt(t3, e2) {
            var n3, r2, i2 = t3.__data__;
            return ("string" == (r2 = typeof (n3 = e2)) || "number" == r2 || "symbol" == r2 || "boolean" == r2 ? "__proto__" !== n3 : null === n3) ? i2["string" == typeof e2 ? "string" : "hash"] : i2.map;
          }
          function Ft(t3, e2) {
            var n3 = function(t4, e3) {
              return null == t4 ? void 0 : t4[e3];
            }(t3, e2);
            return Bt(n3) ? n3 : void 0;
          }
          At.prototype.clear = function() {
            this.__data__ = St ? St(null) : {}, this.size = 0;
          }, At.prototype.delete = function(t3) {
            var e2 = this.has(t3) && delete this.__data__[t3];
            return this.size -= e2 ? 1 : 0, e2;
          }, At.prototype.get = function(t3) {
            var e2 = this.__data__;
            if (St) {
              var n3 = e2[t3];
              return n3 === i ? void 0 : n3;
            }
            return $.call(e2, t3) ? e2[t3] : void 0;
          }, At.prototype.has = function(t3) {
            var e2 = this.__data__;
            return St ? void 0 !== e2[t3] : $.call(e2, t3);
          }, At.prototype.set = function(t3, e2) {
            var n3 = this.__data__;
            return this.size += this.has(t3) ? 0 : 1, n3[t3] = St && void 0 === e2 ? i : e2, this;
          }, mt.prototype.clear = function() {
            this.__data__ = [], this.size = 0;
          }, mt.prototype.delete = function(t3) {
            var e2 = this.__data__, n3 = Pt(e2, t3);
            return !(n3 < 0 || (n3 == e2.length - 1 ? e2.pop() : ot.call(e2, n3, 1), --this.size, 0));
          }, mt.prototype.get = function(t3) {
            var e2 = this.__data__, n3 = Pt(e2, t3);
            return n3 < 0 ? void 0 : e2[n3][1];
          }, mt.prototype.has = function(t3) {
            return Pt(this.__data__, t3) > -1;
          }, mt.prototype.set = function(t3, e2) {
            var n3 = this.__data__, r2 = Pt(n3, t3);
            return r2 < 0 ? (++this.size, n3.push([t3, e2])) : n3[r2][1] = e2, this;
          }, Ct.prototype.clear = function() {
            this.size = 0, this.__data__ = { hash: new At(), map: new (Et || mt)(), string: new At() };
          }, Ct.prototype.delete = function(t3) {
            var e2 = xt(this, t3).delete(t3);
            return this.size -= e2 ? 1 : 0, e2;
          }, Ct.prototype.get = function(t3) {
            return xt(this, t3).get(t3);
          }, Ct.prototype.has = function(t3) {
            return xt(this, t3).has(t3);
          }, Ct.prototype.set = function(t3, e2) {
            var n3 = xt(this, t3), r2 = n3.size;
            return n3.set(t3, e2), this.size += n3.size == r2 ? 0 : 1, this;
          }, It.prototype.add = It.prototype.push = function(t3) {
            return this.__data__.set(t3, i), this;
          }, It.prototype.has = function(t3) {
            return this.__data__.has(t3);
          }, yt.prototype.clear = function() {
            this.__data__ = new mt(), this.size = 0;
          }, yt.prototype.delete = function(t3) {
            var e2 = this.__data__, n3 = e2.delete(t3);
            return this.size = e2.size, n3;
          }, yt.prototype.get = function(t3) {
            return this.__data__.get(t3);
          }, yt.prototype.has = function(t3) {
            return this.__data__.has(t3);
          }, yt.prototype.set = function(t3, e2) {
            var n3 = this.__data__;
            if (n3 instanceof mt) {
              var i2 = n3.__data__;
              if (!Et || i2.length < r - 1)
                return i2.push([t3, e2]), this.size = ++n3.size, this;
              n3 = this.__data__ = new Ct(i2);
            }
            return n3.set(t3, e2), this.size = n3.size, this;
          };
          var Gt = ut ? function(t3) {
            return null == t3 ? [] : (t3 = Object(t3), function(t4, e2) {
              for (var n3 = -1, r2 = null == t4 ? 0 : t4.length, i2 = 0, o2 = []; ++n3 < r2; ) {
                var a2 = t4[n3];
                e2(a2, n3, t4) && (o2[i2++] = a2);
              }
              return o2;
            }(ut(t3), function(e2) {
              return it.call(t3, e2);
            }));
          } : function() {
            return [];
          }, wt = vt;
          function jt(t3, e2) {
            return !!(e2 = null == e2 ? u : e2) && ("number" == typeof t3 || P.test(t3)) && t3 > -1 && t3 % 1 == 0 && t3 < e2;
          }
          function Vt(t3) {
            if (null != t3) {
              try {
                return Q.call(t3);
              } catch (t4) {
              }
              try {
                return t3 + "";
              } catch (t4) {
              }
            }
            return "";
          }
          function Ht(t3, e2) {
            return t3 === e2 || t3 != t3 && e2 != e2;
          }
          (lt && wt(new lt(new ArrayBuffer(1))) != y || Et && wt(new Et()) != h || pt && "[object Promise]" != wt(pt.resolve()) || ft && wt(new ft()) != N || Lt && "[object WeakMap]" != wt(new Lt())) && (wt = function(t3) {
            var e2 = vt(t3), n3 = e2 == R ? t3.constructor : void 0, r2 = n3 ? Vt(n3) : "";
            if (r2)
              switch (r2) {
                case ht:
                  return y;
                case Tt:
                  return h;
                case Ut:
                  return "[object Promise]";
                case Rt:
                  return N;
                case dt:
                  return "[object WeakMap]";
              }
            return e2;
          });
          var Wt = Mt(function() {
            return arguments;
          }()) ? Mt : function(t3) {
            return Qt(t3) && $.call(t3, "callee") && !it.call(t3, "callee");
          }, Yt = Array.isArray;
          var Kt = st || function() {
            return false;
          };
          function Xt(t3) {
            if (!zt(t3))
              return false;
            var e2 = vt(t3);
            return e2 == L || e2 == S || e2 == l || e2 == d;
          }
          function qt(t3) {
            return "number" == typeof t3 && t3 > -1 && t3 % 1 == 0 && t3 <= u;
          }
          function zt(t3) {
            var e2 = typeof t3;
            return null != t3 && ("object" == e2 || "function" == e2);
          }
          function Qt(t3) {
            return null != t3 && "object" == typeof t3;
          }
          var $t = G ? function(t3) {
            return function(e2) {
              return t3(e2);
            };
          }(G) : function(t3) {
            return Qt(t3) && qt(t3.length) && !!v[vt(t3)];
          };
          function Zt(t3) {
            return null != (e2 = t3) && qt(e2.length) && !Xt(e2) ? _t(t3) : kt(t3);
            var e2;
          }
          n2.exports = function(t3, e2) {
            return gt(t3, e2);
          };
        }).call(this, n(70), n(71)(t));
      }, function(t, e, n) {
        "use strict";
        n.r(e), n.d(e, "multiModeLexerDefinition", function() {
          return U;
        }), n.d(e, "srsTokenMap", function() {
          return R;
        }), n.d(e, "srsTokenTypes", function() {
          return d;
        });
        var r, i, o = n(1), a = n(3), u = n(27), s = u.turtleTokenTypes, c = u.turtleTokenMap, l = n(9).sparqlTokenMap;
        !function(t2) {
          t2.TURTLE = "turtle", t2.IFCLAUSE = "ifclause", t2.THENCLAUSE = "thenclause";
        }(i || (i = {}));
        var E = Object(o.createToken)({ name: "Rule", pattern: /rule/i }), p = Object(o.createToken)({ name: "If", pattern: /if/i, push_mode: i.IFCLAUSE }), f = Object(o.createToken)({ name: "Then", pattern: /then/i, push_mode: i.THENCLAUSE }), L = Object(o.createToken)({ name: "EndThen", pattern: "}", pop_mode: true }), S = Object(o.createToken)({ name: "GroupGraphPattern", pattern: function(t2, e2) {
          if (void 0 === e2 && (e2 = 0), "{" !== t2[e2])
            return null;
          var n2, r2 = 1;
          for (n2 = e2 + 1; n2 < t2.length && r2 > 0; n2++)
            "{" === t2[n2] ? r2++ : "}" === t2[n2] && r2--;
          return r2 > 0 ? null : a.CATCH_ALL_AT_LEAST_ONE.exec(t2.slice(e2, n2));
        }, line_breaks: true, pop_mode: true }), h = Object(o.createToken)({ name: "TriplesBlock", pattern: /[^{}]+/, line_breaks: true }), T = s.indexOf(c.IRIREF), U = { modes: (r = {}, r[i.TURTLE] = s.slice(0, T + 1).concat([E, p, f], s.slice(T + 1)), r[i.IFCLAUSE] = [c.WhiteSpace, S], r[i.THENCLAUSE] = [c.WhiteSpace, l.LCurly, L, h], r), defaultMode: i.TURTLE }, R = { Rule: E, If: p, Then: f, EndThen: L, GroupGraphPattern: S, TriplesBlock: h }, d = [E, p, f, L, l.LCurly].concat(s, [S, h]);
      }, function(t, e, n) {
        "use strict";
        n.d(e, "a", function() {
          return TrigParser;
        });
        var r, i = n(1), o = n(35), a = (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        }), u = n(61), s = u.trigTokenMap, c = u.trigTokenTypes, TrigParser = function(t2) {
          function TrigParser2(e2, n2, r2, o2) {
            void 0 === n2 && (n2 = c), void 0 === r2 && (r2 = c), void 0 === o2 && (o2 = true);
            var a2 = t2.call(this, e2, n2, r2, false) || this;
            return a2.parse = function(t3, e3) {
              void 0 === e3 && (e3 = "standard"), a2.input = a2.lexer.tokenize(t3).tokens;
              var n3 = a2.trigDoc(0, [e3]), r3 = a2.errors.slice(), i2 = a2.semanticErrors.slice();
              return a2.resetManagedState(), { errors: r3, semanticErrors: i2, cst: n3 };
            }, a2.trigDoc = a2.RULE("trigDoc", function(t3) {
              var e3 = "stardog" === t3;
              a2.MANY(function() {
                a2.OR([{ ALT: function() {
                  return a2.SUBRULE(a2.directive);
                } }, { ALT: function() {
                  return a2.SUBRULE(a2.block, { ARGS: [e3] });
                } }]);
              });
            }), a2.block = a2.RULE("block", function(t3) {
              a2.OR([{ ALT: function() {
                return a2.SUBRULE(a2.triplesOrGraph, { ARGS: [t3] });
              } }, { ALT: function() {
                return a2.SUBRULE(a2.wrappedGraph, { ARGS: [t3] });
              } }, { ALT: function() {
                return a2.SUBRULE(a2.triples2);
              } }, { ALT: function() {
                a2.CONSUME(s.GRAPH), a2.SUBRULE(a2.labelOrSubject), a2.SUBRULE1(a2.wrappedGraph, { ARGS: [t3] });
              } }]);
            }), a2.triplesOrGraph = a2.RULE("triplesOrGraph", function(t3) {
              var e3 = false;
              a2.OR([{ ALT: function() {
                return a2.SUBRULE(a2.labelOrSubject);
              } }, { GATE: function() {
                return Boolean(t3);
              }, ALT: function() {
                var t4 = a2.SUBRULE(a2.EmbeddedTriplePattern);
                e3 = "EmbeddedTriplePattern" === t4.name;
              } }]), a2.OR1([{ GATE: function() {
                return !e3;
              }, ALT: function() {
                return a2.SUBRULE(a2.wrappedGraph, { ARGS: [t3] });
              } }, { ALT: function() {
                a2.SUBRULE(a2.predicateObjectList), a2.CONSUME(s.Period);
              } }]);
            }), a2.triples2 = a2.RULE("triples2", function() {
              a2.OR([{ ALT: function() {
                a2.SUBRULE(a2.blankNodePropertyList), a2.OPTION(function() {
                  return a2.SUBRULE(a2.predicateObjectList);
                }), a2.CONSUME(s.Period);
              } }, { ALT: function() {
                a2.SUBRULE(a2.collection), a2.SUBRULE1(a2.predicateObjectList), a2.CONSUME1(s.Period);
              } }]);
            }), a2.wrappedGraph = a2.RULE("wrappedGraph", function(t3) {
              a2.CONSUME(s.LCurly), a2.OPTION(function() {
                return a2.SUBRULE(a2.triplesBlock, { ARGS: [t3] });
              }), a2.CONSUME(s.RCurly);
            }), a2.triplesBlock = a2.RULE("triplesBlock", function(t3) {
              a2.SUBRULE(a2.triples, { ARGS: [t3] }), a2.OPTION(function() {
                a2.CONSUME(s.Period), a2.OPTION1(function() {
                  return a2.SUBRULE(a2.triplesBlock, { ARGS: [t3] });
                });
              });
            }), a2.labelOrSubject = a2.RULE("labelOrSubject", function() {
              a2.OR([{ ALT: function() {
                return a2.SUBRULE(a2.iri);
              } }, { ALT: function() {
                return a2.SUBRULE(a2.BlankNode);
              } }]);
            }), o2 && i.Parser.performSelfAnalysis(a2), a2;
          }
          return a(TrigParser2, t2), TrigParser2;
        }(o.a);
      }, function(t, e, n) {
        "use strict";
        n.r(e), n.d(e, "trigTokenMap", function() {
          return u;
        }), n.d(e, "trigTokenTypes", function() {
          return c;
        });
        var r = n(27), i = n(9), o = function() {
          return (o = Object.assign || function(t2) {
            for (var e2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
              for (var i2 in e2 = arguments[n2])
                Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
            return t2;
          }).apply(this, arguments);
        }, a = n(27).turtleTokenTypes, u = o({ GRAPH: i.sparqlTokenMap.GRAPH }, r.turtleTokenMap), s = a.indexOf(r.turtleTokenMap.PN_CHARS_BASE), c = a.slice(0, s).concat([i.sparqlTokenMap.GRAPH], a.slice(s));
      }, function(t, e, n) {
        "use strict";
        n.d(e, "a", function() {
          return SmsParser;
        });
        var r, i = n(1), o = n(56), a = (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        }), u = function() {
          return (u = Object.assign || function(t2) {
            for (var e2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
              for (var i2 in e2 = arguments[n2])
                Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
            return t2;
          }).apply(this, arguments);
        }, s = n(63), c = s.smsTokenTypes, l = s.smsTokenMap, SmsParser = function(t2) {
          function SmsParser2(e2) {
            var n2 = t2.call(this, u({ outputCst: true, recoveryEnabled: true }, e2), c, true) || this;
            return n2.parse = function(t3) {
              n2.input = n2.tokenize(t3);
              var e3 = n2.MappingDoc();
              return { errors: n2.errors, cst: e3 };
            }, n2.MappingDoc = n2.RULE("MappingDoc", function() {
              n2.MANY(function() {
                return n2.SUBRULE(n2.PrefixDecl);
              }), n2.OPTION(function() {
                n2.SUBRULE(n2.MappingClause), n2.MANY1(function() {
                  n2.CONSUME(l.Semicolon), n2.SUBRULE1(n2.MappingClause);
                });
              });
            }), n2.MappingClause = n2.RULE("MappingClause", function() {
              n2.SUBRULE(n2.MappingDecl), n2.SUBRULE(n2.FromClause), n2.SUBRULE(n2.ToClause), n2.SUBRULE(n2.WhereClause);
            }), n2.MappingDecl = n2.RULE("MappingDecl", function() {
              n2.CONSUME(l.Mapping), n2.OPTION(function() {
                return n2.SUBRULE(n2.iri);
              });
            }), n2.FromClause = n2.RULE("FromClause", function() {
              n2.CONSUME(l.FROM), n2.OR([{ ALT: function() {
                return n2.SUBRULE(n2.SqlClause);
              } }, { ALT: function() {
                return n2.SUBRULE(n2.JsonClause);
              } }, { ALT: function() {
                return n2.SUBRULE(n2.GraphQlClause);
              } }, { ALT: function() {
                return n2.SUBRULE(n2.CsvClause);
              } }]);
            }), n2.JsonClause = n2.RULE("JsonClause", function() {
              n2.CONSUME(l.Json), n2.CONSUME(l.JsonBlock);
            }), n2.GraphQlClause = n2.RULE("GraphQlClause", function() {
              n2.CONSUME(l.GraphQl), n2.CONSUME(l.LCurly), n2.CONSUME(l.GraphQlBlock), n2.CONSUME(l.RCurly);
            }), n2.SqlClause = n2.RULE("SqlClause", function() {
              n2.CONSUME(l.Sql), n2.CONSUME(l.LCurly), n2.CONSUME(l.SqlBlock), n2.CONSUME(l.RCurly);
            }), n2.CsvClause = n2.RULE("CsvClause", function() {
              n2.CONSUME(l.Csv), n2.OPTION(function() {
                n2.CONSUME(l.LCurly), n2.CONSUME(l.RCurly);
              });
            }), n2.ToClause = n2.RULE("ToClause", function() {
              n2.CONSUME(l.TO), n2.SUBRULE(n2.ConstructTemplate);
            }), n2.WhereClause = n2.OVERRIDE_RULE("WhereClause", function() {
              n2.CONSUME(l.WHERE), n2.CONSUME(l.LCurly), n2.MANY(function() {
                return n2.SUBRULE(n2.Bind);
              }), n2.CONSUME(l.RCurly);
            }), n2.Bind = n2.OVERRIDE_RULE("Bind", function() {
              n2.CONSUME(l.BIND), n2.CONSUME(l.LParen), n2.SUBRULE(n2.BindExpression), n2.CONSUME(l.AS), n2.SUBRULE(n2.Var), n2.CONSUME(l.RParen);
            }), n2.BindExpression = n2.RULE("BindExpression", function() {
              n2.OR([{ ALT: function() {
                return n2.SUBRULE(n2.TemplateFunc);
              } }, { ALT: function() {
                return n2.SUBRULE(n2.Expression);
              } }]);
            }), n2.TemplateFunc = n2.RULE("TemplateFunc", function() {
              n2.CONSUME(l.Template), n2.CONSUME(l.LParen), n2.SUBRULE(n2.String), n2.CONSUME(l.RParen);
            }), n2.Object = n2.OVERRIDE_RULE("Object", function() {
              n2.SUBRULE(n2.GraphNode);
            }), i.Parser.performSelfAnalysis(n2), n2;
          }
          return a(SmsParser2, t2), SmsParser2;
        }(o.StardogSparqlParser);
      }, function(t, e, n) {
        "use strict";
        n.r(e), n.d(e, "smsTokenMap", function() {
          return p;
        }), n.d(e, "smsTokenTypes", function() {
          return f;
        });
        var r = n(1), i = n(0), o = function() {
          return (o = Object.assign || function(t2) {
            for (var e2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
              for (var i2 in e2 = arguments[n2])
                Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
            return t2;
          }).apply(this, arguments);
        }, a = n(9), u = a.sparqlTokenMap, s = a.stardogSparqlTokens, c = /^\s*to\s*{/i, l = /((?:.|\s)*?)to\s*{/i, E = function(t2, e2, n2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            if (t2[r2] !== e2)
              ;
            else {
              var i2 = t2.slice(r2 + 1);
              if (n2.exec(i2))
                return [t2.slice(0, r2)];
            }
          return null;
        }, p = o({}, u, { Template: Object(i.createKeyword)({ name: "Template" }), Sql: Object(i.createKeyword)({ name: "Sql" }), GraphQl: Object(i.createKeyword)({ name: "GraphQl" }), Json: Object(i.createKeyword)({ name: "Json" }), Csv: Object(i.createKeyword)({ name: "Csv" }), Mapping: Object(i.createKeyword)({ name: "Mapping" }), SqlBlock: Object(r.createToken)({ name: "SqlBlock", pattern: function(t2, e2, n2) {
          void 0 === e2 && (e2 = 0);
          var r2 = n2.slice(-2), i2 = r2[0], o2 = r2[1];
          if (!i2 || !o2 || i2.tokenType.tokenName !== p.Sql.tokenName || o2.tokenType.tokenName !== p.LCurly.tokenName)
            return null;
          var a2 = t2.slice(e2);
          return E(a2, "}", c);
        }, line_breaks: true }), JsonBlock: Object(r.createToken)({ name: "JsonBlock", pattern: function(t2, e2, n2) {
          void 0 === e2 && (e2 = 0);
          var r2 = n2.slice(-1)[0];
          if (!r2 || r2.tokenType.tokenName !== p.Json.tokenName)
            return null;
          var i2 = t2.slice(e2), o2 = l.exec(i2);
          return o2 ? o2.slice(1) : null;
        }, line_breaks: true }), GraphQlBlock: Object(r.createToken)({ name: "GraphQlBlock", pattern: function(t2, e2, n2) {
          void 0 === e2 && (e2 = 0);
          var r2 = n2.slice(-2), i2 = r2[0], o2 = r2[1];
          if (!i2 || !o2 || i2.tokenType.tokenName !== p.GraphQl.tokenName || o2.tokenType.tokenName !== p.LCurly.tokenName)
            return null;
          var a2 = t2.slice(e2);
          return E(a2, "}", c);
        }, line_breaks: true }) }), f = [p.Template, p.Sql, p.GraphQl, p.Json, p.Csv, p.Mapping, p.SqlBlock, p.JsonBlock, p.GraphQlBlock].concat(s);
      }, function(t, e, n) {
        "use strict";
        n.d(e, "a", function() {
          return StandardGraphQlParser;
        });
        var r, i = n(54), o = n(1), a = (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        }), u = n(57).graphQlTokens, StandardGraphQlParser = function(t2) {
          function StandardGraphQlParser2(e2) {
            var n2 = t2.call(this, e2, u) || this;
            return o.Parser.performSelfAnalysis(n2), n2;
          }
          return a(StandardGraphQlParser2, t2), StandardGraphQlParser2;
        }(i.a);
      }, function(t, e, n) {
        "use strict";
        var r, i = n(1), TurtleParser2 = n(35), o = n(12), a = function() {
          return (a = Object.assign || function(t2) {
            for (var e2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
              for (var i2 in e2 = arguments[n2])
                Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
            return t2;
          }).apply(this, arguments);
        }, u = Object.freeze(["", "rdf", "rdfs", "xsd", "owl", "stardog"].reduce(function(t2, e2) {
          var n2;
          return a({}, t2, ((n2 = {})[e2] = true, n2));
        }, {})), s = n(56), c = (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        }), l = function(t2) {
          return new (function(t3) {
            function e2() {
              var e3 = t3.call(this) || this;
              return e3.groupGraphPatterns = [], e3.triplesBlocks = [], e3.IfClause = function(t4, n2) {
                var r2 = t4.GroupGraphPattern;
                e3.$storePlaceholderTokenReplacement({ tokenStore: e3.groupGraphPatterns, originalTokenContext: r2, subParserRule: e3.sparqlParser.parseGroupGraphPattern.bind(e3.sparqlParser), cstInputTokens: n2 });
              }, e3.ThenClause = function(t4, n2) {
                var r2 = t4.TriplesBlock;
                e3.$storePlaceholderTokenReplacement({ tokenStore: e3.triplesBlocks, originalTokenContext: r2, subParserRule: e3.sparqlParser.parseTriplesBlock.bind(e3.sparqlParser), cstInputTokens: n2 });
              }, e3.$storePlaceholderTokenReplacement = function(t4) {
                var n2 = t4.tokenStore, r2 = t4.originalTokenContext, i2 = void 0 === r2 ? [] : r2, o2 = t4.subParserRule, a2 = t4.cstInputTokens, u2 = t4.stripWrappers, s2 = i2[0];
                if (s2 && "string" == typeof s2.image) {
                  var c2 = e3.$getPlaceholderTokenReplacement(s2, o2, a2, u2);
                  n2.push({ parseResult: c2, originalToken: s2 });
                }
              }, e3.$getPlaceholderTokenReplacement = function(t4, e4, n2, r2) {
                void 0 === r2 && (r2 = false);
                for (var i2 = t4.image, o2 = "", a2 = 0, u2 = 0, s2 = 0; s2 < n2.length; s2++) {
                  var c2 = n2[s2];
                  if (s2 > 0) {
                    var l2 = c2.startLine - u2, E2 = c2.startOffset - 1 - a2 - l2;
                    l2 > 0 ? (o2 += "\n".repeat(l2 - 1), o2 += " ".repeat(Math.max(E2, 0)) + "\n") : o2 += " ".repeat(Math.max(E2, 0));
                  }
                  if (c2 === t4)
                    break;
                  c2.image.split("\n").forEach(function(t5, e5) {
                    e5 > 0 && (o2 += "\n"), o2 += " ".repeat(t5.length);
                  }), a2 = c2.endOffset, u2 = c2.endLine;
                }
                var p2 = r2 ? " " + i2.slice(1, -1) + " " : i2;
                return e4("" + o2 + p2);
              }, e3.$getGroupGraphPatterns = function() {
                return e3.groupGraphPatterns;
              }, e3.$getTriplesBlocks = function() {
                return e3.triplesBlocks;
              }, e3.$resetState = function() {
                e3.groupGraphPatterns = [], e3.triplesBlocks = [];
              }, e3.sparqlParser = new s.StardogSparqlParser(), e3.validateVisitor(), e3;
            }
            return c(e2, t3), e2;
          }(t2))();
        };
        function E(t2, e2) {
          return t2.concat(e2.parseResult.errors);
        }
        function p(t2, e2, n2, r2) {
          var i2 = n2.find(function(e3) {
            return e3.originalToken === t2;
          });
          return i2 && (e2.children[r2] = [i2.parseResult.cst]), i2;
        }
        var f, L = n(9), S = /(?:[A-Z]+Expression|ValueLogical)$/i, h = function() {
          return false;
        }, T = ((f = {})[L.sparqlTokenMap.EXISTS.tokenName] = "ExistsFunction", f[L.sparqlTokenMap.NOT_EXISTS.tokenName] = "NotExistsFunction", f[L.sparqlTokenMap.NOW.tokenName] = "BuiltInCall_NOW", f[L.sparqlTokenMap.LEmbed.tokenName] = "LeftEmbed", f[L.sparqlTokenMap.REmbed.tokenName] = "RightEmbed", f), U = Object.keys(T), R = [L.sparqlTokenMap.DOUBLE, L.sparqlTokenMap.DECIMAL, L.sparqlTokenMap.INTEGER, L.sparqlTokenMap.DOUBLE_POSITIVE, L.sparqlTokenMap.DECIMAL_POSITIVE, L.sparqlTokenMap.INTEGER_POSITIVE, L.sparqlTokenMap.DOUBLE_NEGATIVE, L.sparqlTokenMap.DECIMAL_NEGATIVE, L.sparqlTokenMap.INTEGER_NEGATIVE, L.sparqlTokenMap.STRING_LITERAL1, L.sparqlTokenMap.STRING_LITERAL2, L.sparqlTokenMap.STRING_LITERAL_LONG1, L.sparqlTokenMap.STRING_LITERAL_LONG2].map(function(t2) {
          return t2.tokenName;
        }), d = function(t2) {
          return Boolean(t2 && t2.node);
        };
        function O(t2, e2, n2, r2, i2) {
          if (void 0 === i2 && (i2 = h), !t2)
            return [];
          for (var a2 = [], u2 = t2; Object(o.b)(u2.node) && !n2.includes(u2.node.name); ) {
            if (i2(u2))
              return [];
            u2 = u2.parentCtx;
          }
          for (; Object(o.b)(u2.node); ) {
            if (a2.unshift(u2.node.name), i2(u2))
              return [];
            u2 = u2.parentCtx;
          }
          for ("string" == typeof r2 && a2.unshift(r2), u2 = e2; u2; ) {
            if (Object(o.b)(u2.node) && (a2.unshift(u2.node.name), i2(u2)))
              return [];
            u2 = u2.parentCtx;
          }
          return ["SrsDoc"].concat(a2);
        }
        var N = function(t2) {
          return { name: t2.name, message: t2.message, token: t2.node, context: { ruleStack: t2.ruleStack, ruleOccurrenceStack: [] }, resyncedTokens: [] };
        }, A = function(t2, e2, n2, r2) {
          return N({ name: "NoNamespacePrefixError", message: 'A prefix ("' + t2.image + '") was used for which there was no namespace defined.', node: t2, ruleStack: O(e2, n2, ["PrefixedName"], r2) });
        }, m = function(t2, e2, n2, r2) {
          return void 0 === r2 && (r2 = "GroupGraphPattern"), N({ name: "DisallowedTokenError", message: "Token " + t2.tokenType.tokenName + " cannot be used in Stardog Rules.", node: t2, ruleStack: O(e2, n2, [T[t2.tokenType.tokenName]], r2) });
        }, C = function(t2, e2, n2, r2) {
          var i2 = null, o2 = false, a2 = null, u2 = O(e2, n2, ["Expression", "TriplesSameSubjectPath"], r2, function(t3) {
            var e3 = t3.node, n3 = t3.parentCtx, r3 = e3.name;
            if ("PropertyListPathNotEmpty" === r3)
              return i2 = t3, false;
            if (!o2 && S.test(r3))
              return o2 = n3.node.children[r3].length > 1, false;
            var u3 = "Expression" === r3, s2 = "TriplesSameSubjectPath" === r3;
            if (!u3 && !s2)
              return false;
            var c2 = u3 && !o2 && function(t4) {
              if (!d(t4))
                return false;
              var e4 = t4.node.name;
              return "Bind" === e4 || "ExpressionOrEmbeddedTriplePattern" === e4 && d(t4.parentCtx) && "Bind" === t4.parentCtx.node.name;
            }(n3), l2 = s2 && (!i2 || "TriplesSameSubjectPath" !== i2.parentCtx.node.name);
            return !c2 && !l2 || (a2 = c2 ? "Bind" : "TriplesBlock", false);
          });
          if (0 !== u2.length)
            return N({ name: "DisallowedLiteralError", message: "Token " + t2.tokenType.tokenName + " (" + t2.image + ") cannot be used as a subject inside of a " + a2 + " in Stardog Rules Syntax.", node: t2, ruleStack: u2 });
        };
        n.d(e, "a", function() {
          return B;
        });
        var I = function() {
          var t2 = function(e2, n2) {
            return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
              t3.__proto__ = e3;
            } || function(t3, e3) {
              for (var n3 in e3)
                e3.hasOwnProperty(n3) && (t3[n3] = e3[n3]);
            })(e2, n2);
          };
          return function(e2, n2) {
            function r2() {
              this.constructor = e2;
            }
            t2(e2, n2), e2.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
          };
        }(), y = function() {
          return (y = Object.assign || function(t2) {
            for (var e2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
              for (var i2 in e2 = arguments[n2])
                Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
            return t2;
          }).apply(this, arguments);
        }, _ = n(9).sparqlTokenMap, P = n(59), v = P.srsTokenMap, M = P.srsTokenTypes, g = P.multiModeLexerDefinition, B = function(t2) {
          function SrsParser(e2) {
            var n2 = t2.call(this, y({ outputCst: true, recoveryEnabled: true }, e2), M, g, false) || this;
            return n2.baseNamespacesMap = Object.freeze(y({}, u)), n2.namespacesMap = {}, n2.visitCst = function(t3) {
              if (n2.sparqlSrsVisitor)
                n2.sparqlSrsVisitor.$resetState();
              else {
                var e3 = n2.getBaseCstVisitorConstructorWithDefaults();
                n2.sparqlSrsVisitor = l(e3);
              }
              n2.sparqlSrsVisitor.visit(t3, n2.input);
            }, n2.getSparqlRulesFromVisitor = function(t3) {
              return n2.visitCst(t3), { groupGraphPatterns: n2.sparqlSrsVisitor.$getGroupGraphPatterns(), triplesBlocks: n2.sparqlSrsVisitor.$getTriplesBlocks() };
            }, n2.resetManagedState = function() {
              n2.namespacesMap = y({}, u), n2.semanticErrors = [];
            }, n2.setBaseNamespaces = function(t3) {
              n2.baseNamespacesMap = y({}, t3);
            }, n2.tokenize = function(t3) {
              return n2.lexer.tokenize(t3).tokens;
            }, n2.parse = function(t3, e3) {
              void 0 === e3 && (e3 = "standard"), n2.resetManagedState(), n2.input = n2.lexer.tokenize(t3).tokens;
              var r2 = n2.SrsDoc(0, [e3]), i2 = n2.getSparqlRulesFromVisitor(r2), a2 = i2.groupGraphPatterns, u2 = i2.triplesBlocks, s2 = n2.errors.concat(a2.reduce(E, []), u2.reduce(E, [])), c2 = n2.semanticErrors.slice();
              return Object(o.e)(r2, function(t4, e4) {
                var r3 = t4.node, i3 = t4.parentCtx;
                if (Object(o.b)(r3))
                  return e4();
                var l2 = r3.tokenType.tokenName;
                if ("GroupGraphPattern" === l2 || "TriplesBlock" === l2) {
                  var E2 = i3.node;
                  if ("IfClause" === E2.name)
                    (f2 = p(r3, E2, a2, "GroupGraphPattern")) && function(t5) {
                      var e5 = t5.cst, n3 = t5.namespacesMap, r4 = t5.fullCtx, i4 = t5.errors, a3 = t5.semanticErrors;
                      Object(o.d)(e5, function(t6, e6) {
                        var u3 = t6.node, s3 = t6.parentCtx;
                        if (Object(o.b)(u3))
                          return e6();
                        var c3 = u3.tokenType.tokenName;
                        if (U.some(function(t7) {
                          return t7 === c3;
                        }) && i4.push(m(u3, s3, r4)), R.some(function(t7) {
                          return t7 === u3.tokenType.tokenName;
                        })) {
                          var l3 = C(u3, s3, r4, "GroupGraphPattern");
                          l3 && i4.push(l3);
                        }
                        if ("PNAME_NS" === c3 || "PNAME_LN" === c3) {
                          var E3 = u3.image.split(":").shift();
                          n3[E3] || a3.push(A(u3, s3, r4, "GroupGraphPattern"));
                        }
                      });
                    }({ fullCtx: t4, namespacesMap: y({}, n2.baseNamespacesMap, n2.namespacesMap), cst: f2.parseResult.cst, errors: s2, semanticErrors: c2 });
                  else if ("ThenClause" === E2.name) {
                    var f2;
                    (f2 = p(r3, E2, u2, "TriplesBlock")) && function(t5) {
                      var e5 = t5.cst, n3 = t5.namespacesMap, r4 = t5.errors, i4 = t5.semanticErrors, a3 = t5.fullCtx;
                      Object(o.d)(e5, function(t6, e6) {
                        var u3 = t6.node, s3 = t6.parentCtx;
                        if (Object(o.b)(u3))
                          return e6();
                        var c3 = u3.tokenType.tokenName;
                        if (R.some(function(t7) {
                          return t7 === u3.tokenType.tokenName;
                        })) {
                          var l3 = C(u3, s3, a3, "GroupGraphPattern");
                          l3 && r4.push(l3);
                        }
                        if (c3 !== L.sparqlTokenMap.LEmbed.name && c3 !== L.sparqlTokenMap.REmbed.name || r4.push(m(u3, s3, a3, "TriplesBlock")), "PNAME_NS" === c3 || "PNAME_LN" === c3) {
                          var E3 = u3.image.split(":").shift();
                          n3[E3] || i4.push(A(u3, s3, a3, "TriplesBlock"));
                        }
                      });
                    }({ fullCtx: t4, namespacesMap: y({}, n2.baseNamespacesMap, n2.namespacesMap), cst: f2.parseResult.cst, errors: s2, semanticErrors: c2 });
                  }
                }
              }), { semanticErrors: c2, errors: s2, cst: r2 };
            }, n2.SrsDoc = n2.RULE("SrsDoc", function(t3) {
              var e3 = "stardog" === t3;
              n2.SUBRULE(n2.turtleDoc, { ARGS: [t3] }), n2.MANY(function() {
                n2.SUBRULE(n2.RuleDoc), n2.MANY1(function() {
                  n2.SUBRULE(n2.triples, { ARGS: [e3] }), n2.CONSUME(_.Period);
                });
              });
            }), n2.RuleDoc = n2.RULE("RuleDoc", function() {
              n2.OPTION(function() {
                return n2.SUBRULE(n2.RuleClause);
              }), n2.SUBRULE(n2.IfClause), n2.SUBRULE(n2.ThenClause);
            }), n2.RuleClause = n2.RULE("RuleClause", function() {
              n2.CONSUME(v.Rule), n2.SUBRULE(n2.iri);
            }), n2.IfClause = n2.RULE("IfClause", function() {
              n2.CONSUME(v.If), n2.CONSUME(v.GroupGraphPattern);
            }), n2.ThenClause = n2.RULE("ThenClause", function() {
              n2.CONSUME(v.Then), n2.CONSUME(_.LCurly), n2.CONSUME(v.TriplesBlock), n2.CONSUME(v.EndThen);
            }), n2.lexer = new i.Lexer(g), i.Parser.performSelfAnalysis(n2), n2;
          }
          return I(SrsParser, t2), SrsParser;
        }(TurtleParser2.a);
      }, function(t, e, n) {
        "use strict";
        var r, TurtleParser2 = n(35), i = n(1), o = n(69), a = n.n(o), u = n(12), s = (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        }), c = function(t2) {
          return new RegExp("(?:shacl#|" + a()(t2) + ":)(\\S+?)>?$");
        }, l = function(t2) {
          for (var e2 = t2; e2.children; ) {
            var n2 = Object.keys(e2.children)[0];
            e2 = e2.children[n2][0];
          }
          return e2;
        }, E = function(t2, e2) {
          var n2 = e2.exec(t2);
          if (n2)
            return n2[1];
        }, p = function(t2, e2) {
          e2.forEach(function(e3) {
            var n2 = e3.children[Object.keys(e3.children)[0]][0];
            switch (n2.name) {
              case "shaclVerbShape":
                var r2 = l(n2).image.toLowerCase();
                if (!("a" === r2 || "rdf:type" === r2 || "<http://www.w3.org/1999/02/22-rdf-syntax-ns#type>" === r2))
                  return;
                Object.keys(n2.children).forEach(function(e4) {
                  if ("shaclShapeType" === e4) {
                    var r3 = n2.children[e4][0];
                    r3.children.SHACL_NodeShape ? t2.types.push({ type: "NodeShape", token: l(r3) }) : r3.children.SHACL_PropertyShape && t2.types.push({ type: "PropertyShape", token: l(r3) });
                  }
                });
                break;
              case "shaclPredicateIRI":
                n2.children.SingleIriTakingPredicate ? t2.predicates.push({ type: "SingleIriTakingPredicate", token: l(n2.children.SingleIriTakingPredicate[0]) }) : n2.children.ManyIriTakingPredicate && t2.predicates.push({ type: "ManyIriTakingPredicate", token: l(n2.children.ManyIriTakingPredicate[0]) });
                break;
              case "shaclNodeKind":
                t2.predicates.push({ type: "nodeKind", token: n2.children.SHACL_nodeKind[0] });
                break;
              case "shaclTargetNode":
                t2.predicates.push({ type: "targetNode", token: n2.children.SHACL_targetNode[0] });
                break;
              case "shaclPropertyPath":
                t2.predicates.push({ type: "path", token: n2.children.SHACL_path[0] });
                break;
              case "shaclLiteralConstraint":
                t2.predicates.push({ type: "LiteralConstraint", token: l(n2) });
                break;
              case "shaclListTakingConstraint":
                t2.predicates.push({ type: "ListTakingConstraint", token: l(n2) });
                break;
              case "shaclShapeExpectingConstraint":
                t2.predicates.push({ type: "ShapeExpectingPredicate", token: n2.children.ShapeExpectingPredicate[0] });
                break;
              case "shaclHasValueConstraint":
                t2.predicates.push({ type: "hasValue", token: n2.children.SHACL_hasValue[0] });
                break;
              default:
                console.log("SHACL predicateObjectList with name " + n2.name + " not recognized.");
            }
          });
        }, f = function(t2) {
          var e2 = t2.blankNodePropertyList[0], n2 = e2.children.predicateObjectList[0], r2 = t2.predicateObjectList ? t2.predicateObjectList[0] : null;
          if (Object(u.b)(n2) || Object(u.b)(r2)) {
            var i2 = r2 && r2.children && r2.children.shaclRulePredicateObjectList ? (n2.children.shaclRulePredicateObjectList || []).concat(r2.children.shaclRulePredicateObjectList) : n2.children.shaclRulePredicateObjectList;
            if (i2) {
              var o2 = { subject: { type: "blankNodePropertyList", token: l(e2) }, types: [], predicates: [] };
              return p(o2, i2), o2;
            }
          }
        }, L = function(t2) {
          return new (function(t3) {
            function e2() {
              var e3 = t3.call(this) || this;
              return e3.triples = function(t4) {
                if (t4.subject) {
                  var n2 = t4.predicateObjectList[0];
                  if (!Object(u.b)(n2))
                    return;
                  var r2 = n2.children.shaclRulePredicateObjectList;
                  if (!r2)
                    return;
                  var i2 = { subject: { type: "collection" === Object.keys(t4.subject[0].children)[0] ? "collection" : "subject", token: l(t4.subject[0]) }, types: [], predicates: [] };
                  p(i2, r2), e3.shapes.push(i2), e3.visit(t4.subject), e3.visit(n2);
                } else {
                  if (!(i2 = f(t4)))
                    return;
                  e3.shapes.push(i2), e3.visit(t4.blankNodePropertyList), t4.predicateObjectList && e3.visit(t4.predicateObjectList);
                }
              }, e3.shaclShape = function(t4) {
                if (t4.blankNodePropertyList) {
                  var n2 = f(t4);
                  n2 && (e3.shapes.push(n2), e3.visit(t4.blankNodePropertyList));
                }
              }, e3.$resetState = function() {
                e3.shapes = [];
              }, e3.$validateShapes = function(t4) {
                var n2 = t4.shacl, r2 = [], i2 = c(n2), o2 = 0, a2 = e3.shapes.reduce(function(t5, e4) {
                  var n3 = e4.subject.token.image, r3 = "[" === n3 ? "bnode" + ++o2 : n3;
                  if (t5[r3]) {
                    var i3 = t5[r3];
                    t5[r3] = { subjects: i3.subjects.concat([e4.subject]), types: i3.types.concat(e4.types), predicates: i3.predicates.concat(e4.predicates) };
                  } else
                    t5[r3] = { subjects: [e4.subject], types: e4.types, predicates: e4.predicates };
                  return t5;
                }, {});
                return Object.keys(a2).forEach(function(t5) {
                  var e4, o3 = a2[t5], u2 = o3.subjects, s2 = o3.types, c2 = o3.predicates;
                  s2.forEach(function(t6) {
                    var n3 = t6.type;
                    e4 && n3 !== e4 ? r2.push({ name: "ShapeTypeError", message: "A SHACL shape can be at most one of NodeShape or PropertyShape.", token: u2[0].token }) : e4 || (e4 = n3);
                  });
                  var l2 = [], p2 = {};
                  c2.forEach(function(t6) {
                    var e5 = t6.token.image, r3 = E(e5, i2), o4 = r3 ? n2 + ":" + r3 : e5;
                    o4 === n2 + ":path" ? l2.push(t6) : (p2[o4] || (p2[o4] = []), p2[o4].push(t6));
                  }), l2.length > 0 && ("NodeShape" === e4 ? r2.push({ name: "ShapePropertyError", message: "SHACL instances of `NodeShape` cannot have a value for the `path` property.", token: l2[0].token }) : e4 = "PropertyShape", l2.length > 1 && r2.push({ name: "ShapePropertyError", message: "A shape can have at most one value for sh:path.", token: l2[1].token })), "NodeShape" === e4 ? ["minCount", "maxCount", "uniqueLang", "lessThan", "lessThanOrEquals", "qualifiedValueShape"].forEach(function(t6) {
                    var e5 = n2 + ":" + t6;
                    p2[e5] && r2.push({ name: "ShapePropertyError", message: "A NodeShape cannot have any value for " + e5 + ".", token: p2[e5][0].token });
                  }) : ["deactivated", "severity", "datatype", "nodeKind", "minCount", "maxCount", "minExclusive", "minInclusive", "maxExclusive", "maxInclusive", "minLength", "maxLength", "languageIn", "uniqueLang", "in"].forEach(function(t6) {
                    var e5 = n2 + ":" + t6;
                    p2[e5] && p2[e5].length > 1 && r2.push({ name: "ShapePropertyError", message: "A shape can have at most one value for " + e5 + ".", token: p2[e5][1].token });
                  });
                }), { validationErrors: r2 };
              }, e3.validateVisitor(), e3.shapes = [], e3;
            }
            return s(e2, t3), e2;
          }(t2))();
        };
        n.d(e, "a", function() {
          return N;
        });
        var S = function() {
          var t2 = function(e2, n2) {
            return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
              t3.__proto__ = e3;
            } || function(t3, e3) {
              for (var n3 in e3)
                e3.hasOwnProperty(n3) && (t3[n3] = e3[n3]);
            })(e2, n2);
          };
          return function(e2, n2) {
            function r2() {
              this.constructor = e2;
            }
            t2(e2, n2), e2.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
          };
        }(), h = function() {
          return (h = Object.assign || function(t2) {
            for (var e2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
              for (var i2 in e2 = arguments[n2])
                Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
            return t2;
          }).apply(this, arguments);
        }, T = n(67), U = T.getShaclTokenTypes, R = T.getShaclTokenMap, d = T.categoryTokenMap, O = n(27).turtleTokenMap, N = function(t2) {
          function e2(e3, n2) {
            void 0 === n2 && (n2 = { shacl: "sh", xsd: "xsd" });
            var r2 = t2.call(this, h({ outputCst: true, recoveryEnabled: true }, e3), U(n2), U(n2), false) || this;
            return r2.validateWithVisitor = function(t3) {
              if (r2.shaclVisitor)
                r2.shaclVisitor.$resetState();
              else {
                var e4 = r2.getBaseCstVisitorConstructorWithDefaults();
                r2.shaclVisitor = L(e4);
              }
              return r2.shaclVisitor.visit(t3), r2.shaclVisitor.$validateShapes(r2.prefixes);
            }, r2.tokenize = function(t3) {
              return r2.lexer.tokenize(t3).tokens;
            }, r2.parse = function(t3) {
              r2.input = r2.tokenize(t3);
              var e4 = r2.turtleDoc(), n3 = r2.validateWithVisitor(e4).validationErrors;
              return { errors: r2.errors.slice(), semanticErrors: r2.semanticErrors.concat(n3), cst: e4 };
            }, r2.predicateObjectList = r2.OVERRIDE_RULE("predicateObjectList", function() {
              r2.OR([{ ALT: function() {
                r2.SUBRULE(r2.shaclRulePredicateObjectList);
              } }, { ALT: function() {
                r2.SUBRULE(r2.verb), r2.SUBRULE(r2.objectList);
              } }]), r2.MANY(function() {
                r2.CONSUME(O.Semicolon), r2.OPTION(function() {
                  r2.OR1([{ ALT: function() {
                    r2.SUBRULE1(r2.shaclRulePredicateObjectList);
                  } }, { ALT: function() {
                    r2.SUBRULE1(r2.verb), r2.SUBRULE1(r2.objectList);
                  } }]);
                });
              });
            }), r2.shaclRulePredicateObjectList = r2.RULE("shaclRulePredicateObjectList", function() {
              r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.shaclPredicateIRI);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclNodeKind);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclTargetNode);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclPropertyPath);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclLiteralConstraint);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclListTakingConstraint);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclShapeExpectingConstraint);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclHasValueConstraint);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclVerbShape);
              } }]);
            }), r2.shaclPredicateIRI = r2.RULE("shaclPredicateIRI", function() {
              r2.OR([{ ALT: function() {
                r2.CONSUME(d.SingleIriTakingPredicate), r2.SUBRULE(r2.iri);
              } }, { ALT: function() {
                r2.CONSUME(d.ManyIriTakingPredicate), r2.SUBRULE1(r2.iri), r2.MANY(function() {
                  r2.CONSUME(O.Comma), r2.SUBRULE2(r2.iri);
                });
              } }]);
            }), r2.shaclNodeKind = r2.RULE("shaclNodeKind", function() {
              r2.CONSUME(r2.shaclTokenMap.SHACL_nodeKind), r2.CONSUME(d.NodeKindIRI);
            }), r2.shaclTargetNode = r2.RULE("shaclTargetNode", function() {
              r2.CONSUME(r2.shaclTokenMap.SHACL_targetNode), r2.SUBRULE(r2.shaclIRIOrLiteral), r2.MANY(function() {
                r2.CONSUME(O.Comma), r2.SUBRULE1(r2.shaclIRIOrLiteral);
              });
            }), r2.shaclVerbShape = r2.RULE("shaclVerbShape", function() {
              r2.SUBRULE(r2.verb), r2.SUBRULE(r2.shaclShapeType), r2.MANY(function() {
                r2.CONSUME(O.Comma), r2.SUBRULE1(r2.shaclShapeType);
              });
            }), r2.shaclShapeType = r2.RULE("shaclShapeType", function() {
              r2.OR([{ ALT: function() {
                return r2.CONSUME(r2.shaclTokenMap.SHACL_Shape);
              } }, { ALT: function() {
                return r2.CONSUME(r2.shaclTokenMap.SHACL_NodeShape);
              } }, { ALT: function() {
                return r2.CONSUME(r2.shaclTokenMap.SHACL_PropertyShape);
              } }]);
            }), r2.shaclPropertyPath = r2.RULE("shaclPropertyPath", function() {
              r2.CONSUME(r2.shaclTokenMap.SHACL_path), r2.SUBRULE(r2.shaclPropertyPathPath);
            }), r2.shaclPropertyPathPath = r2.RULE("shaclPropertyPathPath", function() {
              r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.shaclPredicatePath);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclSequencePath);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclAlternativePath);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclInversePath);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclZeroOrMorePath);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclOneOrMorePath);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclZeroOrOnePath);
              } }]);
            }), r2.shaclPredicatePath = r2.RULE("shaclPredicatePath", function() {
              r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.iri);
              } }, { ALT: function() {
                r2.CONSUME(O.LParen), r2.SUBRULE1(r2.iri), r2.CONSUME(O.RParen);
              } }]);
            }), r2.shaclSequencePath = r2.RULE("shaclSequencePath", function() {
              r2.CONSUME(O.LParen), r2.SUBRULE(r2.shaclPropertyPathPath), r2.AT_LEAST_ONE(function() {
                return r2.SUBRULE1(r2.shaclPropertyPathPath);
              }), r2.OPTION(function() {
                return r2.CONSUME(O.Semicolon);
              }), r2.CONSUME(O.RParen);
            }), r2.shaclAlternativePath = r2.RULE("shaclAlternativePath", function() {
              r2.CONSUME(O.LBracket), r2.CONSUME(r2.shaclTokenMap.SHACL_alternativePath), r2.SUBRULE(r2.shaclPropertyPathPath), r2.OPTION(function() {
                return r2.CONSUME(O.Semicolon);
              }), r2.CONSUME(O.RBracket);
            }), r2.shaclInversePath = r2.RULE("shaclInversePath", function() {
              r2.CONSUME(O.LBracket), r2.CONSUME(r2.shaclTokenMap.SHACL_inversePath), r2.SUBRULE(r2.shaclPropertyPathPath), r2.OPTION(function() {
                return r2.CONSUME(O.Semicolon);
              }), r2.CONSUME(O.RBracket);
            }), r2.shaclZeroOrMorePath = r2.RULE("shaclZeroOrMorePath", function() {
              r2.CONSUME(O.LBracket), r2.CONSUME(r2.shaclTokenMap.SHACL_zeroOrMorePath), r2.SUBRULE(r2.shaclPropertyPathPath), r2.OPTION(function() {
                return r2.CONSUME(O.Semicolon);
              }), r2.CONSUME(O.RBracket);
            }), r2.shaclOneOrMorePath = r2.RULE("shaclOneOrMorePath", function() {
              r2.CONSUME(O.LBracket), r2.CONSUME(r2.shaclTokenMap.SHACL_oneOrMorePath), r2.SUBRULE(r2.shaclPropertyPathPath), r2.OPTION(function() {
                return r2.CONSUME(O.Semicolon);
              }), r2.CONSUME(O.RBracket);
            }), r2.shaclZeroOrOnePath = r2.RULE("shaclZeroOrOnePath", function() {
              r2.CONSUME(O.LBracket), r2.CONSUME(r2.shaclTokenMap.SHACL_zeroOrOnePath), r2.SUBRULE(r2.shaclPropertyPathPath), r2.OPTION(function() {
                return r2.CONSUME(O.Semicolon);
              }), r2.CONSUME(O.RBracket);
            }), r2.shaclLiteralConstraint = r2.RULE("shaclLiteralConstraint", function() {
              r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.shaclIntConstraint);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclStringConstraint);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclStringLiteralQuoteConstraint);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclLangStringConstraint);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclBooleanConstraint);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclAnyLiteralConstraint);
              } }]);
            }), r2.shaclIntConstraint = r2.RULE("shaclIntConstraint", function() {
              r2.CONSUME(d.IntTakingPredicate), r2.OR([{ ALT: function() {
                return r2.CONSUME(O.INTEGER);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclXsdInteger);
              } }]);
            }), r2.shaclStringConstraint = r2.RULE("shaclStringConstraint", function() {
              r2.OR([{ ALT: function() {
                return r2.CONSUME(r2.shaclTokenMap.SHACL_select);
              } }, { ALT: function() {
                return r2.CONSUME(r2.shaclTokenMap.SHACL_ask);
              } }]), r2.SUBRULE(r2.String);
            }), r2.shaclStringLiteralQuoteConstraint = r2.RULE("shaclStringLiteralQuoteConstraint", function() {
              r2.CONSUME(d.StringLiteralQuoteTakingPredicate), r2.CONSUME(O.STRING_LITERAL_QUOTE), r2.OPTION(function() {
                r2.OR([{ ALT: function() {
                  return r2.CONSUME(O.LANGTAG);
                } }, { ALT: function() {
                  r2.CONSUME(O.DoubleCaret), r2.CONSUME(r2.shaclTokenMap.SHACL_xsd_string);
                } }, { ALT: function() {
                  r2.CONSUME1(O.DoubleCaret), r2.CONSUME(r2.shaclTokenMap.SHACL_xsd_anyURI);
                } }]);
              });
            }), r2.shaclLangStringConstraint = r2.RULE("shaclLangStringConstraint", function() {
              r2.CONSUME(d.LangStringTakingPredicate), r2.SUBRULE(r2.String), r2.OPTION(function() {
                r2.OR([{ ALT: function() {
                  return r2.CONSUME(O.LANGTAG);
                } }, { ALT: function() {
                  r2.CONSUME(O.DoubleCaret), r2.CONSUME(r2.shaclTokenMap.SHACL_xsd_string);
                } }]);
              });
            }), r2.shaclBooleanConstraint = r2.RULE("shaclBooleanConstraint", function() {
              r2.CONSUME(d.BooleanTakingPredicate), r2.OR([{ ALT: function() {
                return r2.CONSUME(O.TRUE);
              } }, { ALT: function() {
                return r2.CONSUME(O.FALSE);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclXsdBoolean);
              } }]);
            }), r2.shaclAnyLiteralConstraint = r2.RULE("shaclAnyLiteralConstraint", function() {
              r2.CONSUME(d.AnyLiteralTakingPredicate), r2.SUBRULE(r2.literal);
            }), r2.shaclListTakingConstraint = r2.RULE("shaclListTakingConstraint", function() {
              r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.shaclLanguageInConstraint);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclShapeListTakingConstraint);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclIRIListTakingConstraint);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.shaclShapeOrLiteralListTakingConstraint);
              } }]);
            }), r2.shaclLanguageInConstraint = r2.RULE("shaclLanguageInConstraint", function() {
              r2.CONSUME(r2.shaclTokenMap.SHACL_languageIn), r2.SUBRULE(r2.shaclStringCollection);
            }), r2.shaclStringCollection = r2.RULE("shaclStringCollection", function() {
              r2.CONSUME(O.LParen), r2.MANY(function() {
                r2.CONSUME(O.STRING_LITERAL_QUOTE);
              }), r2.CONSUME(O.RParen);
            }), r2.shaclShapeListTakingConstraint = r2.RULE("shaclShapeListTakingConstraint", function() {
              r2.OR([{ ALT: function() {
                return r2.CONSUME(r2.shaclTokenMap.SHACL_and);
              } }, { ALT: function() {
                return r2.CONSUME(r2.shaclTokenMap.SHACL_or);
              } }, { ALT: function() {
                return r2.CONSUME(r2.shaclTokenMap.SHACL_xone);
              } }]), r2.SUBRULE(r2.shaclShapeCollection);
            }), r2.shaclShapeCollection = r2.RULE("shaclShapeCollection", function() {
              r2.CONSUME(O.LParen), r2.MANY(function() {
                r2.SUBRULE(r2.shaclShape);
              }), r2.CONSUME(O.RParen);
            }), r2.shaclIRIListTakingConstraint = r2.RULE("shaclIRIListTakingConstraint", function() {
              r2.CONSUME(r2.shaclTokenMap.SHACL_ignoredProperties), r2.SUBRULE(r2.shaclIRICollection);
            }), r2.shaclIRICollection = r2.RULE("shaclIRICollection", function() {
              r2.CONSUME(O.LParen), r2.MANY(function() {
                r2.SUBRULE(r2.iri);
              }), r2.CONSUME(O.RParen);
            }), r2.shaclShapeOrLiteralListTakingConstraint = r2.RULE("shaclShapeOrLiteralListTakingConstraint", function() {
              r2.CONSUME(r2.shaclTokenMap.SHACL_in), r2.SUBRULE(r2.shaclShapeOrLiteralCollection);
            }), r2.shaclShapeOrLiteralCollection = r2.RULE("shaclShapeOrLiteralCollection", function() {
              r2.CONSUME(O.LParen), r2.MANY(function() {
                r2.SUBRULE(r2.shaclShapeOrLiteral);
              }), r2.CONSUME(O.RParen);
            }), r2.shaclShapeExpectingConstraint = r2.RULE("shaclShapeExpectingConstraint", function() {
              r2.CONSUME(d.ShapeExpectingPredicate), r2.SUBRULE(r2.shaclShape);
            }), r2.shaclHasValueConstraint = r2.RULE("shaclHasValueConstraint", function() {
              r2.CONSUME(r2.shaclTokenMap.SHACL_hasValue), r2.SUBRULE(r2.shaclShapeOrLiteral);
            }), r2.shaclShape = r2.RULE("shaclShape", function() {
              r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.iri);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.blankNodePropertyList);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.BlankNode);
              } }]);
            }), r2.shaclShapeOrLiteral = r2.RULE("shaclShapeOrLiteral", function() {
              r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.shaclShape);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.literal);
              } }]);
            }), r2.shaclIRIOrLiteral = r2.RULE("shaclIRIOrLiteral", function() {
              r2.OR([{ ALT: function() {
                return r2.SUBRULE(r2.iri);
              } }, { ALT: function() {
                return r2.SUBRULE(r2.literal);
              } }]);
            }), r2.shaclXsdBoolean = r2.RULE("shaclXsdBoolean", function() {
              r2.SUBRULE(r2.shaclStringWithDoubleCaret), r2.CONSUME(r2.shaclTokenMap.SHACL_xsd_boolean);
            }), r2.shaclXsdString = r2.RULE("shaclXsdString", function() {
              r2.SUBRULE(r2.shaclStringWithDoubleCaret), r2.CONSUME(r2.shaclTokenMap.SHACL_xsd_string);
            }), r2.shaclXsdInteger = r2.RULE("shaclXsdInteger", function() {
              r2.SUBRULE(r2.shaclStringWithDoubleCaret), r2.CONSUME(r2.shaclTokenMap.SHACL_xsd_integer);
            }), r2.shaclXsdDate = r2.RULE("shaclXsdDate", function() {
              r2.SUBRULE(r2.shaclStringWithDoubleCaret), r2.CONSUME(r2.shaclTokenMap.SHACL_xsd_date);
            }), r2.shaclXsdAnyURI = r2.RULE("shaclXsdAnyURI", function() {
              r2.SUBRULE(r2.shaclStringWithDoubleCaret), r2.CONSUME(r2.shaclTokenMap.SHACL_xsd_anyURI);
            }), r2.shaclStringWithDoubleCaret = r2.RULE("shaclStringWithDoubleCaret", function() {
              r2.SUBRULE(r2.String), r2.CONSUME(O.DoubleCaret);
            }), r2.prefixes = n2, r2.lexer = new i.Lexer(U(n2)), r2.shaclTokenMap = R(n2), i.Parser.performSelfAnalysis(r2), r2;
          }
          return S(e2, t2), e2;
        }(TurtleParser2.a);
      }, function(t, e, n) {
        "use strict";
        n.r(e);
        var r = n(1), i = function(t2, e2) {
          return t2.length === e2.length && t2.every(function(t3, n2) {
            return r2 = t3, i2 = e2[n2], r2 === i2;
            var r2, i2;
          });
        };
        var o = function(t2, e2) {
          var n2;
          void 0 === e2 && (e2 = i);
          var r2, o2 = [], a2 = false;
          return function() {
            for (var i2 = arguments.length, u2 = new Array(i2), s2 = 0; s2 < i2; s2++)
              u2[s2] = arguments[s2];
            return a2 && n2 === this && e2(u2, o2) ? r2 : (r2 = t2.apply(this, u2), a2 = true, n2 = this, o2 = u2, r2);
          };
        }, a = n(26), u = n(58), s = n.n(u);
        n.d(e, "categoryTokenMap", function() {
          return L;
        }), n.d(e, "categoryTokens", function() {
          return S;
        }), n.d(e, "getShaclTokenMap", function() {
          return A;
        }), n.d(e, "getShaclTokenTypes", function() {
          return y;
        });
        var c = function() {
          return (c = Object.assign || function(t2) {
            for (var e2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
              for (var i2 in e2 = arguments[n2])
                Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
            return t2;
          }).apply(this, arguments);
        }, l = n(27), E = l.turtleTokenTypes, p = l.turtleTokenMap, f = n(9).sparqlTokenMap, L = { ManyIriTakingPredicate: Object(r.createToken)({ name: "ManyIriTakingPredicate", pattern: r.Lexer.NA }), SingleIriTakingPredicate: Object(r.createToken)({ name: "SingleIriTakingPredicate", pattern: r.Lexer.NA }), NodeKindIRI: Object(r.createToken)({ name: "NodeKindIRI", pattern: r.Lexer.NA }), IntTakingPredicate: Object(r.createToken)({ name: "IntTakingPredicate", pattern: r.Lexer.NA }), StringLiteralQuoteTakingPredicate: Object(r.createToken)({ name: "StringLiteralQuoteTakingPredicate", pattern: r.Lexer.NA }), LangStringTakingPredicate: Object(r.createToken)({ name: "LangStringTakingPredicate", pattern: r.Lexer.NA }), BooleanTakingPredicate: Object(r.createToken)({ name: "BooleanTakingPredicate", pattern: r.Lexer.NA }), ShapeExpectingPredicate: Object(r.createToken)({ name: "ShapeExpectingPredicate", pattern: r.Lexer.NA }), AnyLiteralTakingPredicate: Object(r.createToken)({ name: "AnyLiteralTakingPredicate", pattern: r.Lexer.NA }) }, S = Object.keys(L).map(function(t2) {
          return L[t2];
        }), h = { ManyIriTakingPredicate: Object(a.d)("equals", "disjoint", "lessThan", "lessThanOrEquals", "targetClass", "targetSubjectsOf", "targetObjectsOf"), SingleIriTakingPredicate: Object(a.d)("class", "datatype", "severity"), NodeKindIRI: Object(a.d)("IRI", "BlankNode", "Literal", "BlankNodeOrIRI", "BlankNodeOrLiteral", "IRIOrLiteral"), IntTakingPredicate: Object(a.d)("minCount", "maxCount", "minLength", "maxLength", "qualifiedMinCount", "qualifiedMaxCount"), StringLiteralQuoteTakingPredicate: Object(a.d)("pattern", "flags", "prefix", "namespace"), LangStringTakingPredicate: Object(a.d)("message", "labelTemplate"), BooleanTakingPredicate: Object(a.d)("uniqueLang", "qualifiedValueShapesDisjoint", "closed", "deactivated", "optional"), ShapeExpectingPredicate: Object(a.d)("not", "node", "property", "qualifiedValueShape", "sparql", "declare", "prefixes", "parameter", "nodeValidator", "propertyValidator", "validator"), AnyLiteralTakingPredicate: Object(a.d)("minExclusive", "minInclusive", "maxExclusive", "maxInclusive"), other: Object(a.d)("Shape", "NodeShape", "PropertyShape", "targetNode", "message", "path", "alternativePath", "inversePath", "zeroOrMorePath", "oneOrMorePath", "zeroOrOnePath", "nodeKind", "languageIn", "and", "or", "xone", "ignoredProperties", "hasValue", "in", "select", "ask") }, T = Object(a.d)("boolean", "integer", "string", "date", "dateTime", "anyURI"), U = Object.keys(h).reduce(function(t2, e2) {
          return h[e2].forEach(function(n2) {
            return t2[n2] = e2;
          }), t2;
        }, {}), R = Object.keys(U), d = T.reduce(function(t2, e2) {
          var n2, i2 = "SHACL_xsd_" + e2, o2 = i2 + "_IRI", a2 = Object(r.createToken)({ name: i2, pattern: r.Lexer.NA });
          return c({}, t2, ((n2 = {})[i2] = a2, n2[o2] = Object(r.createToken)({ name: o2, pattern: "<http://www.w3.org/2001/XMLSchema#" + e2, categories: [a2, p.IRIREF] }), n2));
        }, {}), O = R.reduce(function(t2, e2) {
          var n2, i2 = U[e2], o2 = L[i2], a2 = "SHACL_" + e2, u2 = a2 + "_IRI", s2 = Object(r.createToken)({ name: a2, pattern: r.Lexer.NA, categories: o2 ? [o2] : [] });
          return c({}, t2, ((n2 = {})[a2] = s2, n2[u2] = Object(r.createToken)({ name: u2, pattern: "<http://www.w3.org/ns/shacl#" + e2 + ">", categories: [s2, p.IRIREF] }), n2));
        }, d), N = function(t2) {
          return function(e2) {
            return t2 + ":" + e2;
          };
        }, A = o(function(t2) {
          var e2 = N(t2.shacl), n2 = N(t2.xsd), i2 = R.reduce(function(t3, n3) {
            var i3, o2 = "SHACL_" + n3, a2 = o2 + "_prefixed";
            return c({}, t3, ((i3 = {})[a2] = Object(r.createToken)({ name: a2, pattern: e2(n3), categories: [t3[o2], p.PNAME_LN] }), i3));
          }, O);
          return T.reduce(function(t3, e3) {
            var i3, o2 = "SHACL_xsd_" + e3, a2 = o2 + "_prefixed";
            return c({}, t3, ((i3 = {})[a2] = Object(r.createToken)({ name: a2, pattern: "" + n2(e3), categories: [t3[o2], p.PNAME_LN] }), i3));
          }, i2);
        }, s.a), m = E.indexOf(f.PNAME_NS), C = E.indexOf(p.IRIREF), I = function(t2, e2) {
          var n2 = t2.split("_"), r2 = (n2[0], n2[1]), i2 = n2.slice(2), o2 = e2.split("_"), a2 = (o2[0], o2[1]), u2 = o2.slice(2), s2 = ("xsd" === r2 ? i2[0] : r2).toLowerCase(), c2 = ("xsd" === a2 ? u2[0] : a2).toLowerCase();
          if (s2 === c2) {
            var l2 = "xsd" === r2 ? i2[1] : i2[0], E2 = "xsd" === a2 ? u2[1] : u2[0];
            return l2 && E2 ? 0 : l2 ? 1 : -1;
          }
          return s2 < c2 ? 1 : c2 < s2 ? -1 : 0;
        }, y = o(function(t2) {
          var e2 = A(t2), n2 = Object.keys(e2).sort(I).reduce(function(t3, n3) {
            return n3.endsWith("_IRI") ? (C < m && t3.iriTokens.push(e2[n3.slice(0, -4)]), t3.iriTokens.push(e2[n3])) : n3.endsWith("_prefixed") && (m < C && t3.pnameTokens.push(e2[n3.slice(0, -9)]), t3.pnameTokens.push(e2[n3])), t3;
          }, { pnameTokens: [], iriTokens: [] }), r2 = n2.pnameTokens, i2 = n2.iriTokens;
          return m < C ? E.slice(0, m).concat(S, r2, E.slice(m, C), i2, E.slice(C)) : E.slice(0, C).concat(S, i2, E.slice(C, m), r2, E.slice(m));
        }, s.a);
      }, function(t, e, n) {
        "use strict";
        var r, BaseGraphQlParser = n(54), StardogSparqlParser = n(36), i = n(12), o = n(55), a = (r = function(t2, e2) {
          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
          })(t2, e2);
        }, function(t2, e2) {
          function n2() {
            this.constructor = t2;
          }
          r(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (n2.prototype = e2.prototype, new n2());
        }), u = function() {
          return (u = Object.assign || function(t2) {
            for (var e2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
              for (var i2 in e2 = arguments[n2])
                Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
            return t2;
          }).apply(this, arguments);
        }, s = o.a.getArgumentNodes, c = o.a.getArgumentTokenTypesForDirectiveNameToken, l = o.a.isSparqlReceivingStardogDirective;
        function E(t2) {
          var e2 = t2.allowedArgumentTokenTypes, n2 = t2.directiveImage, r2 = t2.errorAccumulator, i2 = t2.numMinimumArguments, o2 = t2.suppliedArgumentNodes.length, a2 = e2.length, u2 = "valid arguments: " + e2.map(function(t3) {
            return "`" + t3.PATTERN + "`";
          }).join(", ");
          if (o2 < i2) {
            var s2 = "requires " + i2 + " argument" + (i2 > 1 ? "s" : "");
            r2.stardogGraphQlErrors.push({ name: "ArgumentArityError", message: "The " + n2 + " directive " + s2 + " (" + u2 + ")" });
          } else
            o2 > a2 && r2.stardogGraphQlErrors.push({ name: "ArgumentArityError", message: "Too many arguments provided to " + n2 + " directive (" + u2 + ")" });
        }
        function p(t2) {
          var e2 = t2.allowedArgumentTokenTypes, n2 = t2.directiveImage, r2 = t2.errorAccumulator, o2 = t2.sparqlParser, a2 = t2.suppliedArgumentNodes, s2 = "valid arguments: " + e2.map(function(t3) {
            return "`" + t3.PATTERN + "`";
          }).join(", ");
          a2.forEach(function(t3) {
            var a3, c2 = Object(i.a)(["Alias", "Name"], t3);
            if (Object(i.c)(c2)) {
              var l2, E2, p2, f2 = c2.tokenType.name;
              if (e2.some(function(t4) {
                return t4.name === f2;
              })) {
                var L2 = Object(i.a)(["Value", "StringValue", "StringValueToken"], t3);
                if (!Object(i.c)(L2))
                  return;
                var S2 = (l2 = L2, E2 = o2, p2 = l2.image.slice(1, -1), E2.parse(p2, E2.Expression)).errors;
                S2.length > 0 && (a3 = r2.sparqlErrors).push.apply(a3, function(t4, e3, n3) {
                  void 0 === n3 && (n3 = 0);
                  var r3 = e3.startOffset, i2 = e3.endOffset, o3 = e3.startColumn, a4 = e3.endColumn;
                  return t4.map(function(t5) {
                    var s3 = t5.token, c3 = s3.startOffset, l3 = s3.endOffset, E3 = s3.startColumn, p3 = s3.endColumn;
                    return u({}, t5, { token: u({}, s3, { startOffset: r3 + (c3 || 0) + n3, endOffset: i2 + (l3 || 0) + n3, startColumn: o3 + (E3 || 0) + n3, endColumn: a4 + (p3 || 0) + n3, startLine: e3.startLine, endLine: e3.endLine }) });
                  });
                }(S2, L2, 1));
              } else
                r2.stardogGraphQlErrors.push({ name: "InvalidArgumentError", message: "Invalid argument `" + c2.image + "` for " + n2 + " directive (" + s2 + ")" });
            }
          });
        }
        var f = function(t2, e2) {
          var n2 = new StardogSparqlParser.a();
          return new (function(t3) {
            function r2() {
              var r3 = t3.call(this) || this;
              return r3.sparqlErrors = [], r3.stardogGraphQlErrors = [], r3.visit = function() {
                for (var e3 = [], n3 = 0; n3 < arguments.length; n3++)
                  e3[n3] = arguments[n3];
                return t3.prototype.visit.apply(r3, e3), { sparqlErrors: r3.sparqlErrors, stardogGraphQlErrors: r3.stardogGraphQlErrors };
              }, r3.Directive = function(t4) {
                var i2, o2;
                if (t4.Name && t4.Name[0]) {
                  var a2 = t4.Name[0];
                  if (l(a2)) {
                    var f2 = function(t5, e3, n3) {
                      var r4, i3, o3 = { stardogGraphQlErrors: [], sparqlErrors: [] }, a3 = c(e3), u2 = e3.tokenType.PATTERN;
                      return i3 = (r4 = { validatorOptions: { allowedArgumentTokenTypes: a3, directiveImage: u2, errorAccumulator: o3, numMinimumArguments: 1, sparqlParser: n3, suppliedArgumentNodes: t5 }, validators: [E, p] }).validatorOptions, r4.validators.forEach(function(t6) {
                        return t6(i3);
                      }), o3;
                    }(s(t4), a2, n2);
                    if (f2.stardogGraphQlErrors.length > 0) {
                      var L2 = e2.getHumanReadableRuleStack(), S2 = e2.RULE_OCCURRENCE_STACK;
                      (i2 = r3.stardogGraphQlErrors).push.apply(i2, f2.stardogGraphQlErrors.map(function(t5) {
                        return u({}, t5, { token: a2, context: { ruleStack: L2, ruleOccurrenceStack: S2 }, resyncedTokens: [] });
                      }));
                    }
                    (o2 = r3.sparqlErrors).push.apply(o2, f2.sparqlErrors.map(function(t5) {
                      return u({}, t5, { name: "SPARQL Error: " + t5.name });
                    }));
                  }
                }
              }, r3.$resetState = function() {
                r3.stardogGraphQlErrors = [], r3.sparqlErrors = [];
              }, r3.validateVisitor(), r3;
            }
            return a(r2, t3), r2;
          }(t2))();
        };
        n.d(e, "a", function() {
          return h;
        });
        var L = function() {
          var t2 = function(e2, n2) {
            return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
              t3.__proto__ = e3;
            } || function(t3, e3) {
              for (var n3 in e3)
                e3.hasOwnProperty(n3) && (t3[n3] = e3[n3]);
            })(e2, n2);
          };
          return function(e2, n2) {
            function r2() {
              this.constructor = e2;
            }
            t2(e2, n2), e2.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
          };
        }(), S = n(57).stardogGraphQlTokens, h = function(t2) {
          function StardogGraphQlParser(e2) {
            var n2 = t2.call(this, e2, S) || this;
            return n2.visitCst = function(t3) {
              if (n2.stardogGraphQlVisitor)
                n2.stardogGraphQlVisitor.$resetState();
              else {
                var e3 = n2.getBaseCstVisitorConstructorWithDefaults();
                n2.stardogGraphQlVisitor = f(e3, n2);
              }
              return n2.stardogGraphQlVisitor.visit(t3, n2.input);
            }, n2.parse = function(t3, e3) {
              void 0 === e3 && (e3 = n2.Document), n2.input = n2.tokenize(t3);
              var r2 = e3.call(n2), i2 = n2.visitCst(r2), o2 = i2.sparqlErrors, a2 = i2.stardogGraphQlErrors;
              return { errors: n2.errors.concat(a2, o2), cst: r2 };
            }, n2.performSelfAnalysis(), n2;
          }
          return L(StardogGraphQlParser, t2), StardogGraphQlParser;
        }(BaseGraphQlParser.a);
      }, function(t, e, n) {
        "use strict";
        const r = /[|\\{}()[\]^$+*?.-]/g;
        t.exports = (t2) => {
          if ("string" != typeof t2)
            throw new TypeError("Expected a string");
          return t2.replace(r, "\\$&");
        };
      }, function(t, e) {
        var n;
        n = function() {
          return this;
        }();
        try {
          n = n || new Function("return this")();
        } catch (t2) {
          "object" == typeof window && (n = window);
        }
        t.exports = n;
      }, function(t, e) {
        t.exports = function(t2) {
          return t2.webpackPolyfill || (t2.deprecate = function() {
          }, t2.paths = [], t2.children || (t2.children = []), Object.defineProperty(t2, "loaded", { enumerable: true, get: function() {
            return t2.l;
          } }), Object.defineProperty(t2, "id", { enumerable: true, get: function() {
            return t2.i;
          } }), t2.webpackPolyfill = 1), t2;
        };
      }, function(t, e, n) {
        "use strict";
        n.r(e), n.d(e, "sparqlTokens", function() {
          return d;
        }), n.d(e, "turtleTokens", function() {
          return O;
        }), n.d(e, "srsTokens", function() {
          return N;
        }), n.d(e, "trigTokens", function() {
          return A;
        }), n.d(e, "smsTokens", function() {
          return m;
        }), n.d(e, "shaclTokens", function() {
          return C;
        }), n.d(e, "graphQlTokens", function() {
          return I;
        });
        var r = n(21);
        n.d(e, "BaseSparqlParser", function() {
          return r.a;
        });
        var i = n(36);
        n.d(e, "StardogSparqlParser", function() {
          return i.a;
        });
        var o = n(53);
        n.d(e, "W3SpecSparqlParser", function() {
          return o.a;
        });
        var a = n(35);
        n.d(e, "TurtleParser", function() {
          return a.a;
        });
        var u = n(65);
        n.d(e, "SrsParser", function() {
          return u.a;
        });
        var s = n(60);
        n.d(e, "TrigParser", function() {
          return s.a;
        });
        var c = n(62);
        n.d(e, "SmsParser", function() {
          return c.a;
        });
        var l = n(66);
        n.d(e, "ShaclParser", function() {
          return l.a;
        });
        var E = n(54);
        n.d(e, "BaseGraphQlParser", function() {
          return E.a;
        });
        var p = n(64);
        n.d(e, "StandardGraphQlParser", function() {
          return p.a;
        });
        var f = n(68);
        n.d(e, "StardogGraphQlParser", function() {
          return f.a;
        });
        var L = n(55);
        n.d(e, "graphQlUtils", function() {
          return L.a;
        });
        var S = n(12);
        n.d(e, "traverse", function() {
          return S.d;
        }), n.d(e, "unsafeTraverse", function() {
          return S.e;
        }), n.d(e, "isCstNode", function() {
          return S.b;
        }), n.d(e, "isIToken", function() {
          return S.c;
        }), n.d(e, "getFirstChildCstElementByRuleStack", function() {
          return S.a;
        });
        var h = n(26);
        n.d(e, "getAsTypedTuple", function() {
          return h.d;
        }), n.d(e, "IToken", function() {
          return h.b;
        }), n.d(e, "CstNode", function() {
          return h.a;
        }), n.d(e, "TokenType", function() {
          return h.c;
        });
        var T = n(0);
        n.d(e, "sparqlKeywords", function() {
          return T.keywords;
        });
        var U = n(5);
        n.d(e, "sparqlTerminals", function() {
          return U.terminals;
        });
        var R = n(3);
        n.d(e, "matchers", function() {
          return R;
        });
        var d = n(9), O = n(27), N = n(59), A = n(61), m = n(63), C = n(67), I = n(57);
      }]);
    });
  }
});

// src/extension.ts
var extension_exports = {};
__export(extension_exports, {
  activate: () => activate3,
  deactivate: () => deactivate2
});
module.exports = __toCommonJS(extension_exports);

// src/extension/resource-module.ts
var import_vscode = require("vscode");
var ResourceModule = class {
  static activate(context) {
    import_vscode.commands.registerCommand("mentor.command.browseResource", (uri) => import_vscode.commands.executeCommand("open", import_vscode.Uri.parse(uri)));
    import_vscode.commands.registerCommand("mentor.command.openExternal", (uri) => import_vscode.env.openExternal(import_vscode.Uri.parse(uri)));
    import_vscode.commands.registerCommand("mentor.command.setNamespaceColor", (uri) => {
      import_vscode.commands.executeCommand("editor.action.showOrFocusStandaloneColorPicker").then((value) => {
        console.debug(value);
      });
    });
  }
};

// src/extension/class-module.ts
var import_vscode3 = require("vscode");

// src/extension/class-node-provider.ts
var import_mentor_rdf3 = __toESM(require_dist());

// src/extension/class-node.ts
var vscode2 = __toESM(require("vscode"));

// src/extension/resource-node.ts
var vscode = __toESM(require("vscode"));
init_src();
var import_mentor_rdf = __toESM(require_dist());

// src/utilities.ts
var import_vscode2 = require("vscode");
function getUri(webview, extensionUri, pathList) {
  return webview.asWebviewUri(import_vscode2.Uri.joinPath(extensionUri, ...pathList));
}
function getNonce() {
  let text = "";
  const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  for (let i = 0; i < 32; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}
function getNamespaceUri(uri) {
  if (!uri) {
    return uri;
  }
  let u = uri;
  let n = u.indexOf("?");
  if (n > -1) {
    u = uri.substring(0, n);
  }
  n = u.indexOf("#");
  if (n > -1) {
    return u.substring(0, n + 1);
  }
  n = u.lastIndexOf("/");
  if (n > 8) {
    return u.substring(0, n + 1);
  } else {
    return u + "/";
  }
}
function toJsonId(uri) {
  if (!uri) {
    return uri;
  }
  let u = uri.split("//")[1];
  u = u.replace(/[^a-zA-Z0-9]/g, ".");
  return u.endsWith(".") ? u.slice(0, -1) : u;
}
function getSortedWorkspaceFolders() {
  const folders = import_vscode2.workspace.workspaceFolders ? import_vscode2.workspace.workspaceFolders.map((folder) => {
    let result = folder.uri.toString();
    if (result.charAt(result.length - 1) !== "/") {
      result = result + "/";
    }
    return result;
  }).sort((a, b) => {
    return a.length - b.length;
  }) : [];
  return folders;
}
function getOuterMostWorkspaceFolder(folder) {
  const sorted = getSortedWorkspaceFolders();
  for (const element of sorted) {
    let uri = folder.uri.toString();
    if (uri.charAt(uri.length - 1) !== "/") {
      uri = uri + "/";
    }
    if (uri.startsWith(element)) {
      return import_vscode2.workspace.getWorkspaceFolder(import_vscode2.Uri.parse(element));
    }
  }
  return folder;
}

// src/extension/resource-node.ts
var ResourceNode = class extends vscode.TreeItem {
  constructor(repository, uri) {
    super("");
    this.repository = repository;
    this.uri = uri;
    this.contextValue = "resource";
    this.iconPath = this.getIcon();
    this.label = this.getLabel();
    this.tooltip = this.getTooltip();
    this.command = {
      command: "mentor.command.selectResource",
      title: "",
      arguments: [uri]
    };
  }
  getLabel() {
    let label;
    const n = this.uri.lastIndexOf("#");
    if (n > -1) {
      label = this.uri.substring(n + 1);
    } else {
      label = this.uri.substring(this.uri.lastIndexOf("/") + 1);
    }
    return {
      label,
      highlights: this.uri.length > 1 ? [[this.uri.length - 2, this.uri.length - 1]] : void 0
    };
  }
  getTooltip() {
    let result = "";
    if (this.repository) {
      const s = N3DataFactory_default.namedNode(this.uri);
      for (let d of this.repository.store.match(s, import_mentor_rdf.skos.definition, null, null)) {
        result += d.object.value;
        break;
      }
      if (!result) {
        for (let d of this.repository.store.match(s, import_mentor_rdf.rdfs.comment, null, null)) {
          result += d.object.value;
          break;
        }
      }
    }
    if (result) {
      result += "\n\n";
    }
    result += this.uri;
    return new vscode.MarkdownString(result, true);
  }
  getColor() {
    const id = toJsonId(getNamespaceUri(this.uri));
    return new vscode.ThemeColor("mentor.color." + id);
  }
  getIcon() {
    return new vscode.ThemeIcon("primitive-square", this.getColor());
  }
};

// src/extension/class-node.ts
var ClassNode = class extends ResourceNode {
  constructor(repository, uri) {
    super(repository, uri);
    this.repository = repository;
    this.uri = uri;
    this.contextValue = "class";
    this.collapsibleState = this.repository.hasSubClasses(uri) ? vscode2.TreeItemCollapsibleState.Collapsed : vscode2.TreeItemCollapsibleState.None;
    this.command = {
      command: "mentor.command.selectClass",
      title: "",
      arguments: [uri]
    };
  }
  getIcon() {
    let icon = "rdf-class";
    if (this.repository.hasEquivalentClass(this.uri)) {
      icon += "-eq";
    } else if (!this.repository.hasSubject(this.uri)) {
      icon += "-ref";
    }
    return new vscode2.ThemeIcon(icon, this.getColor());
  }
};

// src/extension/resource-node-provider.ts
var vscode4 = __toESM(require("vscode"));

// src/extension/mentor.ts
var vscode3 = __toESM(require("vscode"));
var path = __toESM(require("path"));
init_src();
var import_mentor_rdf2 = __toESM(require_dist());
var VocabularyContext = class {
  constructor(document, store) {
    /**
     * All namespaces defined in the document.
     */
    this.namespaces = {};
    /**
     * Maps resource URIs to indexed tokens.
     */
    this.tokens = {};
    this.document = document;
    this.store = store;
    this._parseTokens(document);
  }
  _parseTokens(document) {
    const text = document.getText();
    const tokens = new N3Lexer().tokenize(text);
    tokens.forEach((t, i) => {
      if (!t.value) {
        return;
      }
      let v = t.value;
      switch (t.type) {
        case "prefix": {
          let u = tokens[i + 1].value;
          if (u) {
            this.namespaces[v] = u;
          }
          break;
        }
        case "prefixed": {
          if (t.prefix) {
            v = this.namespaces[t.prefix] + t.value;
            if (!this.tokens[v]) {
              this.tokens[v] = [];
            }
            this.tokens[v].push(t);
          }
          break;
        }
        case "IRI": {
          if (!this.tokens[v]) {
            this.tokens[v] = [];
          }
          this.tokens[v].push(t);
          break;
        }
      }
    });
  }
};
var MentorExtension = class {
  constructor() {
    /**
     * Maps document URIs to loaded document contexts.
     */
    this.contexts = {};
    this._onDidChangeDocumentContext = new vscode3.EventEmitter();
    this.onDidChangeVocabularyContext = this._onDidChangeDocumentContext.event;
    vscode3.workspace.onDidChangeTextDocument((e) => this.onTextDocumentChanged(e));
    vscode3.window.onDidChangeActiveTextEditor(() => this.onActiveEditorChanged());
    this.onActiveEditorChanged();
  }
  onActiveEditorChanged() {
    if (!vscode3.window.activeTextEditor) {
      return;
    }
    const editor = vscode3.window.activeTextEditor;
    if (editor.document == this.activeContext?.document) {
      return;
    }
    if (!this._canLoadDocument(editor.document.uri)) {
      return;
    }
    this._loadDocument(editor.document).then((context) => {
      if (context) {
        this.activeContext = context;
        this._onDidChangeDocumentContext?.fire(context);
      }
    });
  }
  onTextDocumentChanged(e) {
    if (!this._canLoadDocument(e.document.uri)) {
      return;
    }
    this._loadDocument(e.document, true).then((context) => {
      if (context) {
        this._onDidChangeDocumentContext?.fire(context);
      }
    });
  }
  /**
   * Indicates whether a document with the given URI can be loaded.
   * @param uri A document URI.
   * @returns <c>true</c> if the document can be loaded, <c>false</c> otherwise.
   */
  _canLoadDocument(uri) {
    if (!uri || uri.scheme !== "file") {
      return false;
    }
    const ext = path.extname(uri.fsPath);
    return ext === ".ttl" || ext === ".nt";
  }
  async _loadDocument(document, reload = false) {
    if (!document) {
      return;
    }
    const uri = document.uri.toString();
    let context = this.contexts[uri];
    if (context && !reload) {
      return context;
    }
    const store = await import_mentor_rdf2.StoreFactory.createFromStream(document.getText(), uri);
    new import_mentor_rdf2.OwlReasoner().expand(store, uri, uri + "#inference");
    context = new VocabularyContext(document, store);
    this.contexts[uri] = context;
    this.activeContext = context;
    return context;
  }
};
var mentor = new MentorExtension();

// src/extension/resource-node-provider.ts
var ResourceNodeProvider = class {
  constructor() {
    this.nodes = {};
    this.showReferenced = false;
    this.autoRefresh = true;
    this._onDidChangeTreeData = new vscode4.EventEmitter();
    this.onDidChangeTreeData = this._onDidChangeTreeData.event;
    mentor.onDidChangeVocabularyContext((context) => this._onVocabularyChanged(context));
    if (mentor.activeContext) {
      this._onVocabularyChanged(mentor.activeContext);
    }
  }
  _onVocabularyChanged(e) {
    if (e) {
      this.context = e;
      this.repository = this.getRepository(e);
      this.refresh();
    }
  }
  toggleReferenced() {
    this.showReferenced = !this.showReferenced;
  }
  refresh() {
    this._onDidChangeTreeData.fire(void 0);
  }
  select(uri) {
    if (this.context && this.context.tokens[uri]) {
      const context = this.context;
      this.activateDocument().then((editor) => {
        const token = context.tokens[uri].sort((a, b) => a.start - b.start)[0];
        const text = token.type == "prefixed" ? `${token.prefix}:${token.value}` : `<${token.value}>`;
        const n = token.line - 1;
        const line = context.document.lineAt(n);
        const start = line.text.indexOf(text);
        const end = start + text.length;
        const range = new vscode4.Range(n, start, n, end);
        if (editor) {
          editor.selection = new vscode4.Selection(range.start, range.end);
          editor.revealRange(range, vscode4.TextEditorRevealType.InCenter);
        }
      });
    }
  }
  async activateDocument() {
    const activeTextEditor = vscode4.window.activeTextEditor;
    if (activeTextEditor?.document != this.context?.document) {
      await vscode4.commands.executeCommand("vscode.open", this.context?.document.uri);
    }
    return activeTextEditor;
  }
  getNode(uri) {
    if (!this.nodes[uri]) {
      this.nodes[uri] = uri;
    }
    return this.nodes[uri];
  }
};

// src/extension/class-node-provider.ts
var ClassNodeProvider = class extends ResourceNodeProvider {
  getRepository(context) {
    return new import_mentor_rdf3.ClassRepository(context.store);
  }
  getParent(uri) {
    return void 0;
  }
  getChildren(uri) {
    if (!this.repository) {
      return [];
    }
    let result = this.repository.getSubClasses(uri).sort().map((u) => this.getNode(u));
    if (!this.showReferenced) {
      result = result.filter((u) => this.repository?.hasSubject(u) || this.repository?.hasSubClasses(u));
    }
    return result;
  }
  getTreeItem(uri) {
    if (!this.repository) {
      throw new Error("Invalid repostory.");
    }
    return new ClassNode(this.repository, uri);
  }
};

// src/extension/class-module.ts
var ClassModule = class {
  static activate(context) {
    const classProvider = new ClassNodeProvider();
    import_vscode3.window.registerTreeDataProvider("mentor.classExplorer", classProvider);
    import_vscode3.commands.registerCommand("mentor.command.selectClass", (uri) => classProvider.select(uri));
    import_vscode3.commands.registerCommand("mentor.classExplorer.command.addEntry", () => import_vscode3.window.showInformationMessage(`Successfully called add entry.`));
    import_vscode3.commands.registerCommand("mentor.classExplorer.command.editEntry", (node) => import_vscode3.window.showInformationMessage(`Successfully called edit entry on ${node}.`));
    import_vscode3.commands.registerCommand("mentor.classExplorer.command.deleteEntry", (node) => import_vscode3.window.showInformationMessage(`Successfully called delete entry on ${node}.`));
    import_vscode3.commands.registerCommand("mentor.classExplorer.command.refreshEntry", () => classProvider.refresh());
    import_vscode3.commands.registerCommand("mentor.classExplorer.command.toggleReferenced", () => {
      classProvider.toggleReferenced();
      classProvider.refresh();
    });
  }
};

// src/extension/property-module.ts
var import_vscode4 = require("vscode");

// src/extension/property-node-provider.ts
var import_mentor_rdf5 = __toESM(require_dist());

// src/extension/property-node.ts
var vscode5 = __toESM(require("vscode"));
var import_mentor_rdf4 = __toESM(require_dist());
var PropertyNode = class extends ResourceNode {
  constructor(repository, uri) {
    super(repository, uri);
    this.repository = repository;
    this.uri = uri;
    this.contextValue = "property";
    this.collapsibleState = this.repository.hasSubProperties(uri) ? vscode5.TreeItemCollapsibleState.Collapsed : vscode5.TreeItemCollapsibleState.None;
    this.command = {
      command: "mentor.command.selectProperty",
      title: "",
      arguments: [uri]
    };
  }
  getIcon() {
    let icon = "arrow-right";
    const range = this.repository.getRange(this.uri);
    switch (range) {
      case import_mentor_rdf4.xsd.date.id:
      case import_mentor_rdf4.xsd.dateTime.id: {
        icon = "calendar";
        break;
      }
      case import_mentor_rdf4.xsd.byte.id:
      case import_mentor_rdf4.xsd.decimal.id:
      case import_mentor_rdf4.xsd.double.id:
      case import_mentor_rdf4.xsd.float.id:
      case import_mentor_rdf4.xsd.int.id:
      case import_mentor_rdf4.xsd.integer.id:
      case import_mentor_rdf4.xsd.short.id:
      case import_mentor_rdf4.xsd.unsignedInt.id:
      case import_mentor_rdf4.xsd.unsignedShort.id:
      case import_mentor_rdf4.xsd.unsingedLong.id:
      case import_mentor_rdf4.xsd.usignedByte.id: {
        icon = "symbol-number";
        break;
      }
      case import_mentor_rdf4.xsd.boolean.id: {
        icon = "symbol-boolean";
        break;
      }
      case import_mentor_rdf4.xsd.string.id: {
        icon = "symbol-text";
        break;
      }
      case import_mentor_rdf4.xsd.base64Binary.id: {
        icon = "file-binary";
        break;
      }
    }
    return new vscode5.ThemeIcon(icon, this.getColor());
  }
};

// src/extension/property-node-provider.ts
var PropertyNodeProvider = class extends ResourceNodeProvider {
  getRepository(context) {
    return new import_mentor_rdf5.PropertyRepository(context.store);
  }
  getParent(uri) {
    return void 0;
  }
  getChildren(uri) {
    if (!this.repository) {
      return [];
    }
    let result = this.repository.getSubProperties(uri).sort().map((u) => this.getNode(u));
    if (!this.showReferenced) {
      result = result.filter((u) => this.repository?.hasSubject(u));
    }
    return result;
  }
  getTreeItem(uri) {
    if (!this.repository) {
      throw new Error("Invalid repostory.");
    }
    return new PropertyNode(this.repository, uri);
  }
};

// src/extension/property-module.ts
var PropertyModule = class {
  static activate(context) {
    const propertyProvider = new PropertyNodeProvider();
    import_vscode4.window.registerTreeDataProvider("mentor.propertyExplorer", propertyProvider);
    import_vscode4.commands.registerCommand("mentor.command.selectProperty", (uri) => propertyProvider.select(uri));
    import_vscode4.commands.registerCommand("mentor.propertyExplorer.command.addEntry", () => import_vscode4.window.showInformationMessage(`Successfully called add entry.`));
    import_vscode4.commands.registerCommand("mentor.propertyExplorer.command.editEntry", (node) => import_vscode4.window.showInformationMessage(`Successfully called edit entry on ${node}.`));
    import_vscode4.commands.registerCommand("mentor.propertyExplorer.command.deleteEntry", (node) => import_vscode4.window.showInformationMessage(`Successfully called delete entry on ${node}.`));
    import_vscode4.commands.registerCommand("mentor.propertyExplorer.command.refreshEntry", () => propertyProvider.refresh());
    import_vscode4.commands.registerCommand("mentor.propertyExplorer.command.toggleReferenced", () => {
      propertyProvider.toggleReferenced();
      propertyProvider.refresh();
    });
  }
};

// src/extension/individual-module.ts
var import_vscode5 = require("vscode");

// src/extension/individual-node-provider.ts
var import_mentor_rdf6 = __toESM(require_dist());

// src/extension/individual-node.ts
var vscode6 = __toESM(require("vscode"));
var IndividualNode = class extends ResourceNode {
  constructor(repository, uri) {
    super(repository, uri);
    this.repository = repository;
    this.uri = uri;
    this.contextValue = "individual";
    this.collapsibleState = vscode6.TreeItemCollapsibleState.None;
    this.command = {
      command: "mentor.command.selectIndividual",
      title: "",
      arguments: [uri]
    };
  }
  getIcon() {
    return new vscode6.ThemeIcon("rdf-individual", this.getColor());
  }
};

// src/extension/individual-node-provider.ts
var IndividualNodeProvider = class extends ResourceNodeProvider {
  getRepository(context) {
    return new import_mentor_rdf6.IndividualRepository(context.store);
  }
  getParent(uri) {
    return void 0;
  }
  getChildren(uri) {
    if (!this.repository) {
      return [];
    }
    let result = this.repository.getIndividuals().sort().map((u) => this.getNode(u));
    if (!this.showReferenced) {
      result = result.filter((u) => this.repository?.hasSubject(u));
    }
    return result;
  }
  getTreeItem(uri) {
    if (!this.repository) {
      throw new Error("Invalid repostory.");
    }
    return new IndividualNode(this.repository, uri);
  }
};

// src/extension/individual-module.ts
var IndividualModule = class {
  static activate(context) {
    const individualProvider = new IndividualNodeProvider();
    import_vscode5.window.registerTreeDataProvider("mentor.individualExplorer", individualProvider);
    import_vscode5.commands.registerCommand("mentor.command.selectIndividual", (uri) => individualProvider.select(uri));
    import_vscode5.commands.registerCommand("mentor.individualExplorer.command.addEntry", () => import_vscode5.window.showInformationMessage(`Successfully called add entry.`));
    import_vscode5.commands.registerCommand("mentor.individualExplorer.command.editEntry", (node) => import_vscode5.window.showInformationMessage(`Successfully called edit entry on ${node}.`));
    import_vscode5.commands.registerCommand("mentor.individualExplorer.command.deleteEntry", (node) => import_vscode5.window.showInformationMessage(`Successfully called delete entry on ${node}.`));
    import_vscode5.commands.registerCommand("mentor.individualExplorer.command.refreshEntry", () => individualProvider.refresh());
    import_vscode5.commands.registerCommand("mentor.individualExplorer.command.toggleReferenced", () => {
      individualProvider.toggleReferenced();
      individualProvider.refresh();
    });
  }
};

// src/extension/settings-module.ts
var import_vscode7 = require("vscode");

// src/extension/panels/SettingsPanel.ts
var import_vscode6 = require("vscode");
var SettingsPanel = class {
  /**
   * The ComponentGalleryPanel class private constructor (called only from the render method).
   *
   * @param panel A reference to the webview panel
   * @param extensionUri The URI of the directory containing the extension
   */
  constructor(panel, extensionUri) {
    this._disposables = [];
    this._panel = panel;
    this._panel.onDidDispose(() => this.dispose(), null, this._disposables);
    this._panel.webview.html = this._getWebviewContent(this._panel.webview, extensionUri);
  }
  /**
   * Renders the current webview panel if it exists otherwise a new webview panel
   * will be created and displayed.
   *
   * @param extensionUri The URI of the directory containing the extension.
   */
  static render(extensionUri) {
    if (SettingsPanel.currentPanel) {
      SettingsPanel.currentPanel._panel.reveal(import_vscode6.ViewColumn.One);
    } else {
      const panel = import_vscode6.window.createWebviewPanel(
        // Panel view type
        "mentor.view.settings",
        // Panel title
        "Mentor Settings",
        // The editor column the panel should be displayed in
        import_vscode6.ViewColumn.One,
        // Extra panel configurations
        {
          // Enable JavaScript in the webview
          enableScripts: true,
          // Restrict the webview to only load resources from the `out` directory
          localResourceRoots: [import_vscode6.Uri.joinPath(extensionUri, "out")]
        }
      );
      SettingsPanel.currentPanel = new SettingsPanel(panel, extensionUri);
    }
  }
  /**
   * Cleans up and disposes of webview resources when the webview panel is closed.
   */
  dispose() {
    SettingsPanel.currentPanel = void 0;
    this._panel.dispose();
    while (this._disposables.length) {
      const disposable = this._disposables.pop();
      if (disposable) {
        disposable.dispose();
      }
    }
  }
  /**
   * Defines and returns the HTML that should be rendered within the webview panel.
   *
   * @remarks This is also the place where *references* to CSS and JavaScript files
   * are created and inserted into the webview HTML.
   *
   * @param webview A reference to the extension webview
   * @param extensionUri The URI of the directory containing the extension
   * @returns A template string literal containing the HTML that should be
   * rendered within the webview panel
   */
  _getWebviewContent(webview, extensionUri) {
    const webviewUri = getUri(webview, extensionUri, ["out", "webview.js"]);
    const styleUri = getUri(webview, extensionUri, ["out", "style.css"]);
    const codiconUri = getUri(webview, extensionUri, ["out", "codicon.css"]);
    const nonce = getNonce();
    return (
      /*html*/
      `
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource}; font-src ${webview.cspSource}; script-src 'nonce-${nonce}';">
          <link rel="stylesheet" href="${styleUri}">
          <link rel="stylesheet" href="${codiconUri}">
          <title>Mentor Settings 2</title>
        </head>
        <body>
          <section class="component-container">
            <h2>Namespaces</h2>
            <section class="component-example">
              <vscode-data-grid class="basic-grid" generate-header="sticky" grid-template-columns="100px 1fr 2fr" aria-label="With Sticky Header"></vscode-data-grid>
            </section>
          </section>
          <script type="module" nonce="${nonce}" src="${webviewUri}"></script>
        </body>
      </html>
    `
    );
  }
};

// src/extension/panels/SettingsViewProvider.ts
var SettingsViewProvider = class {
  constructor(_extensionUri) {
    this._extensionUri = _extensionUri;
  }
  resolveWebviewView(webviewView, context, _token) {
    this._view = webviewView;
    webviewView.webview.options = {
      // Allow scripts in the webview
      enableScripts: true,
      localResourceRoots: [
        this._extensionUri
      ]
    };
    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);
  }
  _getHtmlForWebview(webview) {
    const webviewUri = getUri(webview, this._extensionUri, ["out", "webview.js"]);
    const styleUri = getUri(webview, this._extensionUri, ["out", "style.css"]);
    const codiconUri = getUri(webview, this._extensionUri, ["out", "codicon.css"]);
    const nonce = getNonce();
    return (
      /*html*/
      `
		  <!DOCTYPE html>
		  <html lang="en">
			<head>
			  <meta charset="UTF-8">
			  <meta name="viewport" content="width=device-width, initial-scale=1.0">
			  <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource}; font-src ${webview.cspSource}; script-src 'nonce-${nonce}';">
			  <link rel="stylesheet" href="${styleUri}">
			  <link rel="stylesheet" href="${codiconUri}">
			  <title>Mentor Settings</title>
			</head>
			<body>
			  <vscode-text-field placeholder="Find"></vscode-text-field>
			  <vscode-panels aria-label="With Badge">
				<vscode-panel-tab id="tab-1">
				  Classes
				  <vscode-badge>1</vscode-badge>
				</vscode-panel-tab>
				<vscode-panel-tab id="tab-2">
				  Properties
				  <vscode-badge>1</vscode-badge>
				</vscode-panel-tab>
				<vscode-panel-tab id="tab-3">
				  Individuals
				</vscode-panel-tab>
				<vscode-panel-view id="view-1"></vscode-panel-view>
				<vscode-panel-view id="view-2"></vscode-panel-view>
				<vscode-panel-view id="view-3"></vscode-panel-view>
			  </vscode-panels>
			  <script type="module" nonce="${nonce}" src="${webviewUri}"></script>
			</body>
		  </html>
		`
    );
  }
};
SettingsViewProvider.viewType = "mentor.view.settings";

// src/extension/settings-module.ts
var SettingsModule = class {
  static activate(context) {
    const command = () => {
      SettingsPanel.render(context.extensionUri);
    };
    const showGalleryCommand = import_vscode7.commands.registerCommand("mentor.command.openSettings", command);
    context.subscriptions.push(showGalleryCommand);
    const settingsViewProvider = new SettingsViewProvider(context.extensionUri);
    const settingsDisposable = import_vscode7.window.registerWebviewViewProvider(SettingsViewProvider.viewType, settingsViewProvider);
    context.subscriptions.push(settingsDisposable);
  }
};

// src/language-turtle/client.ts
var path2 = __toESM(require("path"));
var vscode8 = __toESM(require("vscode"));

// src/language-client.ts
var vscode7 = __toESM(require("vscode"));
var import_node = __toESM(require_node3());
var LanguageClientBase = class {
  constructor(workspaceFolder) {
    /**
     * The channel ID for logging.
     */
    this.channelName = "Mentor Language";
    /**
     * The channel ID for logging.
     */
    this.channelId = "mentor.language";
    this.channel = vscode7.window.createOutputChannel(this.channelName, this.channelId);
    this.workspaceFolder = workspaceFolder;
  }
  activate(context) {
    const module2 = context.asAbsolutePath(this.serverPath);
    const serverOptions = {
      run: { module: module2, transport: import_node.TransportKind.ipc },
      debug: { module: module2, transport: import_node.TransportKind.ipc }
    };
    const clientOptions = {
      diagnosticCollectionName: this.channelId,
      documentSelector: [{ language: this.languageId }],
      workspaceFolder: this.workspaceFolder,
      outputChannel: this.channel
    };
    this.client = new import_node.LanguageClient(this.channelId, `${this.languageName} Language Client`, serverOptions, clientOptions);
    this.client.start();
  }
  async deactivate() {
    if (this.client) {
      await this.client.stop();
    }
  }
};

// src/language-turtle/client.ts
var clients = /* @__PURE__ */ new Map();
var TurtleLanguageClient = class extends LanguageClientBase {
  get serverPath() {
    return path2.join("out", "turtle-server.js");
  }
  get languageName() {
    return "Turtle";
  }
  get languageId() {
    return "turtle";
  }
};
function activate(context) {
  function didOpenTextDocument(document) {
    if (document.languageId !== "turtle") {
      return;
    }
    let folder = vscode8.workspace.getWorkspaceFolder(document.uri);
    if (!folder) {
      return;
    }
    folder = getOuterMostWorkspaceFolder(folder);
    if (clients.has(folder.uri.toString())) {
      return;
    }
    let client = new TurtleLanguageClient(folder);
    client.activate(context);
    clients.set(folder.uri.toString(), client);
  }
  vscode8.workspace.onDidOpenTextDocument(didOpenTextDocument);
  vscode8.workspace.textDocuments.forEach(didOpenTextDocument);
  vscode8.workspace.onDidChangeWorkspaceFolders((event) => {
    for (const folder of event.removed.map((f) => f.uri.toString())) {
      const client = clients.get(folder);
      if (client) {
        clients.delete(folder);
        client.deactivate();
      }
    }
  });
}
function deactivate() {
  const promises = [];
  for (const client of clients.values()) {
    promises.push(client.deactivate());
  }
  return Promise.all(promises).then(() => void 0);
}

// src/language-turtle/token-provider.ts
var vscode9 = __toESM(require("vscode"));
var import_millan = __toESM(require_millan());
var tokenTypes = ["keyword", "namespace", "class", "property", "label", "comment", "string", "number", "variable", "decorator", "operator", "const", "enumMember", "typeParameter"];
var tokenModifiers = ["definition", "declaration", "documentation", "readonly", "modification", "async", "defaultLibrary"];
var legend = new vscode9.SemanticTokensLegend(tokenTypes, tokenModifiers);
var provider = {
  provideDocumentSemanticTokens(document) {
    const parser = new import_millan.TurtleParser();
    parser.parse(document.getText(), "standard");
    const tokens = parser.input;
    const tokensBuilder = new vscode9.SemanticTokensBuilder(legend);
    let lastToken = void 0;
    for (let t of tokens) {
      try {
        const startLine = t.startLine ? t.startLine - 1 : 0;
        const startColumn = t.startColumn ? t.startColumn - 1 : 0;
        const endLine = t.endLine ? t.endLine - 1 : 0;
        const endColumn = t.endColumn ? t.endColumn : 0;
        const start = new vscode9.Position(startLine, startColumn);
        const end = new vscode9.Position(endLine, endColumn);
        const token = t.tokenType?.tokenName;
        if (!token) {
          continue;
        }
        switch (token) {
          case "A":
          case "TTL_PREFIX":
            tokensBuilder.push(new vscode9.Range(start, end), "keyword");
            break;
          case "PNAME_NS":
            tokensBuilder.push(new vscode9.Range(start, end), "namespace", ["definition"]);
            break;
          case "PNAME_LN":
            const p = t.image.split(":")[0];
            if (lastToken === "DoubleCaret") {
              tokensBuilder.push(new vscode9.Range(start, end), "decorator");
            } else {
              tokensBuilder.push(new vscode9.Range(new vscode9.Position(startLine, startColumn), new vscode9.Position(startLine, startColumn + p.length + 1)), "namespace", ["declaration"]);
              tokensBuilder.push(new vscode9.Range(new vscode9.Position(startLine, startColumn + p.length + 1), new vscode9.Position(startLine, endColumn)), "label", []);
            }
            break;
          case "IRIREF":
            if (lastToken === "DoubleCaret") {
              tokensBuilder.push(new vscode9.Range(start, end), "decorator");
            } else {
              tokensBuilder.push(new vscode9.Range(start, end), "enumMember", ["readonly"]);
            }
            break;
          case "STRING_LITERAL_QUOTE":
            tokensBuilder.push(new vscode9.Range(start, end), "string");
            break;
          case "DoubleCaret":
          case "LANGTAG":
            tokensBuilder.push(new vscode9.Range(start, end), "decorator");
            break;
          case "INTEGER":
          case "DECIMAL":
          case "DOUBLE":
            tokensBuilder.push(new vscode9.Range(start, end), "number");
            break;
          case "COMMENT":
            tokensBuilder.push(new vscode9.Range(start, end), "comment");
            break;
          default:
            continue;
        }
        lastToken = token;
      } catch (e) {
        console.log(e);
        continue;
      }
    }
    return tokensBuilder.build();
  }
};
function activate2(context) {
  const selector = { language: "turtle" };
  vscode9.languages.registerDocumentSemanticTokensProvider(selector, provider, legend);
}

// src/extension.ts
function activate3(context) {
  SettingsModule.activate(context);
  ResourceModule.activate(context);
  ClassModule.activate(context);
  PropertyModule.activate(context);
  IndividualModule.activate(context);
  activate(context);
  activate2(context);
}
function deactivate2() {
  return deactivate();
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate,
  deactivate
});
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

queue-microtask/index.js:
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=extension.js.map
